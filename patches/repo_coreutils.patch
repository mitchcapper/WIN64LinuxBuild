diff --git a/src/cat.c b/src/cat.c
index c02210301..cbdfae75f 100644
--- a/src/cat.c
+++ b/src/cat.c
@@ -717,6 +717,7 @@ main (int argc, char **argv)
           && have_out_dev
           && stat_buf.st_dev == out_dev && stat_buf.st_ino == out_ino)
         {
+#ifndef _WIN32
           off_t in_pos = lseek (input_desc, 0, SEEK_CUR);
           if (0 <= in_pos)
             {
@@ -725,6 +726,9 @@ main (int argc, char **argv)
               int whence = (0 <= out_flags && out_flags & O_APPEND
                             ? SEEK_END : SEEK_CUR);
               if (in_pos < lseek (STDOUT_FILENO, 0, whence))
+#else
+              if (out_isreg && (lseek (input_desc, 0, SEEK_CUR) < stat_buf.st_size)
+#endif
                 {
                   error (0, 0, _("%s: input file is output file"),
                          quotef (infile));
diff --git a/src/copy.c b/src/copy.c
index 22d9830ba..106d6bd59 100644
--- a/src/copy.c
+++ b/src/copy.c
@@ -22,6 +22,10 @@
 #include <sys/types.h>
 #include <selinux/selinux.h>
 
+#ifdef _WIN32
+#define HAVE_LCHOWN 0
+#endif
+
 #if HAVE_HURD_H
 # include <hurd.h>
 #endif
@@ -928,6 +932,9 @@ set_owner (const struct cp_options *x, char const *dst_name,
            struct stat const *src_sb, bool new_dst,
            struct stat const *dst_sb)
 {
+#ifdef _WIN32
+	return 1;
+#endif
   uid_t uid = src_sb->st_uid;
   gid_t gid = src_sb->st_gid;
 
@@ -1271,7 +1278,7 @@ copy_reg (char const *src_name, char const *dst_name,
 
   /* Compare the source dev/ino from the open file to the incoming,
      saved ones obtained via a previous call to stat.  */
-  if (! psame_inode (src_sb, &src_open_sb))
+  if (src_sb->st_ino && ! psame_inode (src_sb, &src_open_sb))
     {
       error (0, 0,
              _("skipping file %s, as it was replaced while being copied"),
@@ -1749,7 +1756,7 @@ same_file_ok (char const *src_name, struct stat const *src_sb,
   struct stat tmp_src_sb;
 
   bool same_link;
-  bool same = psame_inode (src_sb, dst_sb);
+  bool same = src_sb->st_ino && psame_inode (src_sb, dst_sb);
 
   *return_now = false;
 
@@ -1810,7 +1817,7 @@ same_file_ok (char const *src_name, struct stat const *src_sb,
       src_sb_link = &tmp_src_sb;
       dst_sb_link = &tmp_dst_sb;
 
-      same_link = psame_inode (src_sb_link, dst_sb_link);
+      same_link = src_sb_link->st_ino && psame_inode (src_sb_link, dst_sb_link);
 
       /* If both are symlinks, then it's ok, but only if the destination
          will be unlinked before being opened.  This is like the test
@@ -1898,7 +1905,7 @@ same_file_ok (char const *src_name, struct stat const *src_sb,
      hard links to the same file.  */
   if (!S_ISLNK (src_sb_link->st_mode) && !S_ISLNK (dst_sb_link->st_mode))
     {
-      if (!psame_inode (src_sb_link, dst_sb_link))
+      if (!SAME_INODE (*src_sb_link, *dst_sb_link))
         return true;
 
       /* If they are the same file, it's ok if we're making hard links.  */
@@ -1959,7 +1966,7 @@ same_file_ok (char const *src_name, struct stat const *src_sb,
       else if (fstatat (dst_dirfd, dst_relname, &tmp_dst_sb, 0) != 0)
         return true;
 
-      if (!psame_inode (&tmp_src_sb, &tmp_dst_sb))
+      if (tmp_src_sb.st_ino && !psame_inode (&tmp_src_sb, &tmp_dst_sb))
         return true;
 
       if (x->hard_link)
@@ -2179,7 +2186,7 @@ source_is_dst_backup (char const *srcbase, struct stat const *src_st,
   struct stat dst_back_sb;
   int dst_back_status = fstatat (dst_dirfd, dst_back, &dst_back_sb, 0);
   free (dst_back);
-  return dst_back_status == 0 && psame_inode (src_st, &dst_back_sb);
+  return dst_back_status == 0 && src_st->st_ino && psame_inode (src_st, &dst_back_sb);
 }
 
 /* Copy the file SRC_NAME to the file DST_NAME aka DST_DIRFD+DST_RELNAME.
@@ -2254,7 +2261,7 @@ copy_internal (char const *src_name, char const *dst_name,
 
       src_mode = src_sb.st_mode;
 
-      if (S_ISDIR (src_mode) && !x->recursive)
+      if (S_ISHARDDIR(src_mode) && !x->recursive)
         {
           error (0, 0, ! x->install_mode /* cp */
                  ? _("-r not specified; omitting directory %s")
@@ -2277,7 +2284,7 @@ copy_internal (char const *src_name, char const *dst_name,
      This check is enabled only if x->src_info is non-null.  */
   if (command_line_arg && x->src_info)
     {
-      if ( ! S_ISDIR (src_mode)
+      if ( !S_ISHARDDIR(src_mode) 
            && x->backup_type == no_backups
            && seen_file (x->src_info, src_name, &src_sb))
         {
@@ -2360,7 +2367,7 @@ copy_internal (char const *src_name, char const *dst_name,
               return false;
             }
 
-          if (x->update == UPDATE_OLDER && !S_ISDIR (src_mode))
+          if (x->update == UPDATE_OLDER && !S_ISHARDDIR(src_mode))
             {
               /* When preserving timestamps (but not moving within a file
                  system), don't worry if the destination timestamp is
@@ -2883,7 +2890,7 @@ skip:
   if (! set_process_security_ctx (src_name, dst_name, src_mode, new_dst, x))
     return false;
 
-  if (S_ISDIR (src_mode))
+  if (S_ISHARDDIR (src_mode))
     {
       struct dir_list *dir;
 
@@ -2906,7 +2913,7 @@ skip:
       dir->ino = src_sb.st_ino;
       dir->dev = src_sb.st_dev;
 
-      if (new_dst || !S_ISDIR (dst_sb.st_mode))
+      if (new_dst || !S_ISHARDDIR(dst_sb.st_mode))
         {
           /* POSIX says mkdir's behavior is implementation-defined when
              (src_mode & ~S_IRWXUGO) != 0.  However, common practice is
@@ -3015,7 +3022,7 @@ skip:
                             || stat (".", &dot_sb) != 0
                             || (fstatat (dst_dirfd, dst_parent, &dst_parent_sb,
                                          0) != 0)
-                            || psame_inode (&dot_sb, &dst_parent_sb));
+                            || (dot_sb.st_ino && psame_inode (&dot_sb, &dst_parent_sb)));
           free (dst_parent);
 
           if (! in_current_dir)
diff --git a/src/cp.c b/src/cp.c
index a0ec06714..f79e6f3f9 100644
--- a/src/cp.c
+++ b/src/cp.c
@@ -346,6 +346,7 @@ re_protect (char const *const_dst_name, char const *dst_src_name,
 
       if (x->preserve_ownership)
         {
+#ifndef _WIN32
           if (lchownat (dst_dirfd, relname, p->st.st_uid, p->st.st_gid)
               != 0)
             {
@@ -359,6 +360,7 @@ re_protect (char const *const_dst_name, char const *dst_src_name,
                  the group, but ignore the possible error. */
               ignore_value (lchownat (dst_dirfd, relname, -1, p->st.st_gid));
             }
+#endif // !_WIN32
         }
 
       if (x->preserve_mode)
diff --git a/src/csplit.c b/src/csplit.c
index 9119dcf5a..41c57e735 100644
--- a/src/csplit.c
+++ b/src/csplit.c
@@ -1375,7 +1375,11 @@ main (int argc, char **argv)
     static int const sig[] =
       {
         /* The usual suspects.  */
+#ifndef _WIN32
         SIGALRM, SIGHUP, SIGINT, SIGPIPE, SIGQUIT, SIGTERM,
+#else
+      SIGINT,  SIGTERM, SIGPIPE,
+#endif
 #ifdef SIGPOLL
         SIGPOLL,
 #endif
diff --git a/src/dd.c b/src/dd.c
index 4e914336b..6083c20c3 100644
--- a/src/dd.c
+++ b/src/dd.c
@@ -634,6 +634,7 @@ Each FLAG symbol may be:\n\
         fputs (_("  text      use text I/O for data\n"), stdout);
 
       {
+#ifndef _WIN32        
         printf (_("\
 \n\
 Sending a %s signal to a running 'dd' process makes it\n\
@@ -642,6 +643,7 @@ print I/O statistics to standard error and then resume copying.\n\
 Options are:\n\
 \n\
 "), SIGINFO == SIGUSR1 ? "USR1" : "INFO");
+#endif
       }
 
       fputs (HELP_OPTION_DESCRIPTION, stdout);
@@ -862,7 +864,9 @@ siginfo_handler (int sig)
 static void
 install_signal_handlers (void)
 {
+#ifndef _WIN32  
   bool catch_siginfo = ! (SIGINFO == SIGUSR1 && getenv ("POSIXLY_CORRECT"));
+#endif
 
 #if SA_NOCLDSTOP
 
@@ -893,12 +897,13 @@ install_signal_handlers (void)
     }
 
 #else
-
+#ifndef _WIN32
   if (catch_siginfo)
     {
       signal (SIGINFO, siginfo_handler);
       siginterrupt (SIGINFO, 1);
     }
+#endif
   if (signal (SIGINT, SIG_IGN) != SIG_IGN)
     {
       signal (SIGINT, interrupt_handler);
@@ -1175,7 +1180,7 @@ static idx_t
 iwrite (int fd, char const *buf, idx_t size)
 {
   idx_t total_written = 0;
-
+#ifndef _WIN32
   if ((output_flags & O_DIRECT) && size < output_blocksize)
     {
       int old_flags = fcntl (STDOUT_FILENO, F_GETFL);
@@ -1199,7 +1204,7 @@ iwrite (int fd, char const *buf, idx_t size)
       /* After the subsequent fsync we'll call invalidate_cache
          to attempt to clear all data from the page cache.  */
     }
-
+#endif
   while (total_written < size)
     {
       ssize_t nwritten = 0;
@@ -1670,6 +1675,10 @@ scanargs (int argc, char *const *argv)
       || multiple_bits_set (output_flags & (O_DIRECT | O_NOCACHE)))
     error (EXIT_FAILURE, 0, _("cannot combine direct and nocache"));
 
+  if (!(input_flags & O_TEXT)) //default to binary mode (like linux) unless text explicitly set
+	  input_flags |= O_BINARY;
+  if (!(output_flags & O_TEXT)) //default to binary mode (like linux) unless text explicitly set
+	  output_flags |= O_BINARY;
   if (input_flags & O_NOCACHE)
     {
       i_nocache = true;
@@ -2046,12 +2055,17 @@ copy_with_unblock (char const *buf, idx_t nread)
 static void
 set_fd_flags (int fd, int add_flags, char const *name)
 {
+
   /* Ignore file creation flags that are no-ops on file descriptors.  */
   add_flags &= ~ (O_NOCTTY | O_NOFOLLOW);
 
   if (add_flags)
     {
+#ifndef _WIN32
       int old_flags = fcntl (fd, F_GETFL);
+#else
+	  int old_flags = 0;
+#endif // !_WIN32
       int new_flags = old_flags | add_flags;
       bool ok = true;
       if (old_flags < 0)
@@ -2077,15 +2091,22 @@ set_fd_flags (int fd, int add_flags, char const *name)
                 }
               new_flags &= ~ (O_DIRECTORY | O_NOLINKS);
             }
-
+#ifdef _WIN32
+		  if (new_flags & O_TEXT && setmode(fd, O_TEXT) == -1)
+			  ok = false;
+		  if(new_flags & O_BINARY && setmode(fd, O_BINARY) == -1)
+			  ok = false;
+#else
           if (ok && old_flags != new_flags
               && fcntl (fd, F_SETFL, new_flags) == -1)
             ok = false;
+#endif // !_WIN32
         }
 
       if (!ok)
         error (EXIT_FAILURE, errno, _("setting flags for %s"), quoteaf (name));
     }
+
 }
 
 /* The main loop.  */
diff --git a/src/df.c b/src/df.c
index a969c5c9b..f82a0b58f 100644
--- a/src/df.c
+++ b/src/df.c
@@ -745,6 +745,9 @@ filter_mount_list (bool devices_only)
       else
         {
           /* If we've already seen this device...  */
+          #ifdef _WIN32
+            buf.st_dev = me->me_dev;
+          #endif
           struct devlist *seen_dev = devlist_for_dev (buf.st_dev);
 
           if (seen_dev)
@@ -1075,7 +1078,10 @@ get_dev (char const *device, char const *mount_point, char const *file,
             }
         }
     }
-
+#ifdef _WIN32
+    if (fstype == NULL || strcmp(fstype, "-") == 0)
+      fstype = fsu.fsu_fs_type; 
+#endif
   if (fsu.fsu_blocks == 0 && !show_all_fs && !show_listed_fs)
     return;
 
diff --git a/src/digest.c b/src/digest.c
index 1f65c73b4..0dcaefdd7 100644
--- a/src/digest.c
+++ b/src/digest.c
@@ -1367,7 +1367,11 @@ main (int argc, char **argv)
 
   /* Line buffer stdout to ensure lines are written atomically and immediately
      so that processes running in parallel do not intersperse their output.  */
+#ifndef _WIN32
   setvbuf (stdout, nullptr, _IOLBF, 0);
+#else
+  setvbuf(stdout, nullptr, _IONBF, 0); //windows treats _IOLBF the same as _IOFBF in addition a buffer of NULL and size of 0 is invalid unless you are doing IONBF.
+#endif
 
 #if HASH_ALGO_SUM
   char const *short_opts = "rs";
diff --git a/src/du.c b/src/du.c
index 0e5d860a9..bcc0b3629 100644
--- a/src/du.c
+++ b/src/du.c
@@ -412,6 +412,7 @@ print_size (const struct duinfo *pdui, char const *string)
 static void
 fill_mount_table (void)
 {
+  #ifndef _WIN32
   struct mount_entry *mnt_ent = read_file_system_list (false);
   while (mnt_ent)
     {
@@ -432,6 +433,7 @@ fill_mount_table (void)
       mnt_ent = mnt_ent->me_next;
       free_mount_entry (mnt_free);
     }
+    #endif
 }
 
 /* This function checks whether any of the directories in the cycle that
diff --git a/src/env.c b/src/env.c
index 17254c303..8a1f9b615 100644
--- a/src/env.c
+++ b/src/env.c
@@ -53,7 +53,9 @@ enum SIGNAL_MODE {
   UNCHANGED = 0,
   DEFAULT,       /* Set to default handler (SIG_DFL).  */
   DEFAULT_NOERR, /* Ditto, but ignore sigaction(2) errors.  */
+#ifndef _WIN32
   IGNORE,        /* Set to ignore (SIG_IGN).  */
+#endif  
   IGNORE_NOERR   /* Ditto, but ignore sigaction(2) errors.  */
 };
 static enum SIGNAL_MODE *signals;
@@ -551,7 +553,15 @@ parse_signal_action_params (char const *arg, bool set_default)
          Some signals cannot be set to ignore or default (e.g., SIGKILL,
          SIGSTOP on most OSes, and SIGCONT on AIX.) - so ignore errors.  */
       for (int i = 1 ; i <= SIGNUM_BOUND; i++)
+#ifndef _WIN32
         signals[i] = set_default ? DEFAULT_NOERR : IGNORE_NOERR;
+#else
+      {
+        char signame[SIG2STR_MAX];
+        if (sig2str (i, signame) == 0 && set_default)
+          signals[i] = DEFAULT_NOERR;
+      }
+#endif 
       return;
     }
 
@@ -755,7 +765,29 @@ initialize_signals (void)
 
   return;
 }
-
+#ifdef _WIN32
+int clearenv(void)
+{
+	char* envp, * s;
+	char name[MAX_LONG_PATH];
+
+	while (environ && (envp = *environ)) {
+		if ((s = strchr(envp, '=')) != NULL) {
+			strncpy(name, envp, s - envp + 1);
+			strncpy_s(name, sizeof(name), envp, s - envp+1);
+			name[s - envp + 1+1] = 0;
+
+			if (_putenv(name) == -1) {
+				return -1;
+			}
+		}
+		else {
+			return -1;
+		}
+	}
+	return 0;
+}
+#endif
 int
 main (int argc, char **argv)
 {
@@ -839,8 +871,12 @@ main (int argc, char **argv)
   if (ignore_environment)
     {
       devmsg ("cleaning environ\n");
+#ifndef _WIN32
       static char *dummy_environ[] = { nullptr };
       environ = dummy_environ;
+#else
+      clearenv();
+#endif
     }
   else
     unset_envvars ();
diff --git a/src/expr.c b/src/expr.c
index cd87763df..82634ee65 100644
--- a/src/expr.c
+++ b/src/expr.c
@@ -43,7 +43,7 @@
 
 /* Various parts of this code assume size_t fits into unsigned long
    int, the widest unsigned type that GMP supports.  */
-static_assert (SIZE_MAX <= ULONG_MAX);
+static_assert (sizeof(size_t) <= ULONG_MAX);
 
 /* The official name of this program (e.g., no 'g' prefix).  */
 #define PROGRAM_NAME "expr"
diff --git a/src/find-mount-point.c b/src/find-mount-point.c
index 732e3cba7..1d4e3b5a8 100644
--- a/src/find-mount-point.c
+++ b/src/find-mount-point.c
@@ -32,6 +32,11 @@ find_mount_point (char const *file, struct stat const *file_stat)
   struct saved_cwd cwd;
   struct stat last_stat;
   char *mp = nullptr;		/* The malloc'd mount point.  */
+#ifdef _WIN32
+  mp = xmalloc (sizeof (char) * (MAX_PATH));
+  GetVolumePathName (file, mp, MAX_PATH);
+  return mp;
+#endif  
 
   if (save_cwd (&cwd) != 0)
     {
diff --git a/src/install.c b/src/install.c
index b3b26abdb..2b473295c 100644
--- a/src/install.c
+++ b/src/install.c
@@ -21,8 +21,12 @@
 #include <getopt.h>
 #include <sys/types.h>
 #include <signal.h>
+#ifndef _WIN32
 #include <pwd.h>
 #include <grp.h>
+#else
+#include "execute.h"
+#endif
 #include <selinux/label.h>
 #include <sys/wait.h>
 
@@ -191,6 +195,7 @@ need_copy (char const *src_name, char const *dest_name,
       || (dest_sb.st_mode & CHMOD_MODE_BITS) != mode)
     return true;
 
+#ifndef _WIN32
   if (owner_id == (uid_t) -1)
     {
       errno = 0;
@@ -234,7 +239,7 @@ need_copy (char const *src_name, char const *dest_name,
       if (!scontext_match)
         return true;
     }
-
+#endif
   /* compare files content */
   src_fd = open (src_name, O_RDONLY | O_BINARY);
   if (src_fd < 0)
@@ -435,6 +440,9 @@ copy_file (char const *from, char const *to,
 static bool
 change_attributes (char const *name, int dirfd, char const *relname)
 {
+  #ifdef _WIN32
+  return true;
+  #endif
   bool ok = false;
   /* chown must precede chmod because on some systems,
      chown clears the set[ug]id bits for non-superusers,
@@ -492,6 +500,7 @@ strip (char const *name)
 {
   int status;
   bool ok = false;
+  #ifndef _WIN32
   pid_t pid = fork ();
 
   switch (pid)
@@ -517,6 +526,16 @@ strip (char const *name)
         ok = true;      /* strip succeeded */
       break;
     }
+#else
+  const char* const values[] = {strip_program,name, NULL};
+
+
+  status = execute(strip_program,strip_program,values, NULL, NULL, false, false,false,false, true, false, NULL);
+   if (! WIFEXITED (status) || WEXITSTATUS (status))
+        error (0, 0, _("strip process terminated abnormally"));
+      else
+        ok = true;
+#endif    
   return ok;
 }
 
@@ -525,6 +544,7 @@ strip (char const *name)
 static void
 get_ids (void)
 {
+#ifndef _WIN32  
   struct passwd *pw;
   struct group *gr;
 
@@ -565,6 +585,7 @@ get_ids (void)
     }
   else
     group_id = (gid_t) -1;
+#endif    
 }
 
 void
diff --git a/src/ln.c b/src/ln.c
index 76ffc49c0..c4b24420f 100644
--- a/src/ln.c
+++ b/src/ln.c
@@ -259,7 +259,7 @@ do_link (char const *source, int destdir_fd, char const *dest_base,
                   if (source_status != 0)
                     source_status = stat (source, &source_stats);
                   if (source_status == 0
-                      && psame_inode (&source_stats, &dest_stats)
+                      && source_stats.st_ino && psame_inode (&source_stats, &dest_stats)
                       && (source_stats.st_nlink == 1
                           || same_nameat (AT_FDCWD, source,
                                           destdir_fd, dest_base)))
diff --git a/src/ls.c b/src/ls.c
index 23309b812..19418351b 100644
--- a/src/ls.c
+++ b/src/ls.c
@@ -52,7 +52,9 @@
 
 #include <stdio.h>
 #include <setjmp.h>
+#ifndef _WIN32
 #include <pwd.h>
+#endif
 #include <getopt.h>
 #include <signal.h>
 #include <uchar.h>
@@ -1575,12 +1577,14 @@ process_signals (void)
       /* SIGTSTP is special, since the application can receive that signal
          more than once.  In this case, don't set the signal handler to the
          default.  Instead, just raise the uncatchable SIGSTOP.  */
+#ifndef _WIN32
       if (stops)
         {
           stop_signal_count = stops - 1;
           sig = SIGSTOP;
         }
       else
+#endif
         signal (sig, SIG_DFL);
 
       /* Exit or suspend the program.  */
@@ -1601,11 +1605,15 @@ signal_setup (bool init)
   /* The signals that are trapped, and the number of such signals.  */
   static int const sig[] =
     {
+#ifndef _WIN32
       /* This one is handled specially.  */
       SIGTSTP,
 
       /* The usual suspects.  */
       SIGALRM, SIGHUP, SIGINT, SIGPIPE, SIGQUIT, SIGTERM,
+      #else
+      SIGINT,  SIGTERM, SIGPIPE,
+      #endif
 #ifdef SIGPOLL
       SIGPOLL,
 #endif
@@ -1658,7 +1666,11 @@ signal_setup (bool init)
           caught_sig[j] = (signal (sig[j], SIG_IGN) != SIG_IGN);
           if (caught_sig[j])
             {
+#ifndef _WIN32
               signal (sig[j], sig[j] == SIGTSTP ? stophandler : sighandler);
+#else
+              signal (sig[j], sighandler);
+#endif
               siginterrupt (sig[j], 0);
             }
         }
@@ -1884,8 +1896,10 @@ main (int argc, char **argv)
          This can process signals out of order, but there doesn't seem to
          be an easy way to do them in order, and the order isn't that
          important anyway.  */
+#ifndef _WIN32
       for (j = stop_signal_count; j; j--)
         raise (SIGSTOP);
+#endif
       j = interrupt_signal;
       if (j)
         raise (j);
@@ -2273,7 +2287,9 @@ decode_switches (int argc, char **argv)
           break;
 
         case 'Z':
+#ifndef _WIN32
           print_scontext = true;
+#endif
           break;
 
         case ZERO_OPTION:
@@ -2332,6 +2348,13 @@ decode_switches (int argc, char **argv)
               && 0 < ws.ws_col)
             linelen = ws.ws_col <= MIN (PTRDIFF_MAX, SIZE_MAX) ? ws.ws_col : 0;
         }
+#elif defined(_WIN32)
+	  CONSOLE_SCREEN_BUFFER_INFO csbi;
+	  int columns, rows;
+
+	  GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &csbi);
+	  linelen = csbi.srWindow.Right - csbi.srWindow.Left + 1;
+
 #endif
       if (linelen < 0)
         {
@@ -3708,7 +3731,11 @@ get_link_name (char const *filename, struct fileinfo *f, bool command_line_arg)
 {
   f->linkname = areadlink_with_size (filename, f->stat.st_size);
   if (f->linkname == nullptr)
+#ifdef _WIN32
+      file_failure(command_line_arg, _("cannot read symbolic link %s or symbolic link points to a volume id (\\??\\Volume*)"),
+#else
     file_failure (command_line_arg, _("cannot read symbolic link %s"),
+#endif // _WIN32
                   filename);
 }
 
@@ -4907,12 +4934,12 @@ get_type_indicator (bool stat_ok, mode_t mode, enum filetype type)
     }
   else
     {
-      if (stat_ok ? S_ISDIR (mode) : type == directory || type == arg_directory)
+	  if (stat_ok ? S_ISLNK(mode) : type == symbolic_link) //windows has symlink dir type so needs to be before isdir
+		  c = '@';
+	  else if (stat_ok ? S_ISDIR (mode) : type == directory || type == arg_directory)
         c = '/';
       else if (indicator_style == slash)
         c = 0;
-      else if (stat_ok ? S_ISLNK (mode) : type == symbolic_link)
-        c = '@';
       else if (stat_ok ? S_ISFIFO (mode) : type == fifo)
         c = '|';
       else if (stat_ok ? S_ISSOCK (mode) : type == sock)
@@ -5008,6 +5035,8 @@ get_color_indicator (const struct fileinfo *f, bool symlink_target)
           else if ((1 < f->stat.st_nlink) && is_colored (C_MULTIHARDLINK))
             type = C_MULTIHARDLINK;
         }
+	  else if (S_ISLNK(mode)) //windows has symlink dir type so needs to be before isdir
+		  type = C_LINK;
       else if (S_ISDIR (mode))
         {
           type = C_DIR;
@@ -5020,8 +5049,6 @@ get_color_indicator (const struct fileinfo *f, bool symlink_target)
           else if ((mode & S_ISVTX) != 0 && is_colored (C_STICKY))
             type = C_STICKY;
         }
-      else if (S_ISLNK (mode))
-        type = C_LINK;
       else if (S_ISFIFO (mode))
         type = C_FIFO;
       else if (S_ISSOCK (mode))
diff --git a/src/make-prime-list.c b/src/make-prime-list.c
index 35cf3627c..9e5dc7773 100644
--- a/src/make-prime-list.c
+++ b/src/make-prime-list.c
@@ -24,7 +24,11 @@ this program.  If not, see https://www.gnu.org/licenses/.  */
 
 #include <limits.h>
 #include <stdint.h>
-#include <stdio.h>
+#ifndef  _WIN32
+#include "../include/stdio.h"
+#else
+#include "../ucrt/stdio.h"
+#endif // ! _WIN32
 #include <string.h>
 #include <stdlib.h>
 #include <errno.h>
diff --git a/src/mkdir.c b/src/mkdir.c
index df4c81976..16c6c6cf8 100644
--- a/src/mkdir.c
+++ b/src/mkdir.c
@@ -60,19 +60,23 @@ Create the DIRECTORY(ies), if they do not already exist.\n\
 "), stdout);
 
       emit_mandatory_arg_note ();
-
+#ifndef _WIN32
+fputs (_("\
+  -m, --mode=MODE   set file mode (as in chmod), not a=rwx - umask\n"), stdout);
+#endif
       fputs (_("\
-  -m, --mode=MODE   set file mode (as in chmod), not a=rwx - umask\n\
   -p, --parents     no error if existing, make parent directories as needed,\n\
                     with their file modes unaffected by any -m option\n\
   -v, --verbose     print a message for each created directory\n\
 "), stdout);
+#ifndef _WIN32
       fputs (_("\
   -Z                   set SELinux security context of each created directory\n\
                          to the default type\n\
       --context[=CTX]  like -Z, or if CTX is specified then set the SELinux\n\
                          or SMACK security context to CTX\n\
 "), stdout);
+#endif
       fputs (HELP_OPTION_DESCRIPTION, stdout);
       fputs (VERSION_OPTION_DESCRIPTION, stdout);
       emit_ancillary_info (PROGRAM_NAME);
@@ -124,7 +128,7 @@ static int
 make_ancestor (char const *dir, char const *component, void *options)
 {
   struct mkdir_options const *o = options;
-
+#ifndef _WIN32
   if (o->set_security_context
       && defaultcon (o->set_security_context, component, S_IFDIR) < 0
       && ! ignorable_ctx_err (errno))
@@ -140,9 +144,14 @@ make_ancestor (char const *dir, char const *component, void *options)
       umask (o->umask_self);
       errno = mkdir_errno;
     }
+#else
+  int r = mkdir (component, 0);
+#endif	
   if (r == 0)
     {
+#ifndef _WIN32      
       r = (o->umask_ancestor & S_IRUSR) != 0;
+#endif      
       announce_mkdir (dir, options);
     }
   return r;
@@ -155,6 +164,7 @@ process_dir (char *dir, struct savewd *wd, void *options)
   struct mkdir_options const *o = options;
 
   /* If possible set context before DIR created.  */
+#ifndef _WIN32  
   if (o->set_security_context)
     {
       if (! o->make_ancestor_function
@@ -163,7 +173,7 @@ process_dir (char *dir, struct savewd *wd, void *options)
         error (0, errno, _("failed to set default creation context for %s"),
                quoteaf (dir));
     }
-
+#endif
   int ret = (make_dir_parents (dir, wd, o->make_ancestor_function, options,
                                o->mode, announce_mkdir,
                                o->mode_bits, (uid_t) -1, (gid_t) -1, true)
@@ -175,6 +185,7 @@ process_dir (char *dir, struct savewd *wd, void *options)
      final component of DIR is created.  So for now, create the
      final component with the context from previous component
      and here we set the context for the final component. */
+#ifndef _WIN32
   if (ret == EXIT_SUCCESS && o->set_security_context
       && o->make_ancestor_function)
     {
@@ -183,7 +194,7 @@ process_dir (char *dir, struct savewd *wd, void *options)
         error (0, errno, _("failed to restore context for %s"),
                quoteaf (dir));
     }
-
+#endif
   return ret;
 }
 
@@ -196,7 +207,9 @@ main (int argc, char **argv)
   struct mkdir_options options;
 
   options.make_ancestor_function = nullptr;
+#ifndef _WIN32  
   options.mode = S_IRWXUGO;
+#endif
   options.mode_bits = 0;
   options.created_directory_format = nullptr;
   options.set_security_context = nullptr;
@@ -223,11 +236,13 @@ main (int argc, char **argv)
           options.created_directory_format = _("created directory %s");
           break;
         case 'Z':
+#ifndef _WIN32        
           if (is_smack_enabled ())
             {
               /* We don't yet support -Z to restore context with SMACK.  */
               scontext = optarg;
             }
+
           else if (is_selinux_enabled () > 0)
             {
               if (optarg)
@@ -246,6 +261,7 @@ main (int argc, char **argv)
                      _("warning: ignoring --context; "
                        "it requires an SELinux/SMACK-enabled kernel"));
             }
+#endif                        
           break;
         case_GETOPT_HELP_CHAR;
         case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);
@@ -259,7 +275,7 @@ main (int argc, char **argv)
       error (0, 0, _("missing operand"));
       usage (EXIT_FAILURE);
     }
-
+#ifndef _WIN32
   /* FIXME: This assumes mkdir() is done in the same process.
      If that's not always the case we would need to call this
      like we do when options.set_security_context.  */
@@ -302,7 +318,7 @@ main (int argc, char **argv)
 
       umask (options.umask_self);
     }
-
+#endif
   return savewd_process_files (argc - optind, argv + optind,
                                process_dir, &options);
 }
diff --git a/src/mktemp.c b/src/mktemp.c
index 706c6518e..dade5920a 100644
--- a/src/mktemp.c
+++ b/src/mktemp.c
@@ -83,7 +83,7 @@ Files are created u+rw, and directories u+rwx, minus umask restrictions.\n\
 "), stdout);
       fputs (_("\
   -p DIR, --tmpdir[=DIR]  interpret TEMPLATE relative to DIR; if DIR is not\n\
-                        specified, use $TMPDIR if set, else /tmp.  With\n\
+                        specified, use $TMPDIR if set, else default temp dir.  With\n\
                         this option, TEMPLATE must not be an absolute name;\n\
                         unlike with -t, TEMPLATE may contain slashes, but\n\
                         mktemp creates only the final component\n\
@@ -91,7 +91,7 @@ Files are created u+rw, and directories u+rwx, minus umask restrictions.\n\
       fputs (_("\
   -t                  interpret TEMPLATE as a single file name component,\n\
                         relative to a directory: $TMPDIR, if set; else the\n\
-                        directory specified via -p; else /tmp [deprecated]\n\
+                        directory specified via -p; else default temp dir [deprecated]\n\
 "), stdout);
       fputs (HELP_OPTION_DESCRIPTION, stdout);
       fputs (VERSION_OPTION_DESCRIPTION, stdout);
@@ -268,12 +268,20 @@ main (int argc, char **argv)
       if (deprecated_t_option)
         {
           char *env = getenv ("TMPDIR");
+#ifdef _WIN32
+          if ((env && *env) == false)
+            env = getenv ("TMP");
+#endif
           if (env && *env)
             dest_dir = env;
           else if (dest_dir_arg && *dest_dir_arg)
             dest_dir = dest_dir_arg;
           else
+#ifndef _WIN32
             dest_dir = "/tmp";
+#else
+            dest_dir = "/temp";//technically could  GetTempPath but ENV TMP sohuld work
+#endif
 
           if (last_component (template) != template)
             error (EXIT_FAILURE, 0,
@@ -287,7 +295,13 @@ main (int argc, char **argv)
           else
             {
               char *env = getenv ("TMPDIR");
-              dest_dir = (env && *env ? env : "/tmp");
+#ifdef _WIN32
+              if ((env && *env) == false)
+                env = getenv ("TMP");
+              dest_dir = (env && *env ? env : "/temp");
+#else
+              dest_dir = (env && *env ? env : "/tmp")
+#endif
             }
           if (IS_ABSOLUTE_FILE_NAME (template))
             error (EXIT_FAILURE, 0,
diff --git a/src/realpath.c b/src/realpath.c
index 4bc00edc2..21e3563d3 100644
--- a/src/realpath.c
+++ b/src/realpath.c
@@ -119,21 +119,21 @@ path_prefix (char const *prefix, char const *path)
   /* '/' is the prefix of everything except '//' (since we know '//'
      is only present after canonicalization if it is distinct).  */
   if (!*prefix)
-    return *path != '/';
+    return  ! ISSLASH(*path);
 
   /* Likewise, '//' is a prefix of any double-slash path.  */
-  if (*prefix == '/' && !prefix[1])
-    return *path == '/';
+  if (ISSLASH(*prefix) && !prefix[1])
+    return ISSLASH(*path);
 
   /* Any other prefix has a non-slash portion.  */
   while (*prefix && *path)
     {
-      if (*prefix != *path)
+      if (! PATH_CHAR_EQ(*prefix, *path) )
         break;
       prefix++;
       path++;
     }
-  return (!*prefix && (*path == '/' || !*path));
+  return (!*prefix && (ISSLASH(*path) || !*path));
 }
 
 static bool
diff --git a/src/relpath.c b/src/relpath.c
index c6a29b2b3..615d92c46 100644
--- a/src/relpath.c
+++ b/src/relpath.c
@@ -20,6 +20,7 @@
 
 #include "system.h"
 #include "relpath.h"
+#include "filename.h"
 
 
 /* Return the length of the longest common prefix
@@ -35,14 +36,14 @@ path_common_prefix (char const *path1, char const *path2)
   /* We already know path1[0] and path2[0] are '/'.  Special case
      '//', which is only present in a canonical name on platforms
      where it is distinct.  */
-  if ((path1[1] == '/') != (path2[1] == '/'))
+  if ((ISSLASH(path1[1])) != (ISSLASH(path2[1])))
     return 0;
 
   while (*path1 && *path2)
     {
-      if (*path1 != *path2)
+      if (!PATH_CHAR_EQ (*path1,*path2))
         break;
-      if (*path1 == '/')
+      if (ISSLASH(*path1))
         ret = i + 1;
       path1++;
       path2++;
@@ -50,8 +51,8 @@ path_common_prefix (char const *path1, char const *path2)
     }
 
   if ((!*path1 && !*path2)
-      || (!*path1 && *path2 == '/')
-      || (!*path2 && *path1 == '/'))
+      || (!*path1 && ISSLASH(*path2))
+      || (!*path2 && ISSLASH(*path1)))
     ret = i;
 
   return ret;
@@ -98,9 +99,9 @@ relpath (char const *can_fname, char const *can_reldir, char *buf, size_t len)
   char const *fname_suffix = can_fname + common_index;
 
   /* Skip over extraneous '/'.  */
-  if (*relto_suffix == '/')
+  if (ISSLASH(*relto_suffix))
     relto_suffix++;
-  if (*fname_suffix == '/')
+  if (ISSLASH(*fname_suffix))
     fname_suffix++;
 
   /* Replace remaining components of --relative-to with '..', to get
@@ -110,13 +111,13 @@ relpath (char const *can_fname, char const *can_reldir, char *buf, size_t len)
       buf_err |= buffer_or_output ("..", &buf, &len);
       for (; *relto_suffix; ++relto_suffix)
         {
-          if (*relto_suffix == '/')
-            buf_err |= buffer_or_output ("/..", &buf, &len);
+          if (ISSLASH(*relto_suffix))
+            buf_err |= buffer_or_output ((char[]) { DIR_SEPARATOR,'.','.', '\0' }, &buf, &len);
         }
 
       if (*fname_suffix)
         {
-          buf_err |= buffer_or_output ("/", &buf, &len);
+		  buf_err |= buffer_or_output((char[]) { DIR_SEPARATOR, '\0' }, &buf, &len);
           buf_err |= buffer_or_output (fname_suffix, &buf, &len);
         }
     }
diff --git a/src/shred.c b/src/shred.c
index 03a260243..3949ff0b2 100644
--- a/src/shred.c
+++ b/src/shred.c
@@ -331,6 +331,7 @@ direct_mode (int fd, bool enable)
 {
   if (O_DIRECT)
     {
+#ifndef _WIN32
       int fd_flags = fcntl (fd, F_GETFL);
       if (0 < fd_flags)
         {
@@ -340,6 +341,7 @@ direct_mode (int fd, bool enable)
           if (new_flags != fd_flags)
             fcntl (fd, F_SETFL, new_flags);
         }
+#endif    
     }
 
 #if HAVE_DIRECTIO && defined DIRECTIO_ON && defined DIRECTIO_OFF
@@ -956,6 +958,7 @@ static bool
 wipefd (int fd, char const *qname, struct randint_source *s,
         struct Options const *flags)
 {
+#ifndef _WIN32
   int fd_flags = fcntl (fd, F_GETFL);
 
   if (fd_flags < 0)
@@ -968,6 +971,7 @@ wipefd (int fd, char const *qname, struct randint_source *s,
       error (0, 0, _("%s: cannot shred append-only file descriptor"), qname);
       return false;
     }
+#endif    
   return do_wipefd (fd, qname, s, flags);
 }
 
diff --git a/src/sort.c b/src/sort.c
index 4473987ef..aa63952cd 100644
--- a/src/sort.c
+++ b/src/sort.c
@@ -715,7 +715,11 @@ static pid_t
 reap (pid_t pid)
 {
   int status;
+#ifndef _WIN32
   pid_t cpid = waitpid ((pid ? pid : -1), &status, (pid ? 0 : WNOHANG));
+#else
+  pid_t cpid = waitpid ((pid ? pid : -1), &status, 0);
+#endif
 
   if (cpid < 0)
     error (SORT_FAILURE, errno, _("waiting for %s [-d]"),
@@ -4394,7 +4398,11 @@ main (int argc, char **argv)
     static int const sig[] =
       {
         /* The usual suspects.  */
+#ifndef _WIN32
         SIGALRM, SIGHUP, SIGINT, SIGPIPE, SIGQUIT, SIGTERM,
+#else
+        SIGINT, SIGTERM, SIGPIPE,
+#endif
 #ifdef SIGPOLL
         SIGPOLL,
 #endif
@@ -4440,8 +4448,9 @@ main (int argc, char **argv)
         }
 #endif
   }
+#ifndef _WIN32
   signal (SIGCHLD, SIG_DFL); /* Don't inherit CHLD handling from parent.  */
-
+#endif
   /* The signal mask is known, so it is safe to invoke exit_cleanup.  */
   atexit (exit_cleanup);
 
diff --git a/src/stat.c b/src/stat.c
index 3ea7da7f5..733ff4b07 100644
--- a/src/stat.c
+++ b/src/stat.c
@@ -20,23 +20,13 @@
 
 /* Keep this conditional in sync with the similar conditional in
    ../m4/stat-prog.m4.  */
-#if ((STAT_STATVFS || STAT_STATVFS64)                                       \
-     && (HAVE_STRUCT_STATVFS_F_BASETYPE || HAVE_STRUCT_STATVFS_F_FSTYPENAME \
-         || (! HAVE_STRUCT_STATFS_F_FSTYPENAME && HAVE_STRUCT_STATVFS_F_TYPE)))
-# define USE_STATVFS 1
-#else
-# define USE_STATVFS 0
-#endif
+
 
 #include <stdio.h>
 #include <sys/types.h>
+#ifndef _WIN32
 #include <pwd.h>
 #include <grp.h>
-#if USE_STATVFS
-# include <sys/statvfs.h>
-#elif HAVE_SYS_VFS_H
-# include <sys/vfs.h>
-#elif HAVE_SYS_MOUNT_H && HAVE_SYS_PARAM_H
 /* NOTE: freebsd5.0 needs sys/param.h and sys/mount.h for statfs.
    It does have statvfs.h, but shouldn't use it, since it doesn't
    HAVE_STRUCT_STATVFS_F_BASETYPE.  So find a clean way to fix it.  */
@@ -52,6 +42,9 @@
 #elif HAVE_OS_H /* BeOS */
 # include <fs_info.h>
 #endif
+
+#include "fsusage.h"
+
 #include <selinux/selinux.h>
 #include <getopt.h>
 
@@ -73,76 +66,6 @@
 #include "xvasprintf.h"
 #include "statx.h"
 
-#if HAVE_STATX && defined STATX_INO
-# define USE_STATX 1
-#else
-# define USE_STATX 0
-#endif
-
-#if USE_STATVFS
-# define STRUCT_STATXFS_F_FSID_IS_INTEGER STRUCT_STATVFS_F_FSID_IS_INTEGER
-# define HAVE_STRUCT_STATXFS_F_TYPE HAVE_STRUCT_STATVFS_F_TYPE
-# if HAVE_STRUCT_STATVFS_F_NAMEMAX
-#  define SB_F_NAMEMAX(S) ((S)->f_namemax)
-# endif
-# if ! STAT_STATVFS && STAT_STATVFS64
-#  define STRUCT_STATVFS struct statvfs64
-#  define STATFS statvfs64
-# else
-#  define STRUCT_STATVFS struct statvfs
-#  define STATFS statvfs
-# endif
-# define STATFS_FRSIZE(S) ((S)->f_frsize)
-#else
-# define HAVE_STRUCT_STATXFS_F_TYPE HAVE_STRUCT_STATFS_F_TYPE
-# if HAVE_STRUCT_STATFS_F_NAMELEN
-#  define SB_F_NAMEMAX(S) ((S)->f_namelen)
-# elif HAVE_STRUCT_STATFS_F_NAMEMAX
-#  define SB_F_NAMEMAX(S) ((S)->f_namemax)
-# endif
-# define STATFS statfs
-# if HAVE_OS_H /* BeOS */
-/* BeOS has a statvfs function, but it does not return sensible values
-   for f_files, f_ffree and f_favail, and lacks f_type, f_basetype and
-   f_fstypename.  Use 'struct fs_info' instead.  */
-NODISCARD
-static int
-statfs (char const *filename, struct fs_info *buf)
-{
-  dev_t device = dev_for_path (filename);
-  if (device < 0)
-    {
-      errno = (device == B_ENTRY_NOT_FOUND ? ENOENT
-               : device == B_BAD_VALUE ? EINVAL
-               : device == B_NAME_TOO_LONG ? ENAMETOOLONG
-               : device == B_NO_MEMORY ? ENOMEM
-               : device == B_FILE_ERROR ? EIO
-               : 0);
-      return -1;
-    }
-  /* If successful, buf->dev will be == device.  */
-  return fs_stat_dev (device, buf);
-}
-#  define f_fsid dev
-#  define f_blocks total_blocks
-#  define f_bfree free_blocks
-#  define f_bavail free_blocks
-#  define f_bsize io_size
-#  define f_files total_nodes
-#  define f_ffree free_nodes
-#  define STRUCT_STATVFS struct fs_info
-#  define STRUCT_STATXFS_F_FSID_IS_INTEGER true
-#  define STATFS_FRSIZE(S) ((S)->block_size)
-# else
-#  define STRUCT_STATVFS struct statfs
-#  define STRUCT_STATXFS_F_FSID_IS_INTEGER STRUCT_STATFS_F_FSID_IS_INTEGER
-#  if HAVE_STRUCT_STATFS_F_FRSIZE
-#   define STATFS_FRSIZE(S) ((S)->f_frsize)
-#  else
-#   define STATFS_FRSIZE(S) 0
-#  endif
-# endif
-#endif
 
 #ifdef SB_F_NAMEMAX
 # define OUT_NAMEMAX out_uint
@@ -153,15 +76,6 @@ statfs (char const *filename, struct fs_info *buf)
 # define OUT_NAMEMAX out_string
 #endif
 
-#if HAVE_STRUCT_STATVFS_F_BASETYPE
-# define STATXFS_FILE_SYSTEM_TYPE_MEMBER_NAME f_basetype
-#else
-# if HAVE_STRUCT_STATVFS_F_FSTYPENAME || HAVE_STRUCT_STATFS_F_FSTYPENAME
-#  define STATXFS_FILE_SYSTEM_TYPE_MEMBER_NAME f_fstypename
-# elif HAVE_OS_H /* BeOS */
-#  define STATXFS_FILE_SYSTEM_TYPE_MEMBER_NAME fsh_name
-# endif
-#endif
 
 #if HAVE_GETATTRAT
 # include <attr.h>
@@ -251,12 +165,16 @@ print_stat (char *pformat, size_t prefix_len, char mod, char m,
    But f_type may only exist in statfs (Cygwin).  */
 NODISCARD
 static char const *
-human_fstype (STRUCT_STATVFS const *statfsbuf)
+human_fstype (struct fs_usage *statfsbuf)
 {
+#ifdef _WIN32
+  return (const char * ) statfsbuf->fsu_fs_type;
+}
+#else
 #ifdef STATXFS_FILE_SYSTEM_TYPE_MEMBER_NAME
   return statfsbuf->STATXFS_FILE_SYSTEM_TYPE_MEMBER_NAME;
 #else
-  switch (statfsbuf->f_type)
+  switch (statfsbuf->fsu_fs_type)
     {
 # if defined __linux__ || defined __ANDROID__
 
@@ -628,6 +546,7 @@ human_fstype (STRUCT_STATVFS const *statfsbuf)
     }
 #endif
 }
+#endif !_WIN32
 
 NODISCARD
 static char *
@@ -858,9 +777,8 @@ NODISCARD
 static bool
 print_statfs (char *pformat, size_t prefix_len, MAYBE_UNUSED char mod, char m,
               int fd, char const *filename,
-              void const *data)
+              struct fs_usage *statfsbuf)
 {
-  STRUCT_STATVFS const *statfsbuf = data;
   bool fail = false;
 
   switch (m)
@@ -871,27 +789,10 @@ print_statfs (char *pformat, size_t prefix_len, MAYBE_UNUSED char mod, char m,
 
     case 'i':
       {
-#if STRUCT_STATXFS_F_FSID_IS_INTEGER
-        uintmax_t fsid = statfsbuf->f_fsid;
-#else
-        typedef unsigned int fsid_word;
-        static_assert (alignof (STRUCT_STATVFS) % alignof (fsid_word) == 0);
-        static_assert (offsetof (STRUCT_STATVFS, f_fsid) % alignof (fsid_word)
-                       == 0);
-        static_assert (sizeof statfsbuf->f_fsid % alignof (fsid_word) == 0);
-        fsid_word const *p = (fsid_word *) &statfsbuf->f_fsid;
 
         /* Assume a little-endian word order, as that is compatible
            with glibc's statvfs implementation.  */
-        uintmax_t fsid = 0;
-        int words = sizeof statfsbuf->f_fsid / sizeof *p;
-        for (int i = 0; i < words && i * sizeof *p < sizeof fsid; i++)
-          {
-            uintmax_t u = p[words - 1 - i];
-            fsid |= u << (i * CHAR_BIT * sizeof *p);
-          }
-#endif
-        out_uint_x (pformat, prefix_len, fsid);
+        out_uint_x (pformat, prefix_len, statfsbuf->fsu_fsid);
       }
       break;
 
@@ -909,30 +810,25 @@ print_statfs (char *pformat, size_t prefix_len, MAYBE_UNUSED char mod, char m,
       out_string (pformat, prefix_len, human_fstype (statfsbuf));
       break;
     case 'b':
-      out_int (pformat, prefix_len, statfsbuf->f_blocks);
+      out_int (pformat, prefix_len, statfsbuf->fsu_blocks);
       break;
     case 'f':
-      out_int (pformat, prefix_len, statfsbuf->f_bfree);
+      out_int (pformat, prefix_len, statfsbuf->fsu_bfree);
       break;
     case 'a':
-      out_int (pformat, prefix_len, statfsbuf->f_bavail);
+      out_int (pformat, prefix_len, statfsbuf->fsu_bavail);
       break;
     case 's':
-      out_uint (pformat, prefix_len, statfsbuf->f_bsize);
+      out_uint (pformat, prefix_len, statfsbuf->fsu_blocksize);
       break;
     case 'S':
-      {
-        uintmax_t frsize = STATFS_FRSIZE (statfsbuf);
-        if (! frsize)
-          frsize = statfsbuf->f_bsize;
-        out_uint (pformat, prefix_len, frsize);
-      }
+      out_uint (pformat, prefix_len, statfsbuf->fsu_blocksize);
       break;
     case 'c':
-      out_uint (pformat, prefix_len, statfsbuf->f_files);
+      out_uint (pformat, prefix_len, statfsbuf->fsu_files);
       break;
     case 'd':
-      out_int (pformat, prefix_len, statfsbuf->f_ffree);
+      out_int (pformat, prefix_len, statfsbuf->fsu_ffree);
       break;
     default:
       fputc ('?', stdout);
@@ -951,6 +847,7 @@ find_bind_mount (char const * name)
   char const * bind_mount = nullptr;
 
   static struct mount_entry *mount_list;
+#ifndef _WIN32
   static bool tried_mount_list = false;
   if (!tried_mount_list) /* attempt/warn once per process.  */
     {
@@ -958,7 +855,7 @@ find_bind_mount (char const * name)
         error (0, errno, "%s", _("cannot read table of mounted file systems"));
       tried_mount_list = true;
     }
-
+#endif
   struct stat name_stats;
   if (stat (name, &name_stats) != 0)
     return nullptr;
@@ -1258,7 +1155,7 @@ NODISCARD
 static bool
 do_statfs (char const *filename, char const *format)
 {
-  STRUCT_STATVFS statfsbuf;
+  struct fs_usage statfsbuf;
 
   if (STREQ (filename, "-"))
     {
@@ -1267,7 +1164,7 @@ do_statfs (char const *filename, char const *format)
       return false;
     }
 
-  if (STATFS (filename, &statfsbuf) != 0)
+  if (get_fs_usage(filename,NULL,&statfsbuf))
     {
       error (0, errno, _("cannot read file system information for %s"),
              quoteaf (filename));
@@ -1564,17 +1461,21 @@ print_stat (char *pformat, size_t prefix_len, char mod, char m,
       out_uint (pformat, prefix_len, statbuf->st_uid);
       break;
     case 'U':
+#ifndef _WIN32
       pw_ent = getpwuid (statbuf->st_uid);
       out_string (pformat, prefix_len,
                   pw_ent ? pw_ent->pw_name : "UNKNOWN");
+#endif ! _WIN32
       break;
     case 'g':
       out_uint (pformat, prefix_len, statbuf->st_gid);
       break;
     case 'G':
+#ifndef _WIN32
       gw_ent = getgrgid (statbuf->st_gid);
       out_string (pformat, prefix_len,
                   gw_ent ? gw_ent->gr_name : "UNKNOWN");
+#endif ! _WIN32      
       break;
     case 'm':
       fail |= out_mount_point (filename, pformat, prefix_len, statbuf);
diff --git a/src/sync.c b/src/sync.c
index 7c518b5fa..e4a4fb0d7 100644
--- a/src/sync.c
+++ b/src/sync.c
@@ -116,6 +116,7 @@ sync_arg (enum sync_mode mode, char const *file)
 
   /* We used O_NONBLOCK above to not hang with fifos,
      so reset that here.  */
+#ifndef _WIN32
   int fdflags = fcntl (fd, F_GETFL);
   if (fdflags == -1
       || fcntl (fd, F_SETFL, fdflags & ~O_NONBLOCK) < 0)
@@ -124,7 +125,7 @@ sync_arg (enum sync_mode mode, char const *file)
              quoteaf (file));
       ret = false;
     }
-
+#endif
   if (ret == true)
     {
       int sync_status = -1;
diff --git a/src/system.h b/src/system.h
index 4a47e15ca..a0aeadcfb 100644
--- a/src/system.h
+++ b/src/system.h
@@ -662,7 +662,12 @@ emit_ancillary_info (char const *program)
 
   /* Don't output this redundant message for English locales.
      Note we still output for 'C' so that it gets included in the man page.  */
-  char const *lc_messages = setlocale (LC_MESSAGES, nullptr);
+  char const* lc_messages =
+#ifndef  _WIN32
+	  setlocale(LC_MESSAGES, nullptr);
+#else
+	  nullptr;
+#endif // ! _WIN32
   if (lc_messages && STRNCMP_LIT (lc_messages, "en_"))
     {
       /* TRANSLATORS: Replace LANG_CODE in this URL with your language code
diff --git a/src/tail.c b/src/tail.c
index 1ed1c4fab..69430d3f2 100644
--- a/src/tail.c
+++ b/src/tail.c
@@ -49,6 +49,9 @@
 #include "xstrtol.h"
 #include "xstrtod.h"
 
+#ifdef _WIN32
+typedef   signed long     blksize_t;
+#endif
 #if HAVE_INOTIFY
 # include "hash.h"
 # include <poll.h>
@@ -979,7 +982,7 @@ recheck (struct File_spec *f, bool blocking)
   bool new_file;
   int fd = (is_stdin
             ? STDIN_FILENO
-            : open (f->name, O_RDONLY | (blocking ? 0 : O_NONBLOCK)));
+            : open_file (f->name, O_RDONLY | (blocking ? 0 : O_NONBLOCK)));
 
   affirm (valid_file_spec (f));
 
@@ -1202,6 +1205,7 @@ tail_forever (struct File_spec *f, size_t n_files, double sleep_interval)
 
           if (f[i].blocking != blocking)
             {
+              #ifndef _WIN32
               int old_flags = fcntl (fd, F_GETFL);
               int new_flags = old_flags | (blocking ? 0 : O_NONBLOCK);
               if (old_flags < 0
@@ -1220,6 +1224,7 @@ tail_forever (struct File_spec *f, size_t n_files, double sleep_interval)
                            quotef (name));
                 }
               else
+#endif
                 f[i].blocking = blocking;
             }
 
@@ -1323,7 +1328,9 @@ tail_forever (struct File_spec *f, size_t n_files, double sleep_interval)
 
           /* Once the writer is dead, read the files once more to
              avoid a race condition.  */
+#ifndef _WIN32
           writers_dead = writers_are_dead ();
+#endif
 
           if (!writers_dead && xnanosleep (sleep_interval))
             error (EXIT_FAILURE, errno, _("cannot read realtime clock"));
@@ -1655,9 +1662,10 @@ tail_forever_inotify (int wd, struct File_spec *f, size_t n_files,
                 {
                   if (writers_dead)
                     exit (EXIT_SUCCESS);
+#ifndef _WIN32  //not sure if we end up looping forever here...
 
                   writers_dead = writers_are_dead ();
-
+#endif
                   if (writers_dead || sleep_interval <= 0)
                     delay = 0;
                   else if (sleep_interval < INT_MAX / 1000 - 1)
@@ -1999,6 +2007,21 @@ tail (char const *filename, int fd, uintmax_t n_units,
     return tail_bytes (filename, fd, n_units, read_pos);
 }
 
+static int open_file(const char* filename, int flags) {
+	int fd;
+#ifndef _WIN32
+	fd = open(filename, flags);
+#else
+	fd = -1;
+	HANDLE winHandle = CreateFile(filename, GENERIC_READ, FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_READONLY, NULL);
+	if (winHandle > 0) {
+		fd = _open_osfhandle((intptr_t)winHandle, _O_RDONLY);
+		if (fd > 0 && flags & O_BINARY)
+			xset_binary_mode(fd, O_BINARY);
+	}
+#endif
+	return fd;
+}
 /* Display the last N_UNITS units of the file described by F.
    Return true if successful.  */
 
@@ -2020,7 +2043,7 @@ tail_file (struct File_spec *f, uintmax_t n_files, uintmax_t n_units)
       xset_binary_mode (STDIN_FILENO, O_BINARY);
     }
   else
-    fd = open (f->name, O_RDONLY | O_BINARY | (nonblocking ? O_NONBLOCK : 0));
+    fd = open_file (f->name, O_RDONLY | O_BINARY | (nonblocking ? O_NONBLOCK : 0));
 
   f->tailable = !(reopen_inaccessible_files && fd == -1);
 
@@ -2320,7 +2343,11 @@ parse_options (int argc, char **argv,
   if (nbpids && !forever)
     error (0, 0,
            _("warning: PID ignored; --pid=PID is useful only when following"));
+#ifndef _WIN32  //not sure if we end up looping forever here...
   else if (nbpids && kill (pids[0], 0) != 0 && errno == ENOSYS)
+#else
+  else if (nbpids)
+#endif
     {
       error (0, 0, _("warning: --pid=PID is not supported on this system"));
       nbpids = 0;
diff --git a/src/wc.c b/src/wc.c
index ed4ad62c4..e19de55c1 100644
--- a/src/wc.c
+++ b/src/wc.c
@@ -739,7 +739,11 @@ main (int argc, char **argv)
   page_size = getpagesize ();
   /* Line buffer stdout to ensure lines are written atomically and immediately
      so that processes running in parallel do not intersperse their output.  */
-  setvbuf (stdout, nullptr, _IOLBF, 0);
+#ifndef _WIN32
+  setvbuf(stdout, nullptr, _IOLBF, 0);
+#else
+  setvbuf(stdout, nullptr, _IONBF, 0); //windows treats _IOLBF the same as _IOFBF in addition a buffer of NULL and size of 0 is invalid unless you are doing IONBF.
+#endif // !_WIN32
 
   posixly_correct = (getenv ("POSIXLY_CORRECT") != nullptr);
 
diff --git a/src/whoami.c b/src/whoami.c
index 9313eaf3e..418181d45 100644
--- a/src/whoami.c
+++ b/src/whoami.c
@@ -21,8 +21,13 @@
 #include <config.h>
 #include <stdio.h>
 #include <sys/types.h>
+#ifndef _WIN32
 #include <pwd.h>
-
+#else
+#define WIN32_LEAN_AND_MEAN
+#include <Windows.h>
+#include <unistd.h>
+#endif
 #include "system.h"
 #include "long-options.h"
 #include "quote.h"
@@ -79,10 +84,15 @@ main (int argc, char **argv)
 
   errno = 0;
   uid = geteuid ();
-  pw = uid == NO_UID && errno ? nullptr : getpwuid (uid);
+#ifndef _WIN32
+  pw = (uid == NO_UID && errno ? nullptr : getpwuid (uid));
   if (!pw)
     error (EXIT_FAILURE, errno, _("cannot find name for user ID %ju"),
            (uintmax_t) uid);
   puts (pw->pw_name);
+#else
+  const char * login = getlogin();
+  puts (login);
+#endif
   return EXIT_SUCCESS;
 }
