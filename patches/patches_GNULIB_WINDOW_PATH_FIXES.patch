diff --git a/lib/argp-help.c b/lib/argp-help.c
index fc6fcf456b..0249ed735b 100644
--- a/lib/argp-help.c
+++ b/lib/argp-help.c
@@ -47,7 +47,7 @@
 #else
 # include "gettext.h"
 #endif
-
+#include "filename.h"
 #include "argp.h"
 #include "argp-fmtstream.h"
 #include "argp-namefrob.h"
@@ -1833,7 +1833,7 @@ char *
 __argp_short_program_name (void)
 {
 # if HAVE_DECL_PROGRAM_INVOCATION_NAME
-  char *name = strrchr (program_invocation_name, '/');
+  char *name = LAST_SLASH_IN_PATH(program_invocation_name);
   return name ? name + 1 : program_invocation_name;
 # else
   /* FIXME: What now? Miles suggests that it is better to use NULL,
diff --git a/lib/basename.c b/lib/basename.c
index 9d2852d4ba..d554daf39e 100644
--- a/lib/basename.c
+++ b/lib/basename.c
@@ -22,6 +22,7 @@
 
 #include <string.h>
 #include "xalloc.h"
+#include "filename.h"
 
 char *
 base_name (char const *name)
@@ -54,7 +55,7 @@ base_name (char const *name)
   if (dotslash_len)
     {
       p[0] = '.';
-      p[1] = '/';
+      p[1] = DIR_SEPARATOR;
     }
 
   /* Finally, copy the basename.  */
diff --git a/lib/canonicalize-lgpl.c b/lib/canonicalize-lgpl.c
index 7aea4aaba6..9bfade367d 100644
--- a/lib/canonicalize-lgpl.c
+++ b/lib/canonicalize-lgpl.c
@@ -242,12 +242,12 @@ realpath_stk (const char *name, char *resolved, struct realpath_bufs *bufs)
   else
     {
       dest = __mempcpy (rname, name, prefix_len);
-      *dest++ = '/';
+      *dest++ = DIR_SEPARATOR;
       if (DOUBLE_SLASH_IS_DISTINCT_ROOT)
         {
           if (prefix_len == 0 /* implies ISSLASH (name[0]) */
               && ISSLASH (name[1]) && !ISSLASH (name[2]))
-            *dest++ = '/';
+            *dest++ = DIR_SEPARATOR;
           *dest = '\0';
         }
       start = name + prefix_len;
@@ -285,7 +285,7 @@ realpath_stk (const char *name, char *resolved, struct realpath_bufs *bufs)
       else
         {
           if (!ISSLASH (dest[-1]))
-            *dest++ = '/';
+            *dest++ = DIR_SEPARATOR;
 
           while (rname + bufs->rname.length - dest
                  < startlen + sizeof dir_suffix)
@@ -351,11 +351,11 @@ realpath_stk (const char *name, char *resolved, struct realpath_bufs *bufs)
                   idx_t pfxlen = FILE_SYSTEM_PREFIX_LEN (buf);
 
                   dest = __mempcpy (rname, buf, pfxlen);
-                  *dest++ = '/'; /* It's an absolute symlink */
+                  *dest++ = DIR_SEPARATOR; /* It's an absolute symlink */
                   if (DOUBLE_SLASH_IS_DISTINCT_ROOT)
                     {
                       if (ISSLASH (buf[1]) && !ISSLASH (buf[2]) && !pfxlen)
-                        *dest++ = '/';
+                        *dest++ = DIR_SEPARATOR;
                       *dest = '\0';
                     }
                   /* Install the new prefix to be in effect hereafter.  */
diff --git a/lib/canonicalize.c b/lib/canonicalize.c
index 88472cc927..6e55592d4d 100644
--- a/lib/canonicalize.c
+++ b/lib/canonicalize.c
@@ -45,11 +45,6 @@
 # define DOUBLE_SLASH_IS_DISTINCT_ROOT false
 #endif
 
-#if ISSLASH ('\\')
-# define SLASHES "/\\"
-#else
-# define SLASHES "/"
-#endif
 
 /* Avoid false GCC warning "'end_idx' may be used uninitialized".  */
 #if _GL_GNUC_PREREQ (4, 7)
@@ -240,13 +235,13 @@ canonicalize_filename_mode_stk (const char *name, canonicalize_mode_t can_mode,
   else
     {
       dest = mempcpy (rname, name, prefix_len);
-      *dest++ = '/';
+      *dest++ = DIR_SEPARATOR;
       if (DOUBLE_SLASH_IS_DISTINCT_ROOT)
         {
           if (prefix_len == 0 /* implies ISSLASH (name[0]) */
               && ISSLASH (name[1]) && !ISSLASH (name[2]))
             {
-              *dest++ = '/';
+              *dest++ = DIR_SEPARATOR;
 #if defined _WIN32 && !defined __CYGWIN__
               /* For UNC file names '\\server\path\to\file', extend the prefix
                  to include the server: '\\server\'.  */
@@ -308,7 +303,7 @@ canonicalize_filename_mode_stk (const char *name, canonicalize_mode_t can_mode,
       else
         {
           if (!ISSLASH (dest[-1]))
-            *dest++ = '/';
+            *dest++ = DIR_SEPARATOR;
 
           while (rname + bufs->rname.length - dest
                  < startlen + sizeof dir_suffix)
@@ -399,11 +394,11 @@ canonicalize_filename_mode_stk (const char *name, canonicalize_mode_t can_mode,
                   idx_t pfxlen = FILE_SYSTEM_PREFIX_LEN (buf);
 
                   dest = mempcpy (rname, buf, pfxlen);
-                  *dest++ = '/'; /* It's an absolute symlink */
+                  *dest++ = DIR_SEPARATOR; /* It's an absolute symlink */
                   if (DOUBLE_SLASH_IS_DISTINCT_ROOT)
                     {
                       if (ISSLASH (buf[1]) && !ISSLASH (buf[2]) && !pfxlen)
-                        *dest++ = '/';
+                        *dest++ = DIR_SEPARATOR;
                       *dest = '\0';
                     }
                   /* Install the new prefix to be in effect hereafter.  */
diff --git a/lib/chdir-long.c b/lib/chdir-long.c
index a7b55991f3..174860d07d 100644
--- a/lib/chdir-long.c
+++ b/lib/chdir-long.c
@@ -25,7 +25,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <stdio.h>
-
+#include "filename.h"
 #include "assure.h"
 
 #ifndef PATH_MAX
@@ -126,7 +126,7 @@ chdir_long (char *dir)
     assure (PATH_MAX <= len);
 
     /* Count leading slashes.  */
-    n_leading_slash = strspn (dir, "/");
+    n_leading_slash = strspn (dir, SLASHES);
 
     /* Handle any leading slashes as well as any name that matches
        the regular expression, m!^//hostname[/]*! .  Handling this
@@ -139,6 +139,8 @@ chdir_long (char *dir)
         /* Find next slash.
            We already know that dir[2] is neither a slash nor '\0'.  */
         char *slash = memchr (dir + 3, '/', dir_end - (dir + 3));
+		if (slash == NULL && '/' != DIR_SEPARATOR)
+			slash = memchr(dir + 3, DIR_SEPARATOR, dir_end - (dir + 3));
         if (slash == NULL)
           {
             errno = ENAMETOOLONG;
@@ -146,7 +148,7 @@ chdir_long (char *dir)
           }
         *slash = '\0';
         err = cdb_advance_fd (&cdb, dir);
-        *slash = '/';
+        *slash = DIR_SEPARATOR;
         if (err != 0)
           goto Fail;
         dir = find_non_slash (slash + 1);
@@ -158,7 +160,7 @@ chdir_long (char *dir)
         dir += n_leading_slash;
       }
 
-    assure (*dir != '/');
+    assure (! ISSLASH(*dir) );
     assure (dir <= dir_end);
 
     while (PATH_MAX <= dir_end - dir)
@@ -168,6 +170,9 @@ chdir_long (char *dir)
            I.e. see if there is a slash that will give us a name of
            length PATH_MAX-1 or less.  */
         char *slash = memrchr (dir, '/', PATH_MAX);
+		if (slash == NULL && '/' != DIR_SEPARATOR)
+			slash = memrchr(dir, DIR_SEPARATOR, PATH_MAX);
+
         if (slash == NULL)
           {
             errno = ENAMETOOLONG;
@@ -177,7 +182,7 @@ chdir_long (char *dir)
         *slash = '\0';
         assure (slash - dir < PATH_MAX);
         err = cdb_advance_fd (&cdb, dir);
-        *slash = '/';
+        *slash = DIR_SEPARATOR;
         if (err != 0)
           goto Fail;
 
diff --git a/lib/chmod.c b/lib/chmod.c
index a8ea754a33..f1940516c6 100644
--- a/lib/chmod.c
+++ b/lib/chmod.c
@@ -22,6 +22,7 @@
 
 #include <errno.h>
 #include <string.h>
+#include "filename.h"
 
 int
 rpl_chmod (const char *filename, mode_t mode)
@@ -31,7 +32,7 @@ rpl_chmod (const char *filename, mode_t mode)
 #endif
 {
   size_t len = strlen (filename);
-  if (len > 0 && filename[len - 1] == '/')
+  if (len > 0 && ISSLASH(filename[len - 1]) )
     {
       struct stat st;
       if (lstat (filename, &st) < 0)
diff --git a/lib/chown.c b/lib/chown.c
index 6cfc7e52b8..c0f2044cb5 100644
--- a/lib/chown.c
+++ b/lib/chown.c
@@ -27,6 +27,7 @@
 #include <fcntl.h>
 #include <string.h>
 #include <sys/stat.h>
+#include "filename.h"
 
 #if !HAVE_CHOWN
 
@@ -113,7 +114,7 @@ rpl_chown (const char *file, uid_t uid, gid_t gid)
   if (!stat_valid)
     {
       size_t len = strlen (file);
-      if (len && file[len - 1] == '/' && stat (file, &st))
+      if (len && ISSLASH(file[len - 1]) && stat (file, &st))
         return -1;
     }
 # endif
diff --git a/lib/concat-filename.c b/lib/concat-filename.c
index ccb55c0599..530931974a 100644
--- a/lib/concat-filename.c
+++ b/lib/concat-filename.c
@@ -64,7 +64,7 @@ concatenated_filename (const char *directory, const char *filename,
       memcpy (result, directory, directory_len);
       p = result + directory_len;
       if (need_slash)
-        *p++ = '/';
+        *p++ = DIR_SEPARATOR;
     }
   p = stpcpy (p, filename);
   if (suffix != NULL)
diff --git a/lib/creat.c b/lib/creat.c
index 84a1b9b9ff..5624c79b13 100644
--- a/lib/creat.c
+++ b/lib/creat.c
@@ -47,6 +47,7 @@ orig_creat (const char *filename, mode_t mode)
 #include <errno.h>
 #include <string.h>
 #include <sys/types.h>
+#include "filename.h"
 
 int
 creat (const char *filename, mode_t mode)
@@ -67,7 +68,7 @@ creat (const char *filename, mode_t mode)
      creat() must fail since creat() cannot create directories.  */
   {
     size_t len = strlen (filename);
-    if (len > 0 && filename[len - 1] == '/')
+    if (len > 0 && ISSLASH(filename[len - 1]))
       {
         errno = EISDIR;
         return -1;
diff --git a/lib/dirname.h b/lib/dirname.h
index d4d03f662e..497cd392f9 100644
--- a/lib/dirname.h
+++ b/lib/dirname.h
@@ -30,7 +30,7 @@
 # include "basename-lgpl.h"
 
 # ifndef DIRECTORY_SEPARATOR
-#  define DIRECTORY_SEPARATOR '/'
+#  define DIRECTORY_SEPARATOR DIR_SEPARATOR
 # endif
 
 #ifdef __cplusplus
diff --git a/lib/exclude.c b/lib/exclude.c
index 485beb64f5..92c1460553 100644
--- a/lib/exclude.c
+++ b/lib/exclude.c
@@ -337,7 +337,7 @@ fnmatch_no_wildcards (char const *pattern, char const *f, int options)
       if (! r)
         {
           r = f[patlen];
-          if (r == '/')
+          if (ISSLASH(r))
             r = 0;
         }
       return r;
@@ -353,9 +353,9 @@ fnmatch_no_wildcards (char const *pattern, char const *f, int options)
 
       char *fcopy = xstrdup (f);
       int r;
-      for (char *p = fcopy; ; *p++ = '/')
+      for (char *p = fcopy; ; *p++ = DIR_SEPARATOR)
         {
-          p = strchr (p, '/');
+          p = strpbrk(p, SLASHES);
           if (p)
             *p = '\0';
           r = mbscasecmp (pattern, fcopy);
@@ -378,7 +378,7 @@ exclude_fnmatch (char const *pattern, char const *f, int options)
 
   if (! (options & EXCLUDE_ANCHORED))
     for (char const *p = f; *p && ! matched; p++)
-      if (*p == '/' && p[1] != '/')
+      if ( ISSLASH(*p) && ! ISSLASH(p[1]))
         matched = matcher (pattern, p + 1, options) == 0;
 
   return matched;
@@ -429,7 +429,7 @@ file_name_matches (struct exclude_segment const *seg, char const *f,
             return true;
           if (options & FNM_LEADING_DIR)
             {
-              char *p = strrchr (buffer, '/');
+              char *p = LAST_SLASH_IN_PATH(buffer);
               if (p)
                 {
                   *p = '\0';
@@ -441,7 +441,7 @@ file_name_matches (struct exclude_segment const *seg, char const *f,
 
       if (!(options & EXCLUDE_ANCHORED))
         {
-          f = strchr (f, '/');
+          f = strpbrk (f, SLASHES);
           if (f)
             f++;
         }
diff --git a/lib/faccessat.c b/lib/faccessat.c
index abb912090a..495ea0e26d 100644
--- a/lib/faccessat.c
+++ b/lib/faccessat.c
@@ -30,6 +30,8 @@
 #include <stdlib.h>
 #include <string.h>
 #include <sys/stat.h>
+#include "filename.h"
+
 #undef _GL_INCLUDING_UNISTD_H
 
 #if HAVE_FACCESSAT
@@ -44,7 +46,7 @@ orig_faccessat (int fd, char const *name, int mode, int flag)
 /* Write "unistd.h" here, not <unistd.h>, otherwise OSF/1 5.1 DTK cc
    eliminates this include because of the preliminary #include <unistd.h>
    above.  */
-# include "unistd.h"
+#include "unistd.h"
 #else
 # include <unistd.h>
 #endif
@@ -63,7 +65,7 @@ rpl_faccessat (int fd, char const *file, int mode, int flag)
 {
   int result = orig_faccessat (fd, file, mode, flag);
 
-  if (file[strlen (file) - 1] == '/')
+  if ( ISSLASH(file[strlen (file) - 1]) )
     {
       struct stat st;
       int ret = fstatat (fd, file, &st, 0);
diff --git a/lib/fchownat.c b/lib/fchownat.c
index 453810d653..a18f08334b 100644
--- a/lib/fchownat.c
+++ b/lib/fchownat.c
@@ -31,6 +31,7 @@
 #include <string.h>
 
 #include "openat.h"
+#include "filename.h"
 
 #if !HAVE_FCHOWNAT
 
@@ -101,7 +102,7 @@ rpl_fchownat (int fd, char const *file, uid_t owner, gid_t group, int flag)
   {
     size_t len = strlen (file);
     struct stat st;
-    if (len && file[len - 1] == '/')
+    if (len && ISSLASH(file[len - 1]))
       {
         if (fstatat (fd, file, &st, 0))
           return -1;
diff --git a/lib/filename.h b/lib/filename.h
index e353363e99..c31e157e4d 100644
--- a/lib/filename.h
+++ b/lib/filename.h
@@ -57,8 +57,12 @@ extern "C" {
  */
 #if defined _WIN32 || defined __CYGWIN__ \
     || defined __EMX__ || defined __MSDOS__ || defined __DJGPP__
-  /* Native Windows, Cygwin, OS/2, DOS */
-# define ISSLASH(C) ((C) == '/' || (C) == '\\')
+
+ /* Native Windows, Cygwin, OS/2, DOS */
+const char* strrpbrk(const char* s, const char* accept);
+# define DIR_SEPARATOR		'\\'
+# define ISSLASH(C) ((C) == '/' || (C) == DIR_SEPARATOR)
+# define SLASHES			"\\/"
   /* Internal macro: Tests whether a character is a drive letter.  */
 # define _IS_DRIVE_LETTER(C) \
     (((C) >= 'A' && (C) <= 'Z') || ((C) >= 'a' && (C) <= 'z'))
@@ -88,15 +92,36 @@ extern "C" {
 # define IS_FILE_NAME_WITH_DIR(Filename) \
     (strchr ((Filename), '/') != NULL || strchr ((Filename), '\\') != NULL \
      || HAS_DEVICE (Filename))
+# define LAST_SLASH_IN_PATH(str) strrpbrk(str,SLASHES)
+# define PATH_CHAR_EQ(c1, c2) ( tolower(c1) == tolower(c2) )
+
+	//could not find a good place to put this otherwise
+	static const char* strrpbrk(const char* s, const char* accept) {
+		const char* p = s + strlen(s);
+		while (--p >= s) {
+			const char* c = accept;
+			while (*c) {
+				if (*c++ == *p)
+					return p;
+			}
+		}
+		return NULL;
+	}
+
+
 #else
   /* Unix */
-# define ISSLASH(C) ((C) == '/')
+# define DIR_SEPARATOR		'/'
+# define ISSLASH(C) ((C) == DIR_SEPARATOR)
+# define SLASHES			"/"
 # define HAS_DEVICE(Filename) ((void) (Filename), 0)
 # define FILE_SYSTEM_PREFIX_LEN(Filename) ((void) (Filename), 0)
 # define FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE 0
 # define IS_ABSOLUTE_FILE_NAME(Filename) ISSLASH ((Filename)[0])
 # define IS_RELATIVE_FILE_NAME(Filename) (! ISSLASH ((Filename)[0]))
 # define IS_FILE_NAME_WITH_DIR(Filename) (strchr ((Filename), '/') != NULL)
+#define LAST_SLASH_IN_PATH(str) strrchr(str,SLASHES)
+#define PATH_CHAR_EQ(c1, c2) (c1 == c2)
 #endif
 
 /* Deprecated macros.  For backward compatibility with old users of the
diff --git a/lib/filenamecat-lgpl.c b/lib/filenamecat-lgpl.c
index 10c3ea8eb7..dd0b0f110a 100644
--- a/lib/filenamecat-lgpl.c
+++ b/lib/filenamecat-lgpl.c
@@ -56,7 +56,7 @@ mfile_name_concat (char const *dir, char const *base, char **base_in_result)
     {
       /* DIR is not a file system root, so separate with / if needed.  */
       if (! ISSLASH (dir[dirlen - 1]) && ! ISSLASH (*base))
-        sep = '/';
+        sep = DIR_SEPARATOR;
     }
   else if (ISSLASH (*base))
     {
diff --git a/lib/findprog-in.c b/lib/findprog-in.c
index a07dee534d..591d2089d0 100644
--- a/lib/findprog-in.c
+++ b/lib/findprog-in.c
@@ -30,13 +30,7 @@
 #include "filename.h"
 #include "concat-filename.h"
 
-#if (defined _WIN32 && !defined __CYGWIN__) || defined __EMX__ || defined __DJGPP__
-  /* Native Windows, OS/2, DOS */
-# define NATIVE_SLASH '\\'
-#else
-  /* Unix */
-# define NATIVE_SLASH '/'
-#endif
+# define NATIVE_SLASH DIR_SEPARATOR
 
 /* Separator in PATH like lists of pathnames.  */
 #if (defined _WIN32 && !defined __CYGWIN__) || defined __EMX__ || defined __DJGPP__
diff --git a/lib/fnmatch_loop.c b/lib/fnmatch_loop.c
index e361be2f76..4421389b1d 100644
--- a/lib/fnmatch_loop.c
+++ b/lib/fnmatch_loop.c
@@ -18,6 +18,7 @@
 #ifdef _LIBC
 # include <stdint.h>
 #endif
+#include "filename.h"
 
 struct STRUCT
 {
@@ -70,7 +71,7 @@ FCT (const CHAR *pattern, const CHAR *string, const CHAR *string_end,
 
           if (n == string_end)
             return FNM_NOMATCH;
-          else if (*n == L_('/') && (flags & FNM_FILE_NAME))
+          else if ( ISSLASH(*n) && (flags & FNM_FILE_NAME))
             return FNM_NOMATCH;
           else if (*n == L_('.') && no_leading_period)
             return FNM_NOMATCH;
@@ -127,7 +128,7 @@ FCT (const CHAR *pattern, const CHAR *string, const CHAR *string_end,
                   if (n == string_end)
                     /* There isn't another character; no match.  */
                     return FNM_NOMATCH;
-                  else if (*n == L_('/')
+                  else if ( ISSLASH(*n)
                            && __glibc_unlikely (flags & FNM_FILE_NAME))
                     /* A slash does not match a wildcard under
                        FNM_FILE_NAME.  */
@@ -154,7 +155,7 @@ FCT (const CHAR *pattern, const CHAR *string, const CHAR *string_end,
                     result = 0;
                   else
                     {
-                      if (MEMCHR (n, L_('/'), string_end - n) == NULL)
+                      if (MEMCHR (n, L_('/'), string_end - n) == NULL && MEMCHR(n, DIR_SEPARATOR, string_end - n) == NULL)
                         result = 0;
                     }
                 }
@@ -167,8 +168,10 @@ FCT (const CHAR *pattern, const CHAR *string, const CHAR *string_end,
               struct STRUCT end;
 
               end.pattern = NULL;
-              endp = MEMCHR (n, (flags & FNM_FILE_NAME) ? L_('/') : L_('\0'),
+              endp = MEMCHR (n, (flags & FNM_FILE_NAME) ? DIR_SEPARATOR : L_('\0'),
                              string_end - n);
+			  if (endp == NULL && (flags & FNM_FILE_NAME) && DIR_SEPARATOR != '/')
+				  endp = MEMCHR(n, L_('/'), string_end - n);
               if (endp == NULL)
                 endp = string_end;
 
@@ -185,11 +188,11 @@ FCT (const CHAR *pattern, const CHAR *string, const CHAR *string_end,
                              &end, alloca_used) == 0)
                       goto found;
                 }
-              else if (c == L_('/') && (flags & FNM_FILE_NAME))
+              else if (ISSLASH(c) && (flags & FNM_FILE_NAME))
                 {
-                  while (n < string_end && *n != L_('/'))
+                  while (n < string_end && ! ISSLASH(*n))
                     ++n;
-                  if (n < string_end && *n == L_('/')
+                  if (n < string_end && ISSLASH (*n)
                       && (FCT (p, n + 1, string_end, flags & FNM_PERIOD, flags,
                                NULL, alloca_used) == 0))
                     return 0;
@@ -243,7 +246,7 @@ FCT (const CHAR *pattern, const CHAR *string, const CHAR *string_end,
             if (*n == L_('.') && no_leading_period)
               return FNM_NOMATCH;
 
-            if (*n == L_('/') && (flags & FNM_FILE_NAME))
+            if (ISSLASH(*n) && (flags & FNM_FILE_NAME))
               /* '/' cannot be matched.  */
               return FNM_NOMATCH;
 
@@ -922,7 +925,7 @@ FCT (const CHAR *pattern, const CHAR *string, const CHAR *string_end,
   if (n == string_end)
     return 0;
 
-  if ((flags & FNM_LEADING_DIR) && n != string_end && *n == L_('/'))
+  if ((flags & FNM_LEADING_DIR) && n != string_end && ISSLASH( *n ))
     /* The FNM_LEADING_DIR flag says that "foo*" matches "foobar/frobozz".  */
     return 0;
 
@@ -1100,7 +1103,7 @@ EXT (INT opt, const CHAR *pattern, const CHAR *string, const CHAR *string_end,
                 && (FCT (p, rs, string_end,
                          rs == string
                          ? no_leading_period
-                         : rs[-1] == '/' && NO_LEADING_PERIOD (flags),
+                         : ISSLASH(rs[-1]) && NO_LEADING_PERIOD (flags),
                          flags & FNM_FILE_NAME
                          ? flags : flags & ~FNM_PERIOD, NULL, alloca_used) == 0
                     /* This didn't work.  Try the whole pattern.  */
@@ -1108,7 +1111,7 @@ EXT (INT opt, const CHAR *pattern, const CHAR *string, const CHAR *string_end,
                         && FCT (pattern - 1, rs, string_end,
                                 rs == string
                                 ? no_leading_period
-                                : rs[-1] == '/' && NO_LEADING_PERIOD (flags),
+                                : ISSLASH(rs[-1]) && NO_LEADING_PERIOD (flags),
                                 flags & FNM_FILE_NAME
                                 ? flags : flags & ~FNM_PERIOD, NULL,
                                 alloca_used) == 0)))
@@ -1160,7 +1163,7 @@ EXT (INT opt, const CHAR *pattern, const CHAR *string, const CHAR *string_end,
               && (FCT (p, rs, string_end,
                        rs == string
                        ? no_leading_period
-                       : rs[-1] == '/' && NO_LEADING_PERIOD (flags),
+                       : ISSLASH(rs[-1]) && NO_LEADING_PERIOD (flags),
                        flags & FNM_FILE_NAME ? flags : flags & ~FNM_PERIOD,
                        NULL, alloca_used) == 0))
             /* This is successful.  */
diff --git a/lib/fopen.c b/lib/fopen.c
index 41587d2c05..e3d8821101 100644
--- a/lib/fopen.c
+++ b/lib/fopen.c
@@ -24,6 +24,7 @@
 
 /* Get the original definition of fopen.  It might be defined as a macro.  */
 #include <stdio.h>
+#include "filename.h"
 #undef _GL_SKIP_GNULIB_STDIO_H
 
 static FILE *
@@ -167,7 +168,7 @@ rpl_fopen (const char *filename, const char *mode)
      fopen() must fail since the file does not contain a '.' directory.  */
   {
     size_t len = strlen (filename);
-    if (len > 0 && filename[len - 1] == '/')
+    if (len > 0 && ISSLASH(filename[len - 1]))
       {
         int fd;
         struct stat statbuf;
diff --git a/lib/fstatat.c b/lib/fstatat.c
index 36dd5e9a20..f2a73a6ced 100644
--- a/lib/fstatat.c
+++ b/lib/fstatat.c
@@ -26,6 +26,7 @@
 /* Get the original definition of fstatat.  It might be defined as a macro.  */
 #include <sys/types.h>
 #include <sys/stat.h>
+#include "filename.h"
 #undef __need_system_sys_stat_h
 
 #if HAVE_FSTATAT && HAVE_WORKING_FSTATAT_ZERO_FLAG
@@ -85,7 +86,7 @@ rpl_fstatat (int fd, char const *file, struct stat *st, int flag)
   if (flag & AT_SYMLINK_NOFOLLOW)
     {
       /* Fix lstat behavior.  */
-      if (file[len - 1] != '/' || S_ISDIR (st->st_mode))
+      if (ISSLASH(file[len - 1]) || S_ISDIR (st->st_mode))
         return 0;
       if (!S_ISLNK (st->st_mode))
         {
@@ -95,7 +96,7 @@ rpl_fstatat (int fd, char const *file, struct stat *st, int flag)
       result = normal_fstatat (fd, file, st, flag & ~AT_SYMLINK_NOFOLLOW);
     }
   /* Fix stat behavior.  */
-  if (result == 0 && !S_ISDIR (st->st_mode) && file[len - 1] == '/')
+  if (result == 0 && !S_ISDIR (st->st_mode) && ISSLASH(file[len - 1]))
     {
       errno = ENOTDIR;
       return -1;
diff --git a/lib/fts.c b/lib/fts.c
index b611e997d4..b3b326f5a0 100644
--- a/lib/fts.c
+++ b/lib/fts.c
@@ -67,7 +67,7 @@ static char sccsid[] = "@(#)fts.c       8.6 (Berkeley) 8/14/94";
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
-
+#include "filename.h"
 #if ! _LIBC
 # include "attribute.h"
 # include "fcntl--.h"
@@ -473,8 +473,8 @@ fts_open (char * const *argv,
                     /* If there are two or more trailing slashes, trim all but one,
                        but don't change "//" to "/", and do map "///" to "/".  */
                     char const *v = *argv;
-                    if (2 < len && v[len - 1] == '/')
-                      while (1 < len && v[len - 2] == '/')
+                    if (2 < len && ISSLASH(v[len - 1]))
+                      while (1 < len && ISSLASH(v[len - 2]))
                         --len;
                   }
 
@@ -563,7 +563,7 @@ fts_load (FTS *sp, register FTSENT *p)
          */
         len = p->fts_pathlen = p->fts_namelen;
         memmove(sp->fts_path, p->fts_name, len + 1);
-        if ((cp = strrchr(p->fts_name, '/')) && (cp != p->fts_name || cp[1])) {
+		if ((cp = LAST_SLASH_IN_PATH(p->fts_name)) && (cp != p->fts_name || cp[1])) {
                 len = strlen(++cp);
                 memmove(p->fts_name, cp, len + 1);
                 p->fts_namelen = len;
@@ -832,7 +832,7 @@ leaf_optimization (_GL_UNUSED FTSENT const *p, _GL_UNUSED int dir_fd)
  * appended which would cause file names to be written as "....//foo".
  */
 #define NAPPEND(p)                                                      \
-        (p->fts_path[p->fts_pathlen - 1] == '/'                         \
+        (ISSLASH(p->fts_path[p->fts_pathlen - 1])                      \
             ? p->fts_pathlen - 1 : p->fts_pathlen)
 
 FTSENT *
@@ -1006,7 +1006,7 @@ next:   tmp = p;
                 }
 
 name:           t = sp->fts_path + NAPPEND(p->fts_parent);
-                *t++ = '/';
+                *t++ = DIR_SEPARATOR;
                 memmove(t, p->fts_name, p->fts_namelen + 1);
 check_for_dir:
                 sp->fts_cur = p;
@@ -1159,7 +1159,7 @@ fts_children (register FTS *sp, int instr)
          * directory is, so we can't get back so that the upcoming chdir by
          * fts_read will work.
          */
-        if (p->fts_level != FTS_ROOTLEVEL || p->fts_accpath[0] == '/' ||
+        if (p->fts_level != FTS_ROOTLEVEL || IS_ABSOLUTE_FILE_NAME(p->fts_accpath) ||
             ISSET(FTS_NOCHDIR))
                 return (sp->fts_child = fts_build(sp, instr));
 
@@ -1423,7 +1423,7 @@ fts_build (register FTS *sp, int type)
         len = NAPPEND(cur);
         if (ISSET(FTS_NOCHDIR)) {
                 cp = sp->fts_path + len;
-                *cp++ = '/';
+                *cp++ = DIR_SEPARATOR;
         } else {
                 /* GCC, you're too verbose. */
                 cp = NULL;
diff --git a/lib/getcwd.c b/lib/getcwd.c
index 05b5e56a37..1431a330e9 100644
--- a/lib/getcwd.c
+++ b/lib/getcwd.c
@@ -30,7 +30,7 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <stddef.h>
-
+#include "filename.h"
 #include <fcntl.h> /* For AT_FDCWD on Solaris 9.  */
 
 /* If this host provides the openat function or if we're using the
@@ -319,7 +319,7 @@ __getcwd_generic (char *buf, size_t size)
       dirstream = __opendir (dotlist);
       if (dirstream == NULL)
         goto lose;
-      dotlist[dotlen++] = '/';
+      dotlist[dotlen++] = DIR_SEPARATOR;
 #endif
       for (;;)
         {
@@ -396,7 +396,7 @@ __getcwd_generic (char *buf, size_t size)
                   {
                     dotlist[i++] = '.';
                     dotlist[i++] = '.';
-                    dotlist[i++] = '/';
+                    dotlist[i++] = DIR_SEPARATOR;
                   }
                 while (i < dotlen);
               }
@@ -445,7 +445,7 @@ __getcwd_generic (char *buf, size_t size)
         }
       dirp -= namlen;
       memcpy (dirp, d->d_name, namlen);
-      *--dirp = '/';
+      *--dirp = DIR_SEPARATOR;
 
       thisdev = dotdev;
       thisino = dotino;
@@ -525,7 +525,7 @@ __getcwd_generic (char *buf, size_t size)
     }
 
   if (dirp == &dir[allocated - 1])
-    *--dirp = '/';
+    *--dirp = DIR_SEPARATOR;
 
 #if ! HAVE_OPENAT_SUPPORT
   if (dotlist != dots)
diff --git a/lib/glob.c b/lib/glob.c
index 0bd8b4237c..1bd310b2a0 100644
--- a/lib/glob.c
+++ b/lib/glob.c
@@ -50,6 +50,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <alloca.h>
+#include "filename.h"
 
 #ifdef _LIBC
 # undef strdup
@@ -308,7 +309,7 @@ __glob (const char *pattern, int flags, int (*errfunc) (const char *, int),
 
   /* POSIX requires all slashes to be matched.  This means that with
      a trailing slash we must match only directories.  */
-  if (pattern[0] && pattern[strlen (pattern) - 1] == '/')
+  if (pattern[0] && ISSLASH(pattern[strlen (pattern) - 1]))
     flags |= GLOB_ONLYDIR;
 
   if (!(flags & GLOB_DOOFFS))
@@ -472,7 +473,7 @@ __glob (const char *pattern, int flags, int (*errfunc) (const char *, int),
   oldcount = pglob->gl_pathc + pglob->gl_offs;
 
   /* Find the filename.  */
-  filename = strrchr (pattern, '/');
+  filename = LAST_SLASH_IN_PATH(pattern);
 
 #if defined __MSDOS__ || defined WINDOWS32
   /* The case of "d:pattern".  Since ':' is not allowed in
@@ -560,7 +561,7 @@ __glob (const char *pattern, int flags, int (*errfunc) (const char *, int),
       bool drive_root = (dirlen > 1
                          && (dirname[dirlen - 1] == ':'
                              || (dirlen > 2 && dirname[dirlen - 2] == ':'
-                                 && dirname[dirlen - 1] == '/')));
+                                 && ISSLASH(dirname[dirlen - 1]) )));
 #else
       bool drive_root = false;
 #endif
@@ -569,7 +570,7 @@ __glob (const char *pattern, int flags, int (*errfunc) (const char *, int),
         /* "pattern/".  Expand "pattern", appending slashes.  */
         {
           int orig_flags = flags;
-          if (!(flags & GLOB_NOESCAPE) && dirname[dirlen - 1] == '\\')
+          if (!(flags & GLOB_NOESCAPE) && ISSLASH(dirname[dirlen - 1]))
             {
               /* "pattern\\/".  Remove the final backslash if it hasn't
                  been quoted.  */
@@ -601,9 +602,9 @@ __glob (const char *pattern, int flags, int (*errfunc) (const char *, int),
 
   if ((flags & (GLOB_TILDE|GLOB_TILDE_CHECK)) && dirname[0] == '~')
     {
-      if (dirname[1] == '\0' || dirname[1] == '/'
-          || (!(flags & GLOB_NOESCAPE) && dirname[1] == '\\'
-              && (dirname[2] == '\0' || dirname[2] == '/')))
+      if (dirname[1] == '\0' || ISSLASH(dirname[1])
+          || (!(flags & GLOB_NOESCAPE) && ISSLASH(dirname[1])
+              && (dirname[2] == '\0' || ISSLASH(dirname[2]))))
         {
           /* Look up home directory.  */
           char *home_dir = getenv ("HOME");
@@ -736,7 +737,7 @@ __glob (const char *pattern, int flags, int (*errfunc) (const char *, int),
 #ifndef WINDOWS32
           /* Recognize ~user as a shorthand for the specified user's home
              directory.  */
-          char *end_name = strchr (dirname, '/');
+          char *end_name = strpbrk(dirname, SLASHES);
           char *user_name;
           int malloc_user_name = 0;
           char *unescape = NULL;
@@ -923,7 +924,7 @@ __glob (const char *pattern, int flags, int (*errfunc) (const char *, int),
           if (pglob->gl_pathv[newcount] == NULL)
             goto nospace;
           p = mempcpy (pglob->gl_pathv[newcount], dirname, dirlen);
-          p[0] = '/';
+          p[0] = DIR_SEPARATOR;
           p[1] = '\0';
           if (__glibc_unlikely (malloc_dirname))
             free (dirname);
@@ -1214,9 +1215,9 @@ prefix_array (const char *dirname, char **array, size_t n)
 {
   size_t i;
   size_t dirlen = strlen (dirname);
-  char dirsep_char = '/';
+  char dirsep_char = DIR_SEPARATOR;
 
-  if (dirlen == 1 && dirname[0] == '/')
+  if (dirlen == 1 && ISSLASH(dirname[0]) )
     /* DIRNAME is just "/", so normal prepending would get us "//foo".
        We want "/foo" instead, so don't prepend any chars from DIRNAME.  */
     dirlen = 0;
@@ -1224,7 +1225,7 @@ prefix_array (const char *dirname, char **array, size_t n)
 #if defined __MSDOS__ || defined WINDOWS32
   if (dirlen > 1)
     {
-      if (dirname[dirlen - 1] == '/' && dirname[dirlen - 2] == ':')
+      if (ISSLASH(dirname[dirlen - 1]) && dirname[dirlen - 2] == ':')
         /* DIRNAME is "d:/".  Don't prepend the slash from DIRNAME.  */
         --dirlen;
       else if (dirname[dirlen - 1] == ':')
@@ -1385,8 +1386,8 @@ glob_in_dir (const char *pattern, const char *directory, int flags,
                             && !scratch_buffer_set_array_size (&s, need, 1))
                           goto memory_error;
                         char *p = mempcpy (s.data, directory, dirlen);
-                        *p = '/';
-                        p += p[-1] != '/';
+                        *p = DIR_SEPARATOR;
+                        p += ISSLASH(p[-1]);
                         memcpy (p, d.name, namelen + 1);
                         if (! is_dir (s.data, flags, pglob))
                           continue;
diff --git a/lib/lchmod.c b/lib/lchmod.c
index 4391a4aa94..4f938f9e01 100644
--- a/lib/lchmod.c
+++ b/lib/lchmod.c
@@ -29,6 +29,7 @@
 #include <unistd.h>
 
 #include <intprops.h>
+#include "filename.h"
 
 /* Work like chmod, except when FILE is a symbolic link.
    In that case, on systems where permissions on symbolic links are unsupported
@@ -69,7 +70,7 @@ lchmod (char const *file, mode_t mode)
 #endif
 
   size_t len = strlen (file);
-  if (len && file[len - 1] == '/')
+  if (len && ISSLASH(file[len - 1]) )
     {
       struct stat st;
       if (lstat (file, &st) < 0)
diff --git a/lib/lchown.c b/lib/lchown.c
index 74cb9afa41..ce02570a9b 100644
--- a/lib/lchown.c
+++ b/lib/lchown.c
@@ -25,6 +25,7 @@
 #include <errno.h>
 #include <string.h>
 #include <sys/stat.h>
+#include "filename.h"
 
 #if !HAVE_LCHOWN
 
@@ -89,7 +90,7 @@ rpl_lchown (const char *file, uid_t uid, gid_t gid)
   if (!stat_valid)
     {
       size_t len = strlen (file);
-      if (len && file[len - 1] == '/')
+      if (len && ISSLASH(file[len - 1]))
         return chown (file, uid, gid);
     }
 # endif
diff --git a/lib/link.c b/lib/link.c
index b2f2132f5e..edbdd81429 100644
--- a/lib/link.c
+++ b/lib/link.c
@@ -23,6 +23,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <sys/stat.h>
+#include "filename.h"
 
 #if !HAVE_LINK
 # if defined _WIN32 && ! defined __CYGWIN__
@@ -87,8 +88,8 @@ link (const char *file1, const char *file2)
     }
   /* Reject trailing slashes on non-directories; native Windows does not
      support hard-linking directories.  */
-  if ((len1 && (file1[len1 - 1] == '/' || file1[len1 - 1] == '\\'))
-      || (len2 && (file2[len2 - 1] == '/' || file2[len2 - 1] == '\\')))
+  if ((len1 && ISSLASH(file1[len1 - 1]))
+      || (len2 && ISSLASH(file2[len2 - 1])))
     {
       /* If stat() fails, then link() should fail for the same reason.  */
       struct stat st;
@@ -113,7 +114,7 @@ link (const char *file1, const char *file2)
   {
     struct stat st;
     char *p = strchr (dir, '\0');
-    while (dir < p && (*--p != '/' && *p != '\\'));
+    while (dir < p && (--p) && !ISSLASH(*p));
     *p = '\0';
     if (p != dir && stat (dir, &st) != 0 && errno != EOVERFLOW)
       {
@@ -196,8 +197,8 @@ rpl_link (char const *file1, char const *file2)
   /* Reject trailing slashes on non-directories.  */
   len1 = strlen (file1);
   len2 = strlen (file2);
-  if ((len1 && file1[len1 - 1] == '/')
-      || (len2 && file2[len2 - 1] == '/'))
+  if ((len1 && ISSLASH(file1[len1 - 1]))
+      || (len2 && ISSLASH(file2[len2 - 1])))
     {
       /* Let link() decide whether hard-linking directories is legal.
          If stat() fails, then link() should fail for the same reason
@@ -220,7 +221,7 @@ rpl_link (char const *file1, char const *file2)
         return -1;
       /* We already know file2 does not end in slash.  Strip off the
          basename, then check that the dirname exists.  */
-      p = strrchr (dir, '/');
+      p = LAST_SLASH_IN_PATH(dir);
       if (p)
         {
           *p = '\0';
diff --git a/lib/linkat.c b/lib/linkat.c
index d1d789b73e..6ba8e86e1b 100644
--- a/lib/linkat.c
+++ b/lib/linkat.c
@@ -32,6 +32,7 @@
 #include "eloop-threshold.h"
 #include "filenamecat.h"
 #include "openat-priv.h"
+#include "filename.h"
 
 #if !HAVE_LINKAT || LINKAT_SYMLINK_NOTSUP
 
@@ -278,8 +279,8 @@ rpl_linkat (int fd1, char const *file1, int fd2, char const *file2, int flag)
   {
     size_t len1 = strlen (file1);
     size_t len2 = strlen (file2);
-    if ((len1 && file1[len1 - 1] == '/')
-        || (len2 && file2[len2 - 1] == '/'))
+    if ((len1 && ISSLASH(file1[len1 - 1]) )
+        || (len2 && ISSLASH(file2[len2 - 1])))
       {
         /* Let linkat() decide whether hard-linking directories is legal.
            If fstatat() fails, then linkat() should fail for the same reason;
diff --git a/lib/lstat.c b/lib/lstat.c
index bb4a59f174..531c229b45 100644
--- a/lib/lstat.c
+++ b/lib/lstat.c
@@ -22,7 +22,7 @@
    rpl_lstat.  */
 #define __need_system_sys_stat_h
 #include <config.h>
-
+#include "filename.h"
 #if !HAVE_LSTAT
 /* On systems that lack symlinks, our replacement <sys/stat.h> already
    defined lstat as stat, so there is nothing further to do other than
@@ -81,7 +81,7 @@ rpl_lstat (const char *file, struct stat *sbuf)
      out above, with a failure return of ENOENT.  */
   if (result == 0)
     {
-      if (S_ISDIR (sbuf->st_mode) || file[strlen (file) - 1] != '/')
+      if (S_ISDIR (sbuf->st_mode) || ISSLASH(file[strlen (file) - 1]))
         result = stat_time_normalize (result, sbuf);
       else
         {
diff --git a/lib/mkfifo.c b/lib/mkfifo.c
index 419b7b1dfd..765380167d 100644
--- a/lib/mkfifo.c
+++ b/lib/mkfifo.c
@@ -22,6 +22,7 @@
 
 #include <errno.h>
 #include <string.h>
+#include "filename.h"
 
 #if !HAVE_MKFIFO
 /* Mingw lacks mkfifo; always fail with ENOSYS.  */
@@ -45,7 +46,7 @@ rpl_mkfifo (char const *name, mode_t mode)
 {
 # if MKFIFO_TRAILING_SLASH_BUG
   size_t len = strlen (name);
-  if (len && name[len - 1] == '/')
+  if (len && ISSLASH(name[len - 1]) )
     {
       struct stat st;
       if (stat (name, &st) == 0 || errno == EOVERFLOW)
diff --git a/lib/mkfifoat.c b/lib/mkfifoat.c
index 8bac32111b..6d7ac58b1f 100644
--- a/lib/mkfifoat.c
+++ b/lib/mkfifoat.c
@@ -22,6 +22,7 @@
 #include <sys/stat.h>
 
 #include <stdlib.h>
+#include "filename.h"
 
 #if HAVE_MKFIFOAT
 
@@ -35,7 +36,7 @@ rpl_mkfifoat (int fd, char const *file, mode_t mode)
 {
   /* Use the original mkfifoat(), but correct the trailing slash handling.  */
   size_t len = strlen (file);
-  if (len && file[len - 1] == '/')
+  if (len && ISSLASH(file[len - 1]) )
     {
       struct stat st;
 
diff --git a/lib/mknodat.c b/lib/mknodat.c
index 2154a94451..cdd79d34a2 100644
--- a/lib/mknodat.c
+++ b/lib/mknodat.c
@@ -22,6 +22,7 @@
 #include <sys/stat.h>
 
 #include <stdlib.h>
+#include "filename.h"
 
 #if HAVE_MKNODAT
 
@@ -35,7 +36,7 @@ rpl_mknodat (int fd, char const *file, mode_t mode, dev_t dev)
 {
   /* Use the original mknodat(), but correct the trailing slash handling.  */
   size_t len = strlen (file);
-  if (len && file[len - 1] == '/')
+  if (len && ISSLASH(file[len - 1]) )
     {
       struct stat st;
 
diff --git a/lib/mountlist.c b/lib/mountlist.c
index 3376b730fc..4914fa505e 100644
--- a/lib/mountlist.c
+++ b/lib/mountlist.c
@@ -30,7 +30,7 @@
 #include <errno.h>
 
 #include <fcntl.h>
-
+#include "filename.h"
 #include <unistd.h>
 
 #if HAVE_SYS_PARAM_H
@@ -704,7 +704,7 @@ read_file_system_list (bool need_fs_type)
             else
               {
                 name = xmalloc (1 + strlen (d->d_name) + 1);
-                name[0] = '/';
+                name[0] = DIR_SEPARATOR;
                 strcpy (name + 1, d->d_name);
               }
 
diff --git a/lib/open.c b/lib/open.c
index 7415b48f81..49671617d4 100644
--- a/lib/open.c
+++ b/lib/open.c
@@ -21,7 +21,7 @@
    rpl_open.  */
 #define __need_system_fcntl_h
 #include <config.h>
-
+#include "filename.h"
 /* Get the original definition of open.  It might be defined as a macro.  */
 #include <fcntl.h>
 #include <sys/types.h>
@@ -30,11 +30,23 @@
 static int
 orig_open (const char *filename, int flags, mode_t mode)
 {
+	int fd;
 #if defined _WIN32 && !defined __CYGWIN__
-  return _open (filename, flags, mode);
+  fd = _open (filename, flags, mode);
 #else
-  return open (filename, flags, mode);
+  fd = open (filename, flags, mode);
+#endif
+#if defined _WIN32
+  if (fd < 0 && errno == ENOENT && strlen(filename) > 1 && ISSLASH(filename[strlen(filename) - 1]) ) {   ///so windows is odd it doesn't like \ at the end of a path (https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-findfirstfilea see end in a trailing \)  it returns errno=2 ENOENT however while it also doesn't like a path ending in / it returns errno=13 EACCES for this (which the below then fixes)
+	  struct _stat buf;
+	  int result = _stat(filename, &buf);
+	  if (result != 0 || (buf.st_mode & _S_IFDIR) != _S_IFDIR)
+		  _set_errno(ENOENT);
+	  else
+		  _set_errno(EACCES);
+  }
 #endif
+  return fd;
 }
 
 /* Specification.  */
@@ -123,7 +135,7 @@ open (const char *filename, int flags, ...)
       || (flags & O_ACCMODE) == O_WRONLY)
     {
       size_t len = strlen (filename);
-      if (len > 0 && filename[len - 1] == '/')
+      if (len > 0 &&  ISSLASH(filename[len - 1]))
         {
           errno = EISDIR;
           return -1;
@@ -190,7 +202,7 @@ open (const char *filename, int flags, ...)
     {
       /* We know len is positive, since open did not fail with ENOENT.  */
       size_t len = strlen (filename);
-      if (filename[len - 1] == '/')
+      if (ISSLASH( filename[len - 1]) )
         {
           struct stat statbuf;
 
diff --git a/lib/openat-proc.c b/lib/openat-proc.c
index a333a3f878..c9b7916dae 100644
--- a/lib/openat-proc.c
+++ b/lib/openat-proc.c
@@ -38,6 +38,7 @@
 #endif
 
 #include "intprops.h"
+#include "filename.h"
 
 /* Set BUF to the name of the subfile of the directory identified by
    FD, where the subfile is named FILE.  If successful, return BUF if
@@ -145,7 +146,7 @@ openat_proc_name (char buf[OPENAT_BUFFER_SIZE], int fd, char const *file)
       }
 
     strcpy (result, dir);
-    result[dirlen++] = '/';
+    result[dirlen++] = DIR_SEPARATOR;
   }
 #endif
 
diff --git a/lib/openat.c b/lib/openat.c
index f6dce43ba7..0e70c14260 100644
--- a/lib/openat.c
+++ b/lib/openat.c
@@ -99,7 +99,7 @@ rpl_openat (int dfd, char const *filename, int flags, ...)
       || (flags & O_ACCMODE) == O_WRONLY)
     {
       size_t len = strlen (filename);
-      if (len > 0 && filename[len - 1] == '/')
+      if (len > 0 && ISSLASH(filename[len - 1]))
         {
           errno = EISDIR;
           return -1;
@@ -149,7 +149,7 @@ rpl_openat (int dfd, char const *filename, int flags, ...)
     {
       /* We know len is positive, since open did not fail with ENOENT.  */
       size_t len = strlen (filename);
-      if (filename[len - 1] == '/')
+      if ( ISSLASH(filename[len - 1]) )
         {
           struct stat statbuf;
 
diff --git a/lib/progname.c b/lib/progname.c
index 4a45ca3490..2a83904c0e 100644
--- a/lib/progname.c
+++ b/lib/progname.c
@@ -21,7 +21,7 @@
 /* Specification.  */
 #undef ENABLE_RELOCATABLE /* avoid defining set_program_name as a macro */
 #include "progname.h"
-
+#include "filename.h"
 #include <errno.h> /* get program_invocation_name declaration */
 #include <stdio.h>
 #include <stdlib.h>
@@ -56,7 +56,7 @@ set_program_name (const char *argv0)
       abort ();
     }
 
-  slash = strrchr (argv0, '/');
+  slash = LAST_SLASH_IN_PATH(argv0);
   base = (slash != NULL ? slash + 1 : argv0);
   if (base - argv0 >= 7 && strncmp (base - 7, "/.libs/", 7) == 0)
     {
diff --git a/lib/progreloc.c b/lib/progreloc.c
index 17848589e8..dfdeb4c20f 100644
--- a/lib/progreloc.c
+++ b/lib/progreloc.c
@@ -50,6 +50,7 @@
 #endif
 
 #include "relocatable.h"
+#include "filename.h"
 
 #ifdef NO_XMALLOC
 # include "areadlink.h"
@@ -85,25 +86,6 @@ extern char * canonicalize_file_name (const char *name);
 # define GetModuleFileName GetModuleFileNameA
 #endif
 
-/* Pathname support.
-   ISSLASH(C)                tests whether C is a directory separator character.
-   IS_FILE_NAME_WITH_DIR(P)  tests whether P contains a directory specification.
- */
-#if (defined _WIN32 && !defined __CYGWIN__) || defined __EMX__ || defined __DJGPP__
-  /* Native Windows, OS/2, DOS */
-# define ISSLASH(C) ((C) == '/' || (C) == '\\')
-# define HAS_DEVICE(P) \
-    ((((P)[0] >= 'A' && (P)[0] <= 'Z') || ((P)[0] >= 'a' && (P)[0] <= 'z')) \
-     && (P)[1] == ':')
-# define IS_FILE_NAME_WITH_DIR(P) \
-    (strchr (P, '/') != NULL || strchr (P, '\\') != NULL || HAS_DEVICE (P))
-# define FILE_SYSTEM_PREFIX_LEN(P) (HAS_DEVICE (P) ? 2 : 0)
-#else
-  /* Unix */
-# define ISSLASH(C) ((C) == '/')
-# define IS_FILE_NAME_WITH_DIR(P) (strchr (P, '/') != NULL)
-# define FILE_SYSTEM_PREFIX_LEN(P) 0
-#endif
 
 /* Use the system functions, not the gnulib overrides in this file.  */
 #undef sprintf
@@ -341,7 +323,7 @@ find_executable (const char *argv0)
   char location[4096];
   unsigned int length = sizeof (location);
   if (_NSGetExecutablePath (location, &length) == 0
-      && location[0] == '/')
+      && ISSLASH(location[0]) )
     return canonicalize_file_name (location);
 # endif
   /* Guess the executable's full path.  We assume the executable has been
@@ -352,7 +334,7 @@ find_executable (const char *argv0)
     {
       const char *p;
       for (p = argv0; *p; p++)
-        if (*p == '/')
+        if (ISSLASH(*p) )
           {
             has_slash = true;
             break;
@@ -394,7 +376,7 @@ find_executable (const char *argv0)
                 else
                   {
                     memcpy (concat_name, p, p_len);
-                    concat_name[p_len] = '/';
+                    concat_name[p_len] = DIR_SEPARATOR;
                     strcpy (concat_name + p_len + 1, argv0);
                   }
                 if (maybe_executable (concat_name))
diff --git a/lib/readlinkat.c b/lib/readlinkat.c
index 4d7851dd2c..7fd784de9c 100644
--- a/lib/readlinkat.c
+++ b/lib/readlinkat.c
@@ -20,7 +20,7 @@
 
 /* Specification.  */
 #include <unistd.h>
-
+#include "filename.h"
 #include <errno.h>
 #include <stdlib.h>
 #include <string.h>
@@ -36,7 +36,7 @@ rpl_readlinkat (int fd, char const *file, char *buf, size_t bufsize)
 {
 # if READLINK_TRAILING_SLASH_BUG
   size_t file_len = strlen (file);
-  if (file_len && file[file_len - 1] == '/')
+  if (file_len && ISSLASH(file[file_len - 1]) )
     {
       /* Even if FILE without the slash is a symlink to a directory,
          both lstat() and stat() must resolve the trailing slash to
diff --git a/lib/relocatable.c b/lib/relocatable.c
index 15b3bc442d..292ceda96a 100644
--- a/lib/relocatable.c
+++ b/lib/relocatable.c
@@ -25,7 +25,7 @@
 
 #define _GL_USE_STDLIB_ALLOC 1
 #include <config.h>
-
+#include "filename.h"
 /* Specification.  */
 #include "relocatable.h"
 
@@ -79,24 +79,6 @@
 #define false 0
 #define true 1
 
-/* Pathname support.
-   ISSLASH(C)                tests whether C is a directory separator character.
-   IS_FILE_NAME_WITH_DIR(P)  tests whether P contains a directory specification.
- */
-#if (defined _WIN32 && !defined __CYGWIN__) || defined __EMX__ || defined __DJGPP__
-  /* Native Windows, OS/2, DOS */
-# define ISSLASH(C) ((C) == '/' || (C) == '\\')
-# define HAS_DEVICE(P) \
-    ((((P)[0] >= 'A' && (P)[0] <= 'Z') || ((P)[0] >= 'a' && (P)[0] <= 'z')) \
-     && (P)[1] == ':')
-# define IS_FILE_NAME_WITH_DIR(P) \
-    (strchr (P, '/') != NULL || strchr (P, '\\') != NULL || HAS_DEVICE (P))
-# define FILE_SYSTEM_PREFIX_LEN(P) (HAS_DEVICE (P) ? 2 : 0)
-#else
-  /* Unix */
-# define ISSLASH(C) ((C) == '/')
-# define IS_FILE_NAME_WITH_DIR(P) (strchr (P, '/') != NULL)
-# define FILE_SYSTEM_PREFIX_LEN(P) 0
 #endif
 
 /* Whether to enable the more costly support for relocatable libraries.
@@ -425,9 +407,9 @@ find_shared_library_fullname ()
           if (address >= start && address <= end - 1)
             {
               /* Found it.  Now see if this line contains a filename.  */
-              while (c = getc (fp), c != EOF && c != '\n' && c != '/')
+              while (c = getc (fp), c != EOF && c != '\n' && ! ISSLASH(c))
                 continue;
-              if (c == '/')
+              if (ISSLASH(c))
                 {
                   size_t size;
                   int len;
diff --git a/lib/rename.c b/lib/rename.c
index 4e524c0ab9..9c631e38b3 100644
--- a/lib/rename.c
+++ b/lib/rename.c
@@ -320,8 +320,8 @@ rpl_rename (char const *src, char const *dst)
   }
 # endif /* RENAME_DEST_EXISTS_BUG */
 
-  src_slash = src[src_len - 1] == '/';
-  dst_slash = dst[dst_len - 1] == '/';
+  src_slash = ISSLASH(src[src_len - 1]);
+  dst_slash = ISSLASH(dst[dst_len - 1]);
 
 # if !RENAME_HARD_LINK_BUG && !RENAME_DEST_EXISTS_BUG
   /* If there are no trailing slashes, then trust the native
@@ -448,7 +448,7 @@ rpl_rename (char const *src, char const *dst)
         }
       src_len = strlen (src_temp);
       if (strncmp (src_temp, dst_temp, src_len) == 0
-          && dst_temp[src_len] == '/')
+          && ISSLASH(dst_temp[src_len]) )
         {
           rename_errno = EINVAL;
           goto out;
diff --git a/lib/renameatu.c b/lib/renameatu.c
index b71e8e3fe4..75b3227d63 100644
--- a/lib/renameatu.c
+++ b/lib/renameatu.c
@@ -163,8 +163,8 @@ renameatu (int fd1, char const *src, int fd2, char const *dst,
   if (!src_len || !dst_len)
     return renameat2ish (fd1, src, fd2, dst, flags);
 
-  src_slash = src[src_len - 1] == '/';
-  dst_slash = dst[dst_len - 1] == '/';
+  src_slash = ISSLASH(src[src_len - 1]);
+  dst_slash = ISSLASH(dst[dst_len - 1]);
   if (!src_slash && !dst_slash)
     return renameat2ish (fd1, src, fd2, dst, flags);
 
diff --git a/lib/spawni.c b/lib/spawni.c
index f6558dfd16..10e8ec42f7 100644
--- a/lib/spawni.c
+++ b/lib/spawni.c
@@ -1028,7 +1028,7 @@ __spawni (pid_t *pid, const char *file,
         }
     }
 
-  if (! use_path || strchr (file, '/') != NULL)
+  if (! use_path || IS_FILE_NAME_WITH_DIR(file))
     {
       /* The FILE parameter is actually a path.  */
       execve (file, (char * const *) argv, (char * const *) envp);
@@ -1061,7 +1061,7 @@ __spawni (pid_t *pid, const char *file,
   /* Copy the file name at the top.  */
   name = (char *) memcpy (name + pathlen + 1, file, len);
   /* And add the slash.  */
-  *--name = '/';
+  *--name = DIR_SEPARATOR;
 
   p = path;
   do
diff --git a/lib/symlink.c b/lib/symlink.c
index 8839a9818c..2d9d0f5ce9 100644
--- a/lib/symlink.c
+++ b/lib/symlink.c
@@ -19,6 +19,7 @@
 /* Specification.  */
 #include <unistd.h>
 
+#include "filename.h"
 #include <errno.h>
 #include <string.h>
 #include <sys/stat.h>
@@ -33,7 +34,7 @@ int
 rpl_symlink (char const *contents, char const *name)
 {
   size_t len = strlen (name);
-  if (len && name[len - 1] == '/')
+  if (len && ISSLASH(name[len - 1]))
     {
       struct stat st;
       if (lstat (name, &st) == 0 || errno == EOVERFLOW)
diff --git a/lib/symlinkat.c b/lib/symlinkat.c
index f24a0e0145..48d406a9a0 100644
--- a/lib/symlinkat.c
+++ b/lib/symlinkat.c
@@ -26,7 +26,7 @@
 
 #if HAVE_SYMLINKAT
 # undef symlinkat
-
+#include "filename.h"
 #include <fcntl.h>
 #include <sys/stat.h>
 #include <string.h>
@@ -36,7 +36,7 @@ int
 rpl_symlinkat (char const *contents, int fd, char const *name)
 {
   size_t len = strlen (name);
-  if (len && name[len - 1] == '/')
+  if (len && ISSLASH(name[len - 1]))
     {
       struct stat st;
       if (fstatat (fd, name, &st, AT_SYMLINK_NOFOLLOW) == 0
diff --git a/lib/tmpdir.c b/lib/tmpdir.c
index db1f1e48eb..7364b9521f 100644
--- a/lib/tmpdir.c
+++ b/lib/tmpdir.c
@@ -21,7 +21,7 @@
 
 /* Specification.  */
 #include "tmpdir.h"
-
+#include "filename.h"
 #include <stdlib.h>
 #include <string.h>
 
@@ -62,23 +62,13 @@
 # define __xstat64(version, path, buf) stat (path, buf)
 #endif
 
-/* Pathname support.
-   ISSLASH(C)           tests whether C is a directory separator character.
- */
-#if defined _WIN32 || defined __CYGWIN__ || defined __EMX__ || defined __DJGPP__
-  /* Native Windows, Cygwin, OS/2, DOS */
-# define ISSLASH(C) ((C) == '/' || (C) == '\\')
-#else
-  /* Unix */
-# define ISSLASH(C) ((C) == '/')
-#endif
 
 
 /* Return nonzero if DIR is an existent directory.  */
 static bool
 direxists (const char *dir)
 {
-  struct_stat64 buf;
+  struct_stat64 buf; 
   return __xstat64 (_STAT_VER, dir, &buf) == 0 && S_ISDIR (buf.st_mode);
 }
 
