diff --git a/lib/argp-help.c b/lib/argp-help.c
index e5baee2ca8..d3970e4f4e 100644
--- a/lib/argp-help.c
+++ b/lib/argp-help.c
@@ -47,7 +47,7 @@
 #else
 # include "gettext.h"
 #endif
-
+#include "filename.h"
 #include "argp.h"
 #include "argp-fmtstream.h"
 #include "argp-namefrob.h"
@@ -1828,7 +1828,7 @@ char *
 __argp_short_program_name (void)
 {
 # if HAVE_DECL_PROGRAM_INVOCATION_NAME
-  char *name = strrchr (program_invocation_name, '/');
+  char *name = LAST_SLASH_IN_PATH(program_invocation_name);
   return name ? name + 1 : program_invocation_name;
 # else
   /* FIXME: What now? Miles suggests that it is better to use NULL,
diff --git a/lib/basename.c b/lib/basename.c
index 21fab1efad..f88c8f3518 100644
--- a/lib/basename.c
+++ b/lib/basename.c
@@ -1,64 +1,65 @@
-/* basename.c -- return the last element in a file name
-
-   Copyright (C) 1990, 1998-2001, 2003-2006, 2009-2023 Free Software
-   Foundation, Inc.
-
-   This program is free software: you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation, either version 3 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
-
-#include <config.h>
-
-#include "dirname.h"
-
-#include <string.h>
-#include "xalloc.h"
-
-char *
-base_name (char const *name)
-{
-  char const *base = last_component (name);
-  idx_t length;
-  int dotslash_len;
-  if (*base)
-    {
-      length = base_len (base);
-
-      /* Collapse a sequence of trailing slashes into one.  */
-      length += ISSLASH (base[length]);
-
-      /* On systems with drive letters, "a/b:c" must return "./b:c" rather
-         than "b:c" to avoid confusion with a drive letter.  On systems
-         with pure POSIX semantics, this is not an issue.  */
-      dotslash_len = FILE_SYSTEM_PREFIX_LEN (base) != 0 ? 2 : 0;
-    }
-  else
-    {
-      /* There is no last component, so NAME is a file system root or
-         the empty string.  */
-      base = name;
-      length = base_len (base);
-      dotslash_len = 0;
-    }
-
-  char *p = ximalloc (dotslash_len + length + 1);
-  if (dotslash_len)
-    {
-      p[0] = '.';
-      p[1] = '/';
-    }
-
-  /* Finally, copy the basename.  */
-  memcpy (p + dotslash_len, base, length);
-  p[dotslash_len + length] = '\0';
-  return p;
-}
+/* basename.c -- return the last element in a file name
+
+   Copyright (C) 1990, 1998-2001, 2003-2006, 2009-2023 Free Software
+   Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+#include <config.h>
+
+#include "dirname.h"
+
+#include <string.h>
+#include "xalloc.h"
+#include "filename.h"
+
+char *
+base_name (char const *name)
+{
+  char const *base = last_component (name);
+  idx_t length;
+  int dotslash_len;
+  if (*base)
+    {
+      length = base_len (base);
+
+      /* Collapse a sequence of trailing slashes into one.  */
+      length += ISSLASH (base[length]);
+
+      /* On systems with drive letters, "a/b:c" must return "./b:c" rather
+         than "b:c" to avoid confusion with a drive letter.  On systems
+         with pure POSIX semantics, this is not an issue.  */
+      dotslash_len = FILE_SYSTEM_PREFIX_LEN (base) != 0 ? 2 : 0;
+    }
+  else
+    {
+      /* There is no last component, so NAME is a file system root or
+         the empty string.  */
+      base = name;
+      length = base_len (base);
+      dotslash_len = 0;
+    }
+
+  char *p = ximalloc (dotslash_len + length + 1);
+  if (dotslash_len)
+    {
+      p[0] = '.';
+      p[1] = DIR_SEPARATOR;
+    }
+
+  /* Finally, copy the basename.  */
+  memcpy (p + dotslash_len, base, length);
+  p[dotslash_len + length] = '\0';
+  return p;
+}
diff --git a/lib/canonicalize-lgpl.c b/lib/canonicalize-lgpl.c
index e701297d84..572afdcaef 100644
--- a/lib/canonicalize-lgpl.c
+++ b/lib/canonicalize-lgpl.c
@@ -1,469 +1,469 @@
-/* Return the canonical absolute name of a given file.
-   Copyright (C) 1996-2023 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#ifndef _LIBC
-/* Don't use __attribute__ __nonnull__ in this compilation unit.  Otherwise gcc
-   optimizes away the name == NULL test below.  */
-# define _GL_ARG_NONNULL(params)
-
-# include <libc-config.h>
-#endif
-
-/* Specification.  */
-#include <stdlib.h>
-
-#include <errno.h>
-#include <fcntl.h>
-#include <limits.h>
-#include <string.h>
-#include <sys/stat.h>
-#include <unistd.h>
-
-#include <eloop-threshold.h>
-#include <filename.h>
-#include <idx.h>
-#include <intprops.h>
-#include <scratch_buffer.h>
-
-#ifdef _LIBC
-# include <shlib-compat.h>
-# define GCC_LINT 1
-# define _GL_ATTRIBUTE_PURE __attribute__ ((__pure__))
-#else
-# define __canonicalize_file_name canonicalize_file_name
-# define __realpath realpath
-# define __strdup strdup
-# include "pathmax.h"
-# define __faccessat faccessat
-# if defined _WIN32 && !defined __CYGWIN__
-#  define __getcwd _getcwd
-# elif HAVE_GETCWD
-#  if IN_RELOCWRAPPER
-    /* When building the relocatable program wrapper, use the system's getcwd
-       function, not the gnulib override, otherwise we would get a link error.
-     */
-#   undef getcwd
-#  endif
-#  if defined VMS && !defined getcwd
-    /* We want the directory in Unix syntax, not in VMS syntax.
-       The gnulib override of 'getcwd' takes 2 arguments; the original VMS
-       'getcwd' takes 3 arguments.  */
-#   define __getcwd(buf, max) getcwd (buf, max, 0)
-#  else
-#   define __getcwd getcwd
-#  endif
-# else
-#  define __getcwd(buf, max) getwd (buf)
-# endif
-# define __mempcpy mempcpy
-# define __pathconf pathconf
-# define __rawmemchr rawmemchr
-# define __readlink readlink
-# if IN_RELOCWRAPPER
-    /* When building the relocatable program wrapper, use the system's memmove
-       function, not the gnulib override, otherwise we would get a link error.
-     */
-#  undef memmove
-# endif
-#endif
-
-/* Suppress bogus GCC -Wmaybe-uninitialized warnings.  */
-#if defined GCC_LINT || defined lint
-# define IF_LINT(Code) Code
-#else
-# define IF_LINT(Code) /* empty */
-#endif
-
-#ifndef DOUBLE_SLASH_IS_DISTINCT_ROOT
-# define DOUBLE_SLASH_IS_DISTINCT_ROOT false
-#endif
-
-#if defined _LIBC || !FUNC_REALPATH_WORKS
-
-/* Return true if FILE's existence can be shown, false (setting errno)
-   otherwise.  Follow symbolic links.  */
-static bool
-file_accessible (char const *file)
-{
-# if defined _LIBC || HAVE_FACCESSAT
-  return __faccessat (AT_FDCWD, file, F_OK, AT_EACCESS) == 0;
-# else
-  struct stat st;
-  return stat (file, &st) == 0 || errno == EOVERFLOW;
-# endif
-}
-
-/* True if concatenating END as a suffix to a file name means that the
-   code needs to check that the file name is that of a searchable
-   directory, since the canonicalize_filename_mode_stk code won't
-   check this later anyway when it checks an ordinary file name
-   component within END.  END must either be empty, or start with a
-   slash.  */
-
-static bool _GL_ATTRIBUTE_PURE
-suffix_requires_dir_check (char const *end)
-{
-  /* If END does not start with a slash, the suffix is OK.  */
-  while (ISSLASH (*end))
-    {
-      /* Two or more slashes act like a single slash.  */
-      do
-        end++;
-      while (ISSLASH (*end));
-
-      switch (*end++)
-        {
-        default: return false;  /* An ordinary file name component is OK.  */
-        case '\0': return true; /* Trailing "/" is trouble.  */
-        case '.': break;        /* Possibly "." or "..".  */
-        }
-      /* Trailing "/.", or "/.." even if not trailing, is trouble.  */
-      if (!*end || (*end == '.' && (!end[1] || ISSLASH (end[1]))))
-        return true;
-    }
-
-  return false;
-}
-
-/* Append this to a file name to test whether it is a searchable directory.
-   On POSIX platforms "/" suffices, but "/./" is sometimes needed on
-   macOS 10.13 <https://bugs.gnu.org/30350>, and should also work on
-   platforms like AIX 7.2 that need at least "/.".  */
-
-# if defined _LIBC || defined LSTAT_FOLLOWS_SLASHED_SYMLINK
-static char const dir_suffix[] = "/";
-# else
-static char const dir_suffix[] = "/./";
-# endif
-
-/* Return true if DIR is a searchable dir, false (setting errno) otherwise.
-   DIREND points to the NUL byte at the end of the DIR string.
-   Store garbage into DIREND[0 .. strlen (dir_suffix)].  */
-
-static bool
-dir_check (char *dir, char *dirend)
-{
-  strcpy (dirend, dir_suffix);
-  return file_accessible (dir);
-}
-
-static idx_t
-get_path_max (void)
-{
-# ifdef PATH_MAX
-  long int path_max = PATH_MAX;
-# else
-  /* The caller invoked realpath with a null RESOLVED, even though
-     PATH_MAX is not defined as a constant.  The glibc manual says
-     programs should not do this, and POSIX says the behavior is undefined.
-     Historically, glibc here used the result of pathconf, or 1024 if that
-     failed; stay consistent with this (dubious) historical practice.  */
-  int err = errno;
-  long int path_max = __pathconf ("/", _PC_PATH_MAX);
-  __set_errno (err);
-# endif
-  return path_max < 0 ? 1024 : path_max <= IDX_MAX ? path_max : IDX_MAX;
-}
-
-/* Scratch buffers used by realpath_stk and managed by __realpath.  */
-struct realpath_bufs
-{
-  struct scratch_buffer rname;
-  struct scratch_buffer extra;
-  struct scratch_buffer link;
-};
-
-static char *
-realpath_stk (const char *name, char *resolved, struct realpath_bufs *bufs)
-{
-  char *dest;
-  char const *start;
-  char const *end;
-  int num_links = 0;
-
-  if (name == NULL)
-    {
-      /* As per Single Unix Specification V2 we must return an error if
-         either parameter is a null pointer.  We extend this to allow
-         the RESOLVED parameter to be NULL in case the we are expected to
-         allocate the room for the return value.  */
-      __set_errno (EINVAL);
-      return NULL;
-    }
-
-  if (name[0] == '\0')
-    {
-      /* As per Single Unix Specification V2 we must return an error if
-         the name argument points to an empty string.  */
-      __set_errno (ENOENT);
-      return NULL;
-    }
-
-  char *rname = bufs->rname.data;
-  bool end_in_extra_buffer = false;
-  bool failed = true;
-
-  /* This is always zero for Posix hosts, but can be 2 for MS-Windows
-     and MS-DOS X:/foo/bar file names.  */
-  idx_t prefix_len = FILE_SYSTEM_PREFIX_LEN (name);
-
-  if (!IS_ABSOLUTE_FILE_NAME (name))
-    {
-      while (!__getcwd (bufs->rname.data, bufs->rname.length))
-        {
-          if (errno != ERANGE)
-            {
-              dest = rname;
-              goto error;
-            }
-          if (!scratch_buffer_grow (&bufs->rname))
-            return NULL;
-          rname = bufs->rname.data;
-        }
-      dest = __rawmemchr (rname, '\0');
-      start = name;
-      prefix_len = FILE_SYSTEM_PREFIX_LEN (rname);
-    }
-  else
-    {
-      dest = __mempcpy (rname, name, prefix_len);
-      *dest++ = '/';
-      if (DOUBLE_SLASH_IS_DISTINCT_ROOT)
-        {
-          if (prefix_len == 0 /* implies ISSLASH (name[0]) */
-              && ISSLASH (name[1]) && !ISSLASH (name[2]))
-            *dest++ = '/';
-          *dest = '\0';
-        }
-      start = name + prefix_len;
-    }
-
-  for ( ; *start; start = end)
-    {
-      /* Skip sequence of multiple file name separators.  */
-      while (ISSLASH (*start))
-        ++start;
-
-      /* Find end of component.  */
-      for (end = start; *end && !ISSLASH (*end); ++end)
-        /* Nothing.  */;
-
-      /* Length of this file name component; it can be zero if a file
-         name ends in '/'.  */
-      idx_t startlen = end - start;
-
-      if (startlen == 0)
-        break;
-      else if (startlen == 1 && start[0] == '.')
-        /* nothing */;
-      else if (startlen == 2 && start[0] == '.' && start[1] == '.')
-        {
-          /* Back up to previous component, ignore if at root already.  */
-          if (dest > rname + prefix_len + 1)
-            for (--dest; dest > rname && !ISSLASH (dest[-1]); --dest)
-              continue;
-          if (DOUBLE_SLASH_IS_DISTINCT_ROOT
-              && dest == rname + 1 && !prefix_len
-              && ISSLASH (*dest) && !ISSLASH (dest[1]))
-            dest++;
-        }
-      else
-        {
-          if (!ISSLASH (dest[-1]))
-            *dest++ = '/';
-
-          while (rname + bufs->rname.length - dest
-                 < startlen + sizeof dir_suffix)
-            {
-              idx_t dest_offset = dest - rname;
-              if (!scratch_buffer_grow_preserve (&bufs->rname))
-                return NULL;
-              rname = bufs->rname.data;
-              dest = rname + dest_offset;
-            }
-
-          dest = __mempcpy (dest, start, startlen);
-          *dest = '\0';
-
-          char *buf;
-          ssize_t n;
-          while (true)
-            {
-              buf = bufs->link.data;
-              idx_t bufsize = bufs->link.length;
-              n = __readlink (rname, buf, bufsize - 1);
-              if (n < bufsize - 1)
-                break;
-              if (!scratch_buffer_grow (&bufs->link))
-                return NULL;
-            }
-          if (0 <= n)
-            {
-              if (++num_links > __eloop_threshold ())
-                {
-                  __set_errno (ELOOP);
-                  goto error;
-                }
-
-              buf[n] = '\0';
-
-              char *extra_buf = bufs->extra.data;
-              idx_t end_idx IF_LINT (= 0);
-              if (end_in_extra_buffer)
-                end_idx = end - extra_buf;
-              size_t len = strlen (end);
-              if (INT_ADD_OVERFLOW (len, n))
-                {
-                  __set_errno (ENOMEM);
-                  return NULL;
-                }
-              while (bufs->extra.length <= len + n)
-                {
-                  if (!scratch_buffer_grow_preserve (&bufs->extra))
-                    return NULL;
-                  extra_buf = bufs->extra.data;
-                }
-              if (end_in_extra_buffer)
-                end = extra_buf + end_idx;
-
-              /* Careful here, end may be a pointer into extra_buf... */
-              memmove (&extra_buf[n], end, len + 1);
-              name = end = memcpy (extra_buf, buf, n);
-              end_in_extra_buffer = true;
-
-              if (IS_ABSOLUTE_FILE_NAME (buf))
-                {
-                  idx_t pfxlen = FILE_SYSTEM_PREFIX_LEN (buf);
-
-                  dest = __mempcpy (rname, buf, pfxlen);
-                  *dest++ = '/'; /* It's an absolute symlink */
-                  if (DOUBLE_SLASH_IS_DISTINCT_ROOT)
-                    {
-                      if (ISSLASH (buf[1]) && !ISSLASH (buf[2]) && !pfxlen)
-                        *dest++ = '/';
-                      *dest = '\0';
-                    }
-                  /* Install the new prefix to be in effect hereafter.  */
-                  prefix_len = pfxlen;
-                }
-              else
-                {
-                  /* Back up to previous component, ignore if at root
-                     already: */
-                  if (dest > rname + prefix_len + 1)
-                    for (--dest; dest > rname && !ISSLASH (dest[-1]); --dest)
-                      continue;
-                  if (DOUBLE_SLASH_IS_DISTINCT_ROOT && dest == rname + 1
-                      && ISSLASH (*dest) && !ISSLASH (dest[1]) && !prefix_len)
-                    dest++;
-                }
-            }
-          else if (! (suffix_requires_dir_check (end)
-                      ? dir_check (rname, dest)
-                      : errno == EINVAL))
-            goto error;
-        }
-    }
-  if (dest > rname + prefix_len + 1 && ISSLASH (dest[-1]))
-    --dest;
-  if (DOUBLE_SLASH_IS_DISTINCT_ROOT && dest == rname + 1 && !prefix_len
-      && ISSLASH (*dest) && !ISSLASH (dest[1]))
-    dest++;
-  failed = false;
-
-error:
-  *dest++ = '\0';
-  if (resolved != NULL)
-    {
-      /* Copy the full result on success or partial result if failure was due
-         to the path not existing or not being accessible.  */
-      if ((!failed || errno == ENOENT || errno == EACCES)
-          && dest - rname <= get_path_max ())
-        {
-          strcpy (resolved, rname);
-          if (failed)
-            return NULL;
-          else
-            return resolved;
-        }
-      if (!failed)
-        __set_errno (ENAMETOOLONG);
-      return NULL;
-    }
-  else
-    {
-      if (failed)
-        return NULL;
-      else
-        return __strdup (bufs->rname.data);
-    }
-}
-
-/* Return the canonical absolute name of file NAME.  A canonical name
-   does not contain any ".", ".." components nor any repeated file name
-   separators ('/') or symlinks.  All file name components must exist.  If
-   RESOLVED is null, the result is malloc'd; otherwise, if the
-   canonical name is PATH_MAX chars or more, returns null with 'errno'
-   set to ENAMETOOLONG; if the name fits in fewer than PATH_MAX chars,
-   returns the name in RESOLVED.  If the name cannot be resolved and
-   RESOLVED is non-NULL, it contains the name of the first component
-   that cannot be resolved.  If the name can be resolved, RESOLVED
-   holds the same value as the value returned.  */
-
-char *
-__realpath (const char *name, char *resolved)
-{
-  struct realpath_bufs bufs;
-  scratch_buffer_init (&bufs.rname);
-  scratch_buffer_init (&bufs.extra);
-  scratch_buffer_init (&bufs.link);
-  char *result = realpath_stk (name, resolved, &bufs);
-  scratch_buffer_free (&bufs.link);
-  scratch_buffer_free (&bufs.extra);
-  scratch_buffer_free (&bufs.rname);
-  return result;
-}
-libc_hidden_def (__realpath)
-versioned_symbol (libc, __realpath, realpath, GLIBC_2_3);
-
-#endif /* defined _LIBC || !FUNC_REALPATH_WORKS */
-
-
-#if SHLIB_COMPAT(libc, GLIBC_2_0, GLIBC_2_3)
-char *
-attribute_compat_text_section
-__old_realpath (const char *name, char *resolved)
-{
-  if (resolved == NULL)
-    {
-      __set_errno (EINVAL);
-      return NULL;
-    }
-
-  return __realpath (name, resolved);
-}
-compat_symbol (libc, __old_realpath, realpath, GLIBC_2_0);
-#endif
-
-
-char *
-__canonicalize_file_name (const char *name)
-{
-  return __realpath (name, NULL);
-}
-weak_alias (__canonicalize_file_name, canonicalize_file_name)
+/* Return the canonical absolute name of a given file.
+   Copyright (C) 1996-2023 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _LIBC
+/* Don't use __attribute__ __nonnull__ in this compilation unit.  Otherwise gcc
+   optimizes away the name == NULL test below.  */
+# define _GL_ARG_NONNULL(params)
+
+# include <libc-config.h>
+#endif
+
+/* Specification.  */
+#include <stdlib.h>
+
+#include <errno.h>
+#include <fcntl.h>
+#include <limits.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+#include <eloop-threshold.h>
+#include <filename.h>
+#include <idx.h>
+#include <intprops.h>
+#include <scratch_buffer.h>
+
+#ifdef _LIBC
+# include <shlib-compat.h>
+# define GCC_LINT 1
+# define _GL_ATTRIBUTE_PURE __attribute__ ((__pure__))
+#else
+# define __canonicalize_file_name canonicalize_file_name
+# define __realpath realpath
+# define __strdup strdup
+# include "pathmax.h"
+# define __faccessat faccessat
+# if defined _WIN32 && !defined __CYGWIN__
+#  define __getcwd _getcwd
+# elif HAVE_GETCWD
+#  if IN_RELOCWRAPPER
+    /* When building the relocatable program wrapper, use the system's getcwd
+       function, not the gnulib override, otherwise we would get a link error.
+     */
+#   undef getcwd
+#  endif
+#  if defined VMS && !defined getcwd
+    /* We want the directory in Unix syntax, not in VMS syntax.
+       The gnulib override of 'getcwd' takes 2 arguments; the original VMS
+       'getcwd' takes 3 arguments.  */
+#   define __getcwd(buf, max) getcwd (buf, max, 0)
+#  else
+#   define __getcwd getcwd
+#  endif
+# else
+#  define __getcwd(buf, max) getwd (buf)
+# endif
+# define __mempcpy mempcpy
+# define __pathconf pathconf
+# define __rawmemchr rawmemchr
+# define __readlink readlink
+# if IN_RELOCWRAPPER
+    /* When building the relocatable program wrapper, use the system's memmove
+       function, not the gnulib override, otherwise we would get a link error.
+     */
+#  undef memmove
+# endif
+#endif
+
+/* Suppress bogus GCC -Wmaybe-uninitialized warnings.  */
+#if defined GCC_LINT || defined lint
+# define IF_LINT(Code) Code
+#else
+# define IF_LINT(Code) /* empty */
+#endif
+
+#ifndef DOUBLE_SLASH_IS_DISTINCT_ROOT
+# define DOUBLE_SLASH_IS_DISTINCT_ROOT false
+#endif
+
+#if defined _LIBC || !FUNC_REALPATH_WORKS
+
+/* Return true if FILE's existence can be shown, false (setting errno)
+   otherwise.  Follow symbolic links.  */
+static bool
+file_accessible (char const *file)
+{
+# if defined _LIBC || HAVE_FACCESSAT
+  return __faccessat (AT_FDCWD, file, F_OK, AT_EACCESS) == 0;
+# else
+  struct stat st;
+  return stat (file, &st) == 0 || errno == EOVERFLOW;
+# endif
+}
+
+/* True if concatenating END as a suffix to a file name means that the
+   code needs to check that the file name is that of a searchable
+   directory, since the canonicalize_filename_mode_stk code won't
+   check this later anyway when it checks an ordinary file name
+   component within END.  END must either be empty, or start with a
+   slash.  */
+
+static bool _GL_ATTRIBUTE_PURE
+suffix_requires_dir_check (char const *end)
+{
+  /* If END does not start with a slash, the suffix is OK.  */
+  while (ISSLASH (*end))
+    {
+      /* Two or more slashes act like a single slash.  */
+      do
+        end++;
+      while (ISSLASH (*end));
+
+      switch (*end++)
+        {
+        default: return false;  /* An ordinary file name component is OK.  */
+        case '\0': return true; /* Trailing "/" is trouble.  */
+        case '.': break;        /* Possibly "." or "..".  */
+        }
+      /* Trailing "/.", or "/.." even if not trailing, is trouble.  */
+      if (!*end || (*end == '.' && (!end[1] || ISSLASH (end[1]))))
+        return true;
+    }
+
+  return false;
+}
+
+/* Append this to a file name to test whether it is a searchable directory.
+   On POSIX platforms "/" suffices, but "/./" is sometimes needed on
+   macOS 10.13 <https://bugs.gnu.org/30350>, and should also work on
+   platforms like AIX 7.2 that need at least "/.".  */
+
+# if defined _LIBC || defined LSTAT_FOLLOWS_SLASHED_SYMLINK
+static char const dir_suffix[] = "/";
+# else
+static char const dir_suffix[] = "/./";
+# endif
+
+/* Return true if DIR is a searchable dir, false (setting errno) otherwise.
+   DIREND points to the NUL byte at the end of the DIR string.
+   Store garbage into DIREND[0 .. strlen (dir_suffix)].  */
+
+static bool
+dir_check (char *dir, char *dirend)
+{
+  strcpy (dirend, dir_suffix);
+  return file_accessible (dir);
+}
+
+static idx_t
+get_path_max (void)
+{
+# ifdef PATH_MAX
+  long int path_max = PATH_MAX;
+# else
+  /* The caller invoked realpath with a null RESOLVED, even though
+     PATH_MAX is not defined as a constant.  The glibc manual says
+     programs should not do this, and POSIX says the behavior is undefined.
+     Historically, glibc here used the result of pathconf, or 1024 if that
+     failed; stay consistent with this (dubious) historical practice.  */
+  int err = errno;
+  long int path_max = __pathconf ("/", _PC_PATH_MAX);
+  __set_errno (err);
+# endif
+  return path_max < 0 ? 1024 : path_max <= IDX_MAX ? path_max : IDX_MAX;
+}
+
+/* Scratch buffers used by realpath_stk and managed by __realpath.  */
+struct realpath_bufs
+{
+  struct scratch_buffer rname;
+  struct scratch_buffer extra;
+  struct scratch_buffer link;
+};
+
+static char *
+realpath_stk (const char *name, char *resolved, struct realpath_bufs *bufs)
+{
+  char *dest;
+  char const *start;
+  char const *end;
+  int num_links = 0;
+
+  if (name == NULL)
+    {
+      /* As per Single Unix Specification V2 we must return an error if
+         either parameter is a null pointer.  We extend this to allow
+         the RESOLVED parameter to be NULL in case the we are expected to
+         allocate the room for the return value.  */
+      __set_errno (EINVAL);
+      return NULL;
+    }
+
+  if (name[0] == '\0')
+    {
+      /* As per Single Unix Specification V2 we must return an error if
+         the name argument points to an empty string.  */
+      __set_errno (ENOENT);
+      return NULL;
+    }
+
+  char *rname = bufs->rname.data;
+  bool end_in_extra_buffer = false;
+  bool failed = true;
+
+  /* This is always zero for Posix hosts, but can be 2 for MS-Windows
+     and MS-DOS X:/foo/bar file names.  */
+  idx_t prefix_len = FILE_SYSTEM_PREFIX_LEN (name);
+
+  if (!IS_ABSOLUTE_FILE_NAME (name))
+    {
+      while (!__getcwd (bufs->rname.data, bufs->rname.length))
+        {
+          if (errno != ERANGE)
+            {
+              dest = rname;
+              goto error;
+            }
+          if (!scratch_buffer_grow (&bufs->rname))
+            return NULL;
+          rname = bufs->rname.data;
+        }
+      dest = __rawmemchr (rname, '\0');
+      start = name;
+      prefix_len = FILE_SYSTEM_PREFIX_LEN (rname);
+    }
+  else
+    {
+      dest = __mempcpy (rname, name, prefix_len);
+      *dest++ = DIR_SEPARATOR;
+      if (DOUBLE_SLASH_IS_DISTINCT_ROOT)
+        {
+          if (prefix_len == 0 /* implies ISSLASH (name[0]) */
+              && ISSLASH (name[1]) && !ISSLASH (name[2]))
+            *dest++ = DIR_SEPARATOR;
+          *dest = '\0';
+        }
+      start = name + prefix_len;
+    }
+
+  for ( ; *start; start = end)
+    {
+      /* Skip sequence of multiple file name separators.  */
+      while (ISSLASH (*start))
+        ++start;
+
+      /* Find end of component.  */
+      for (end = start; *end && !ISSLASH (*end); ++end)
+        /* Nothing.  */;
+
+      /* Length of this file name component; it can be zero if a file
+         name ends in '/'.  */
+      idx_t startlen = end - start;
+
+      if (startlen == 0)
+        break;
+      else if (startlen == 1 && start[0] == '.')
+        /* nothing */;
+      else if (startlen == 2 && start[0] == '.' && start[1] == '.')
+        {
+          /* Back up to previous component, ignore if at root already.  */
+          if (dest > rname + prefix_len + 1)
+            for (--dest; dest > rname && !ISSLASH (dest[-1]); --dest)
+              continue;
+          if (DOUBLE_SLASH_IS_DISTINCT_ROOT
+              && dest == rname + 1 && !prefix_len
+              && ISSLASH (*dest) && !ISSLASH (dest[1]))
+            dest++;
+        }
+      else
+        {
+          if (!ISSLASH (dest[-1]))
+            *dest++ = DIR_SEPARATOR;
+
+          while (rname + bufs->rname.length - dest
+                 < startlen + sizeof dir_suffix)
+            {
+              idx_t dest_offset = dest - rname;
+              if (!scratch_buffer_grow_preserve (&bufs->rname))
+                return NULL;
+              rname = bufs->rname.data;
+              dest = rname + dest_offset;
+            }
+
+          dest = __mempcpy (dest, start, startlen);
+          *dest = '\0';
+
+          char *buf;
+          ssize_t n;
+          while (true)
+            {
+              buf = bufs->link.data;
+              idx_t bufsize = bufs->link.length;
+              n = __readlink (rname, buf, bufsize - 1);
+              if (n < bufsize - 1)
+                break;
+              if (!scratch_buffer_grow (&bufs->link))
+                return NULL;
+            }
+          if (0 <= n)
+            {
+              if (++num_links > __eloop_threshold ())
+                {
+                  __set_errno (ELOOP);
+                  goto error;
+                }
+
+              buf[n] = '\0';
+
+              char *extra_buf = bufs->extra.data;
+              idx_t end_idx IF_LINT (= 0);
+              if (end_in_extra_buffer)
+                end_idx = end - extra_buf;
+              size_t len = strlen (end);
+              if (INT_ADD_OVERFLOW (len, n))
+                {
+                  __set_errno (ENOMEM);
+                  return NULL;
+                }
+              while (bufs->extra.length <= len + n)
+                {
+                  if (!scratch_buffer_grow_preserve (&bufs->extra))
+                    return NULL;
+                  extra_buf = bufs->extra.data;
+                }
+              if (end_in_extra_buffer)
+                end = extra_buf + end_idx;
+
+              /* Careful here, end may be a pointer into extra_buf... */
+              memmove (&extra_buf[n], end, len + 1);
+              name = end = memcpy (extra_buf, buf, n);
+              end_in_extra_buffer = true;
+
+              if (IS_ABSOLUTE_FILE_NAME (buf))
+                {
+                  idx_t pfxlen = FILE_SYSTEM_PREFIX_LEN (buf);
+
+                  dest = __mempcpy (rname, buf, pfxlen);
+                  *dest++ = DIR_SEPARATOR; /* It's an absolute symlink */
+                  if (DOUBLE_SLASH_IS_DISTINCT_ROOT)
+                    {
+                      if (ISSLASH (buf[1]) && !ISSLASH (buf[2]) && !pfxlen)
+                        *dest++ = DIR_SEPARATOR;
+                      *dest = '\0';
+                    }
+                  /* Install the new prefix to be in effect hereafter.  */
+                  prefix_len = pfxlen;
+                }
+              else
+                {
+                  /* Back up to previous component, ignore if at root
+                     already: */
+                  if (dest > rname + prefix_len + 1)
+                    for (--dest; dest > rname && !ISSLASH (dest[-1]); --dest)
+                      continue;
+                  if (DOUBLE_SLASH_IS_DISTINCT_ROOT && dest == rname + 1
+                      && ISSLASH (*dest) && !ISSLASH (dest[1]) && !prefix_len)
+                    dest++;
+                }
+            }
+          else if (! (suffix_requires_dir_check (end)
+                      ? dir_check (rname, dest)
+                      : errno == EINVAL))
+            goto error;
+        }
+    }
+  if (dest > rname + prefix_len + 1 && ISSLASH (dest[-1]))
+    --dest;
+  if (DOUBLE_SLASH_IS_DISTINCT_ROOT && dest == rname + 1 && !prefix_len
+      && ISSLASH (*dest) && !ISSLASH (dest[1]))
+    dest++;
+  failed = false;
+
+error:
+  *dest++ = '\0';
+  if (resolved != NULL)
+    {
+      /* Copy the full result on success or partial result if failure was due
+         to the path not existing or not being accessible.  */
+      if ((!failed || errno == ENOENT || errno == EACCES)
+          && dest - rname <= get_path_max ())
+        {
+          strcpy (resolved, rname);
+          if (failed)
+            return NULL;
+          else
+            return resolved;
+        }
+      if (!failed)
+        __set_errno (ENAMETOOLONG);
+      return NULL;
+    }
+  else
+    {
+      if (failed)
+        return NULL;
+      else
+        return __strdup (bufs->rname.data);
+    }
+}
+
+/* Return the canonical absolute name of file NAME.  A canonical name
+   does not contain any ".", ".." components nor any repeated file name
+   separators ('/') or symlinks.  All file name components must exist.  If
+   RESOLVED is null, the result is malloc'd; otherwise, if the
+   canonical name is PATH_MAX chars or more, returns null with 'errno'
+   set to ENAMETOOLONG; if the name fits in fewer than PATH_MAX chars,
+   returns the name in RESOLVED.  If the name cannot be resolved and
+   RESOLVED is non-NULL, it contains the name of the first component
+   that cannot be resolved.  If the name can be resolved, RESOLVED
+   holds the same value as the value returned.  */
+
+char *
+__realpath (const char *name, char *resolved)
+{
+  struct realpath_bufs bufs;
+  scratch_buffer_init (&bufs.rname);
+  scratch_buffer_init (&bufs.extra);
+  scratch_buffer_init (&bufs.link);
+  char *result = realpath_stk (name, resolved, &bufs);
+  scratch_buffer_free (&bufs.link);
+  scratch_buffer_free (&bufs.extra);
+  scratch_buffer_free (&bufs.rname);
+  return result;
+}
+libc_hidden_def (__realpath)
+versioned_symbol (libc, __realpath, realpath, GLIBC_2_3);
+
+#endif /* defined _LIBC || !FUNC_REALPATH_WORKS */
+
+
+#if SHLIB_COMPAT(libc, GLIBC_2_0, GLIBC_2_3)
+char *
+attribute_compat_text_section
+__old_realpath (const char *name, char *resolved)
+{
+  if (resolved == NULL)
+    {
+      __set_errno (EINVAL);
+      return NULL;
+    }
+
+  return __realpath (name, resolved);
+}
+compat_symbol (libc, __old_realpath, realpath, GLIBC_2_0);
+#endif
+
+
+char *
+__canonicalize_file_name (const char *name)
+{
+  return __realpath (name, NULL);
+}
+weak_alias (__canonicalize_file_name, canonicalize_file_name)
diff --git a/lib/canonicalize.c b/lib/canonicalize.c
index d73ee2c894..813879c44d 100644
--- a/lib/canonicalize.c
+++ b/lib/canonicalize.c
@@ -1,469 +1,464 @@
-/* Return the canonical absolute name of a given file.
-   Copyright (C) 1996-2023 Free Software Foundation, Inc.
-
-   This program is free software: you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation, either version 3 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
-
-#include <config.h>
-
-#include "canonicalize.h"
-
-#include <errno.h>
-#include <fcntl.h>
-#include <string.h>
-#include <sys/stat.h>
-#include <unistd.h>
-
-#include <filename.h>
-#include <idx.h>
-#include <intprops.h>
-#include <scratch_buffer.h>
-
-#include "attribute.h"
-#include "file-set.h"
-#include "hash-triple.h"
-#include "xalloc.h"
-
-#ifndef DOUBLE_SLASH_IS_DISTINCT_ROOT
-# define DOUBLE_SLASH_IS_DISTINCT_ROOT false
-#endif
-
-#if ISSLASH ('\\')
-# define SLASHES "/\\"
-#else
-# define SLASHES "/"
-#endif
-
-/* Avoid false GCC warning "'end_idx' may be used uninitialized".  */
+/* Return the canonical absolute name of a given file.
+   Copyright (C) 1996-2023 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+#include <config.h>
+
+#include "canonicalize.h"
+
+#include <errno.h>
+#include <fcntl.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+#include <filename.h>
+#include <idx.h>
+#include <intprops.h>
+#include <scratch_buffer.h>
+
+#include "attribute.h"
+#include "file-set.h"
+#include "hash-triple.h"
+#include "xalloc.h"
+
+#ifndef DOUBLE_SLASH_IS_DISTINCT_ROOT
+# define DOUBLE_SLASH_IS_DISTINCT_ROOT false
+#endif
+
+
+
+/* Avoid false GCC warning "'end_idx' may be used uninitialized".  */
 #if __GNUC__ + (__GNUC_MINOR__ >= 7) > 4
 # pragma GCC diagnostic ignored "-Wmaybe-uninitialized"
 #endif
-
-/* Return true if FILE's existence can be shown, false (setting errno)
-   otherwise.  Follow symbolic links.  */
-static bool
-file_accessible (char const *file)
-{
-# if HAVE_FACCESSAT
-  return faccessat (AT_FDCWD, file, F_OK, AT_EACCESS) == 0;
-# else
-  struct stat st;
-  return stat (file, &st) == 0 || errno == EOVERFLOW;
-# endif
-}
-
-/* True if concatenating END as a suffix to a file name means that the
-   code needs to check that the file name is that of a searchable
-   directory, since the canonicalize_filename_mode_stk code won't
-   check this later anyway when it checks an ordinary file name
-   component within END.  END must either be empty, or start with a
-   slash.  */
-
-static bool _GL_ATTRIBUTE_PURE
-suffix_requires_dir_check (char const *end)
-{
-  /* If END does not start with a slash, the suffix is OK.  */
-  while (ISSLASH (*end))
-    {
-      /* Two or more slashes act like a single slash.  */
-      do
-        end++;
-      while (ISSLASH (*end));
-
-      switch (*end++)
-        {
-        default: return false;  /* An ordinary file name component is OK.  */
-        case '\0': return true; /* Trailing "/" is trouble.  */
-        case '.': break;        /* Possibly "." or "..".  */
-        }
-      /* Trailing "/.", or "/.." even if not trailing, is trouble.  */
-      if (!*end || (*end == '.' && (!end[1] || ISSLASH (end[1]))))
-        return true;
-    }
-
-  return false;
-}
-
-/* Append this to a file name to test whether it is a searchable directory.
-   On POSIX platforms "/" suffices, but "/./" is sometimes needed on
-   macOS 10.13 <https://bugs.gnu.org/30350>, and should also work on
-   platforms like AIX 7.2 that need at least "/.".  */
-
-#ifdef LSTAT_FOLLOWS_SLASHED_SYMLINK
-static char const dir_suffix[] = "/";
-#else
-static char const dir_suffix[] = "/./";
-#endif
-
-/* Return true if DIR is a searchable dir, false (setting errno) otherwise.
-   DIREND points to the NUL byte at the end of the DIR string.
-   Store garbage into DIREND[0 .. strlen (dir_suffix)].  */
-
-static bool
-dir_check (char *dir, char *dirend)
-{
-  strcpy (dirend, dir_suffix);
-  return file_accessible (dir);
-}
-
-#if !((HAVE_CANONICALIZE_FILE_NAME && FUNC_REALPATH_WORKS)      \
-      || GNULIB_CANONICALIZE_LGPL)
-/* Return the canonical absolute name of file NAME.  A canonical name
-   does not contain any ".", ".." components nor any repeated file name
-   separators ('/') or symlinks.  All components must exist.
-   The result is malloc'd.  */
-
-char *
-canonicalize_file_name (const char *name)
-{
-  return canonicalize_filename_mode (name, CAN_EXISTING);
-}
-#endif /* !HAVE_CANONICALIZE_FILE_NAME */
-
-static bool
-multiple_bits_set (canonicalize_mode_t i)
-{
-  return (i & (i - 1)) != 0;
-}
-
-/* Return true if we've already seen the triple, <FILENAME, dev, ino>.
-   If *HT is not initialized, initialize it.  */
-static bool
-seen_triple (Hash_table **ht, char const *filename, struct stat const *st)
-{
-  if (*ht == NULL)
-    {
-      idx_t initial_capacity = 7;
-      *ht = hash_initialize (initial_capacity,
-                            NULL,
-                            triple_hash,
-                            triple_compare_ino_str,
-                            triple_free);
-      if (*ht == NULL)
-        xalloc_die ();
-    }
-
-  if (seen_file (*ht, filename, st))
-    return true;
-
-  record_file (*ht, filename, st);
-  return false;
-}
-
-/* Scratch buffers used by canonicalize_filename_mode_stk and managed
-   by __realpath.  */
-struct realpath_bufs
-{
-  struct scratch_buffer rname;
-  struct scratch_buffer extra;
-  struct scratch_buffer link;
-};
-
-static char *
-canonicalize_filename_mode_stk (const char *name, canonicalize_mode_t can_mode,
-                                struct realpath_bufs *bufs)
-{
-  char *dest;
-  char const *start;
-  char const *end;
-  Hash_table *ht = NULL;
-  bool logical = (can_mode & CAN_NOLINKS) != 0;
-  int num_links = 0;
-
-  canonicalize_mode_t can_exist = can_mode & CAN_MODE_MASK;
-  if (multiple_bits_set (can_exist))
-    {
-      errno = EINVAL;
-      return NULL;
-    }
-
-  if (name == NULL)
-    {
-      errno = EINVAL;
-      return NULL;
-    }
-
-  if (name[0] == '\0')
-    {
-      errno = ENOENT;
-      return NULL;
-    }
-
-  char *rname = bufs->rname.data;
-  bool end_in_extra_buffer = false;
-  bool failed = true;
-
-  /* This is always zero for Posix hosts, but can be 2 for MS-Windows
-     and MS-DOS X:/foo/bar file names.  */
-  idx_t prefix_len = FILE_SYSTEM_PREFIX_LEN (name);
-
-  if (!IS_ABSOLUTE_FILE_NAME (name))
-    {
-      while (!getcwd (bufs->rname.data, bufs->rname.length))
-        {
-          switch (errno)
-            {
-            case ERANGE:
-              if (scratch_buffer_grow (&bufs->rname))
-                break;
-              FALLTHROUGH;
-            case ENOMEM:
-              xalloc_die ();
-
-            default:
-              dest = rname;
-              goto error;
-            }
-          rname = bufs->rname.data;
-        }
-      dest = rawmemchr (rname, '\0');
-      start = name;
-      prefix_len = FILE_SYSTEM_PREFIX_LEN (rname);
-    }
-  else
-    {
-      dest = mempcpy (rname, name, prefix_len);
-      *dest++ = '/';
-      if (DOUBLE_SLASH_IS_DISTINCT_ROOT)
-        {
-          if (prefix_len == 0 /* implies ISSLASH (name[0]) */
-              && ISSLASH (name[1]) && !ISSLASH (name[2]))
-            {
-              *dest++ = '/';
-#if defined _WIN32 && !defined __CYGWIN__
-              /* For UNC file names '\\server\path\to\file', extend the prefix
-                 to include the server: '\\server\'.  */
-              {
-                idx_t i;
-                for (i = 2; name[i] != '\0' && !ISSLASH (name[i]); )
-                  i++;
-                if (name[i] != '\0' /* implies ISSLASH (name[i]) */
-                    && i + 1 < bufs->rname.length)
-                  {
-                    prefix_len = i;
-                    memcpy (dest, name + 2, i - 2 + 1);
-                    dest += i - 2 + 1;
-                  }
-                else
-                  {
-                    /* Either name = '\\server'; this is an invalid file name.
-                       Or name = '\\server\...' and server is more than
-                       bufs->rname.length - 4 bytes long.  In either
-                       case, stop the UNC processing.  */
-                  }
-              }
-#endif
-            }
-          *dest = '\0';
-        }
-      start = name + prefix_len;
-    }
-
-  for ( ; *start; start = end)
-    {
-      /* Skip sequence of multiple file name separators.  */
-      while (ISSLASH (*start))
-        ++start;
-
-      /* Find end of component.  */
-      for (end = start; *end && !ISSLASH (*end); ++end)
-        /* Nothing.  */;
-
-      /* Length of this file name component; it can be zero if a file
-         name ends in '/'.  */
-      idx_t startlen = end - start;
-
-      if (startlen == 0)
-        break;
-      else if (startlen == 1 && start[0] == '.')
-        /* nothing */;
-      else if (startlen == 2 && start[0] == '.' && start[1] == '.')
-        {
-          /* Back up to previous component, ignore if at root already.  */
-          if (dest > rname + prefix_len + 1)
-            for (--dest; dest > rname && !ISSLASH (dest[-1]); --dest)
-              continue;
-          if (DOUBLE_SLASH_IS_DISTINCT_ROOT
-              && dest == rname + 1 && !prefix_len
-              && ISSLASH (*dest) && !ISSLASH (dest[1]))
-            dest++;
-        }
-      else
-        {
-          if (!ISSLASH (dest[-1]))
-            *dest++ = '/';
-
-          while (rname + bufs->rname.length - dest
-                 < startlen + sizeof dir_suffix)
-            {
-              idx_t dest_offset = dest - rname;
-              if (!scratch_buffer_grow_preserve (&bufs->rname))
-                xalloc_die ();
-              rname = bufs->rname.data;
-              dest = rname + dest_offset;
-            }
-
-          dest = mempcpy (dest, start, startlen);
-          *dest = '\0';
-
-          char *buf;
-          ssize_t n = -1;
-          if (!logical)
-            {
-              while (true)
-                {
-                  buf = bufs->link.data;
-                  idx_t bufsize = bufs->link.length;
-                  n = readlink (rname, buf, bufsize - 1);
-                  if (n < bufsize - 1)
-                    break;
-                  if (!scratch_buffer_grow (&bufs->link))
-                    xalloc_die ();
-                }
-            }
-          if (0 <= n)
-            {
-              /* A physical traversal and RNAME is a symbolic link.  */
-
-              if (num_links < 20)
-                num_links++;
-              else if (*start)
-                {
-                  /* Enough symlinks have been seen that it is time to
-                     worry about being in a symlink cycle.
-                     Get the device and inode of the parent directory, as
-                     pre-2017 POSIX says this info is not reliable for
-                     symlinks.  */
-                  struct stat st;
-                  dest[- startlen] = '\0';
-                  if (stat (*rname ? rname : ".", &st) != 0)
-                    goto error;
-                  dest[- startlen] = *start;
-
-                  /* Detect loops.  We cannot use the cycle-check module here,
-                     since it's possible to encounter the same parent
-                     directory more than once in a given traversal.  However,
-                     encountering the same (parentdir, START) pair twice does
-                     indicate a loop.  */
-                  if (seen_triple (&ht, start, &st))
-                    {
-                      if (can_exist == CAN_MISSING)
-                        continue;
-                      errno = ELOOP;
-                      goto error;
-                    }
-                }
-
-              buf[n] = '\0';
-
-              char *extra_buf = bufs->extra.data;
-              idx_t end_idx;
-              if (end_in_extra_buffer)
-                end_idx = end - extra_buf;
-              size_t len = strlen (end);
-              if (INT_ADD_OVERFLOW (len, n))
-                xalloc_die ();
-              while (bufs->extra.length <= len + n)
-                {
-                  if (!scratch_buffer_grow_preserve (&bufs->extra))
-                    xalloc_die ();
-                  extra_buf = bufs->extra.data;
-                }
-              if (end_in_extra_buffer)
-                end = extra_buf + end_idx;
-
-              /* Careful here, end may be a pointer into extra_buf... */
-              memmove (&extra_buf[n], end, len + 1);
-              name = end = memcpy (extra_buf, buf, n);
-              end_in_extra_buffer = true;
-
-              if (IS_ABSOLUTE_FILE_NAME (buf))
-                {
-                  idx_t pfxlen = FILE_SYSTEM_PREFIX_LEN (buf);
-
-                  dest = mempcpy (rname, buf, pfxlen);
-                  *dest++ = '/'; /* It's an absolute symlink */
-                  if (DOUBLE_SLASH_IS_DISTINCT_ROOT)
-                    {
-                      if (ISSLASH (buf[1]) && !ISSLASH (buf[2]) && !pfxlen)
-                        *dest++ = '/';
-                      *dest = '\0';
-                    }
-                  /* Install the new prefix to be in effect hereafter.  */
-                  prefix_len = pfxlen;
-                }
-              else
-                {
-                  /* Back up to previous component, ignore if at root
-                     already: */
-                  if (dest > rname + prefix_len + 1)
-                    for (--dest; dest > rname && !ISSLASH (dest[-1]); --dest)
-                      continue;
-                  if (DOUBLE_SLASH_IS_DISTINCT_ROOT && dest == rname + 1
-                      && ISSLASH (*dest) && !ISSLASH (dest[1]) && !prefix_len)
-                    dest++;
-                }
-            }
-          else if (! (can_exist == CAN_MISSING
-                      || (suffix_requires_dir_check (end)
-                          ? dir_check (rname, dest)
-                          : !logical
-                          ? errno == EINVAL
-                          : *end || file_accessible (rname))
-                      || (can_exist == CAN_ALL_BUT_LAST
-                          && errno == ENOENT
-                          && !end[strspn (end, SLASHES)])))
-            goto error;
-        }
-    }
-  if (dest > rname + prefix_len + 1 && ISSLASH (dest[-1]))
-    --dest;
-  if (DOUBLE_SLASH_IS_DISTINCT_ROOT && dest == rname + 1 && !prefix_len
-      && ISSLASH (*dest) && !ISSLASH (dest[1]))
-    dest++;
-  failed = false;
-
-error:
-  if (ht)
-    hash_free (ht);
-
-  if (failed)
-    return NULL;
-
-  *dest++ = '\0';
-  char *result = malloc (dest - rname);
-  if (!result)
-    xalloc_die ();
-  return memcpy (result, rname, dest - rname);
-}
-
-/* Return the canonical absolute name of file NAME, while treating
-   missing elements according to CAN_MODE.  A canonical name
-   does not contain any ".", ".." components nor any repeated file name
-   separators ('/') or, depending on other CAN_MODE flags, symlinks.
-   Whether components must exist or not depends on canonicalize mode.
-   The result is malloc'd.  */
-
-char *
-canonicalize_filename_mode (const char *name, canonicalize_mode_t can_mode)
-{
-  struct realpath_bufs bufs;
-  scratch_buffer_init (&bufs.rname);
-  scratch_buffer_init (&bufs.extra);
-  scratch_buffer_init (&bufs.link);
-  char *result = canonicalize_filename_mode_stk (name, can_mode, &bufs);
-  scratch_buffer_free (&bufs.link);
-  scratch_buffer_free (&bufs.extra);
-  scratch_buffer_free (&bufs.rname);
-  return result;
-}
+/* Return true if FILE's existence can be shown, false (setting errno)
+   otherwise.  Follow symbolic links.  */
+static bool
+file_accessible (char const *file)
+{
+# if HAVE_FACCESSAT
+  return faccessat (AT_FDCWD, file, F_OK, AT_EACCESS) == 0;
+# else
+  struct stat st;
+  return stat (file, &st) == 0 || errno == EOVERFLOW;
+# endif
+}
+
+/* True if concatenating END as a suffix to a file name means that the
+   code needs to check that the file name is that of a searchable
+   directory, since the canonicalize_filename_mode_stk code won't
+   check this later anyway when it checks an ordinary file name
+   component within END.  END must either be empty, or start with a
+   slash.  */
+
+static bool _GL_ATTRIBUTE_PURE
+suffix_requires_dir_check (char const *end)
+{
+  /* If END does not start with a slash, the suffix is OK.  */
+  while (ISSLASH (*end))
+    {
+      /* Two or more slashes act like a single slash.  */
+      do
+        end++;
+      while (ISSLASH (*end));
+
+      switch (*end++)
+        {
+        default: return false;  /* An ordinary file name component is OK.  */
+        case '\0': return true; /* Trailing "/" is trouble.  */
+        case '.': break;        /* Possibly "." or "..".  */
+        }
+      /* Trailing "/.", or "/.." even if not trailing, is trouble.  */
+      if (!*end || (*end == '.' && (!end[1] || ISSLASH (end[1]))))
+        return true;
+    }
+
+  return false;
+}
+
+/* Append this to a file name to test whether it is a searchable directory.
+   On POSIX platforms "/" suffices, but "/./" is sometimes needed on
+   macOS 10.13 <https://bugs.gnu.org/30350>, and should also work on
+   platforms like AIX 7.2 that need at least "/.".  */
+
+#ifdef LSTAT_FOLLOWS_SLASHED_SYMLINK
+static char const dir_suffix[] = "/";
+#else
+static char const dir_suffix[] = "/./";
+#endif
+
+/* Return true if DIR is a searchable dir, false (setting errno) otherwise.
+   DIREND points to the NUL byte at the end of the DIR string.
+   Store garbage into DIREND[0 .. strlen (dir_suffix)].  */
+
+static bool
+dir_check (char *dir, char *dirend)
+{
+  strcpy (dirend, dir_suffix);
+  return file_accessible (dir);
+}
+
+#if !((HAVE_CANONICALIZE_FILE_NAME && FUNC_REALPATH_WORKS)      \
+      || GNULIB_CANONICALIZE_LGPL)
+/* Return the canonical absolute name of file NAME.  A canonical name
+   does not contain any ".", ".." components nor any repeated file name
+   separators ('/') or symlinks.  All components must exist.
+   The result is malloc'd.  */
+
+char *
+canonicalize_file_name (const char *name)
+{
+  return canonicalize_filename_mode (name, CAN_EXISTING);
+}
+#endif /* !HAVE_CANONICALIZE_FILE_NAME */
+
+static bool
+multiple_bits_set (canonicalize_mode_t i)
+{
+  return (i & (i - 1)) != 0;
+}
+
+/* Return true if we've already seen the triple, <FILENAME, dev, ino>.
+   If *HT is not initialized, initialize it.  */
+static bool
+seen_triple (Hash_table **ht, char const *filename, struct stat const *st)
+{
+  if (*ht == NULL)
+    {
+      idx_t initial_capacity = 7;
+      *ht = hash_initialize (initial_capacity,
+                            NULL,
+                            triple_hash,
+                            triple_compare_ino_str,
+                            triple_free);
+      if (*ht == NULL)
+        xalloc_die ();
+    }
+
+  if (seen_file (*ht, filename, st))
+    return true;
+
+  record_file (*ht, filename, st);
+  return false;
+}
+
+/* Scratch buffers used by canonicalize_filename_mode_stk and managed
+   by __realpath.  */
+struct realpath_bufs
+{
+  struct scratch_buffer rname;
+  struct scratch_buffer extra;
+  struct scratch_buffer link;
+};
+
+static char *
+canonicalize_filename_mode_stk (const char *name, canonicalize_mode_t can_mode,
+                                struct realpath_bufs *bufs)
+{
+  char *dest;
+  char const *start;
+  char const *end;
+  Hash_table *ht = NULL;
+  bool logical = (can_mode & CAN_NOLINKS) != 0;
+  int num_links = 0;
+
+  canonicalize_mode_t can_exist = can_mode & CAN_MODE_MASK;
+  if (multiple_bits_set (can_exist))
+    {
+      errno = EINVAL;
+      return NULL;
+    }
+
+  if (name == NULL)
+    {
+      errno = EINVAL;
+      return NULL;
+    }
+
+  if (name[0] == '\0')
+    {
+      errno = ENOENT;
+      return NULL;
+    }
+
+  char *rname = bufs->rname.data;
+  bool end_in_extra_buffer = false;
+  bool failed = true;
+
+  /* This is always zero for Posix hosts, but can be 2 for MS-Windows
+     and MS-DOS X:/foo/bar file names.  */
+  idx_t prefix_len = FILE_SYSTEM_PREFIX_LEN (name);
+
+  if (!IS_ABSOLUTE_FILE_NAME (name))
+    {
+      while (!getcwd (bufs->rname.data, bufs->rname.length))
+        {
+          switch (errno)
+            {
+            case ERANGE:
+              if (scratch_buffer_grow (&bufs->rname))
+                break;
+              FALLTHROUGH;
+            case ENOMEM:
+              xalloc_die ();
+
+            default:
+              dest = rname;
+              goto error;
+            }
+          rname = bufs->rname.data;
+        }
+      dest = rawmemchr (rname, '\0');
+      start = name;
+      prefix_len = FILE_SYSTEM_PREFIX_LEN (rname);
+    }
+  else
+    {
+      dest = mempcpy (rname, name, prefix_len);
+      *dest++ = DIR_SEPARATOR;
+      if (DOUBLE_SLASH_IS_DISTINCT_ROOT)
+        {
+          if (prefix_len == 0 /* implies ISSLASH (name[0]) */
+              && ISSLASH (name[1]) && !ISSLASH (name[2]))
+            {
+              *dest++ = DIR_SEPARATOR;
+#if defined _WIN32 && !defined __CYGWIN__
+              /* For UNC file names '\\server\path\to\file', extend the prefix
+                 to include the server: '\\server\'.  */
+              {
+                idx_t i;
+                for (i = 2; name[i] != '\0' && !ISSLASH (name[i]); )
+                  i++;
+                if (name[i] != '\0' /* implies ISSLASH (name[i]) */
+                    && i + 1 < bufs->rname.length)
+                  {
+                    prefix_len = i;
+                    memcpy (dest, name + 2, i - 2 + 1);
+                    dest += i - 2 + 1;
+                  }
+                else
+                  {
+                    /* Either name = '\\server'; this is an invalid file name.
+                       Or name = '\\server\...' and server is more than
+                       bufs->rname.length - 4 bytes long.  In either
+                       case, stop the UNC processing.  */
+                  }
+              }
+#endif
+            }
+          *dest = '\0';
+        }
+      start = name + prefix_len;
+    }
+
+  for ( ; *start; start = end)
+    {
+      /* Skip sequence of multiple file name separators.  */
+      while (ISSLASH (*start))
+        ++start;
+
+      /* Find end of component.  */
+      for (end = start; *end && !ISSLASH (*end); ++end)
+        /* Nothing.  */;
+
+      /* Length of this file name component; it can be zero if a file
+         name ends in '/'.  */
+      idx_t startlen = end - start;
+
+      if (startlen == 0)
+        break;
+      else if (startlen == 1 && start[0] == '.')
+        /* nothing */;
+      else if (startlen == 2 && start[0] == '.' && start[1] == '.')
+        {
+          /* Back up to previous component, ignore if at root already.  */
+          if (dest > rname + prefix_len + 1)
+            for (--dest; dest > rname && !ISSLASH (dest[-1]); --dest)
+              continue;
+          if (DOUBLE_SLASH_IS_DISTINCT_ROOT
+              && dest == rname + 1 && !prefix_len
+              && ISSLASH (*dest) && !ISSLASH (dest[1]))
+            dest++;
+        }
+      else
+        {
+          if (!ISSLASH (dest[-1]))
+            *dest++ = DIR_SEPARATOR;
+
+          while (rname + bufs->rname.length - dest
+                 < startlen + sizeof dir_suffix)
+            {
+              idx_t dest_offset = dest - rname;
+              if (!scratch_buffer_grow_preserve (&bufs->rname))
+                xalloc_die ();
+              rname = bufs->rname.data;
+              dest = rname + dest_offset;
+            }
+
+          dest = mempcpy (dest, start, startlen);
+          *dest = '\0';
+
+          char *buf;
+          ssize_t n = -1;
+          if (!logical)
+            {
+              while (true)
+                {
+                  buf = bufs->link.data;
+                  idx_t bufsize = bufs->link.length;
+                  n = readlink (rname, buf, bufsize - 1);
+                  if (n < bufsize - 1)
+                    break;
+                  if (!scratch_buffer_grow (&bufs->link))
+                    xalloc_die ();
+                }
+            }
+          if (0 <= n)
+            {
+              /* A physical traversal and RNAME is a symbolic link.  */
+
+              if (num_links < 20)
+                num_links++;
+              else if (*start)
+                {
+                  /* Enough symlinks have been seen that it is time to
+                     worry about being in a symlink cycle.
+                     Get the device and inode of the parent directory, as
+                     pre-2017 POSIX says this info is not reliable for
+                     symlinks.  */
+                  struct stat st;
+                  dest[- startlen] = '\0';
+                  if (stat (*rname ? rname : ".", &st) != 0)
+                    goto error;
+                  dest[- startlen] = *start;
+
+                  /* Detect loops.  We cannot use the cycle-check module here,
+                     since it's possible to encounter the same parent
+                     directory more than once in a given traversal.  However,
+                     encountering the same (parentdir, START) pair twice does
+                     indicate a loop.  */
+                  if (seen_triple (&ht, start, &st))
+                    {
+                      if (can_exist == CAN_MISSING)
+                        continue;
+                      errno = ELOOP;
+                      goto error;
+                    }
+                }
+
+              buf[n] = '\0';
+
+              char *extra_buf = bufs->extra.data;
+              idx_t end_idx;
+              if (end_in_extra_buffer)
+                end_idx = end - extra_buf;
+              size_t len = strlen (end);
+              if (INT_ADD_OVERFLOW (len, n))
+                xalloc_die ();
+              while (bufs->extra.length <= len + n)
+                {
+                  if (!scratch_buffer_grow_preserve (&bufs->extra))
+                    xalloc_die ();
+                  extra_buf = bufs->extra.data;
+                }
+              if (end_in_extra_buffer)
+                end = extra_buf + end_idx;
+
+              /* Careful here, end may be a pointer into extra_buf... */
+              memmove (&extra_buf[n], end, len + 1);
+              name = end = memcpy (extra_buf, buf, n);
+              end_in_extra_buffer = true;
+
+              if (IS_ABSOLUTE_FILE_NAME (buf))
+                {
+                  idx_t pfxlen = FILE_SYSTEM_PREFIX_LEN (buf);
+
+                  dest = mempcpy (rname, buf, pfxlen);
+                  *dest++ = DIR_SEPARATOR; /* It's an absolute symlink */
+                  if (DOUBLE_SLASH_IS_DISTINCT_ROOT)
+                    {
+                      if (ISSLASH (buf[1]) && !ISSLASH (buf[2]) && !pfxlen)
+                        *dest++ = DIR_SEPARATOR;
+                      *dest = '\0';
+                    }
+                  /* Install the new prefix to be in effect hereafter.  */
+                  prefix_len = pfxlen;
+                }
+              else
+                {
+                  /* Back up to previous component, ignore if at root
+                     already: */
+                  if (dest > rname + prefix_len + 1)
+                    for (--dest; dest > rname && !ISSLASH (dest[-1]); --dest)
+                      continue;
+                  if (DOUBLE_SLASH_IS_DISTINCT_ROOT && dest == rname + 1
+                      && ISSLASH (*dest) && !ISSLASH (dest[1]) && !prefix_len)
+                    dest++;
+                }
+            }
+          else if (! (can_exist == CAN_MISSING
+                      || (suffix_requires_dir_check (end)
+                          ? dir_check (rname, dest)
+                          : !logical
+                          ? errno == EINVAL
+                          : *end || file_accessible (rname))
+                      || (can_exist == CAN_ALL_BUT_LAST
+                          && errno == ENOENT
+                          && !end[strspn (end, SLASHES)])))
+            goto error;
+        }
+    }
+  if (dest > rname + prefix_len + 1 && ISSLASH (dest[-1]))
+    --dest;
+  if (DOUBLE_SLASH_IS_DISTINCT_ROOT && dest == rname + 1 && !prefix_len
+      && ISSLASH (*dest) && !ISSLASH (dest[1]))
+    dest++;
+  failed = false;
+
+error:
+  if (ht)
+    hash_free (ht);
+
+  if (failed)
+    return NULL;
+
+  *dest++ = '\0';
+  char *result = malloc (dest - rname);
+  if (!result)
+    xalloc_die ();
+  return memcpy (result, rname, dest - rname);
+}
+
+/* Return the canonical absolute name of file NAME, while treating
+   missing elements according to CAN_MODE.  A canonical name
+   does not contain any ".", ".." components nor any repeated file name
+   separators ('/') or, depending on other CAN_MODE flags, symlinks.
+   Whether components must exist or not depends on canonicalize mode.
+   The result is malloc'd.  */
+
+char *
+canonicalize_filename_mode (const char *name, canonicalize_mode_t can_mode)
+{
+  struct realpath_bufs bufs;
+  scratch_buffer_init (&bufs.rname);
+  scratch_buffer_init (&bufs.extra);
+  scratch_buffer_init (&bufs.link);
+  char *result = canonicalize_filename_mode_stk (name, can_mode, &bufs);
+  scratch_buffer_free (&bufs.link);
+  scratch_buffer_free (&bufs.extra);
+  scratch_buffer_free (&bufs.rname);
+  return result;
+}
diff --git a/lib/chdir-long.c b/lib/chdir-long.c
index 8a25538b3f..eb32ff685c 100644
--- a/lib/chdir-long.c
+++ b/lib/chdir-long.c
@@ -25,7 +25,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <stdio.h>
-
+#include "filename.h"
 #include "assure.h"
 
 #ifndef PATH_MAX
@@ -126,7 +126,7 @@ chdir_long (char *dir)
     assure (PATH_MAX <= len);
 
     /* Count leading slashes.  */
-    n_leading_slash = strspn (dir, "/");
+    n_leading_slash = strspn (dir, SLASHES);
 
     /* Handle any leading slashes as well as any name that matches
        the regular expression, m!^//hostname[/]*! .  Handling this
@@ -139,6 +139,8 @@ chdir_long (char *dir)
         /* Find next slash.
            We already know that dir[2] is neither a slash nor '\0'.  */
         char *slash = memchr (dir + 3, '/', dir_end - (dir + 3));
+		if (slash == NULL && '/' != DIR_SEPARATOR)
+			slash = memchr(dir + 3, DIR_SEPARATOR, dir_end - (dir + 3));
         if (slash == NULL)
           {
             errno = ENAMETOOLONG;
@@ -146,7 +148,7 @@ chdir_long (char *dir)
           }
         *slash = '\0';
         err = cdb_advance_fd (&cdb, dir);
-        *slash = '/';
+        *slash = DIR_SEPARATOR;
         if (err != 0)
           goto Fail;
         dir = find_non_slash (slash + 1);
@@ -158,7 +160,7 @@ chdir_long (char *dir)
         dir += n_leading_slash;
       }
 
-    assure (*dir != '/');
+    assure (! ISSLASH(*dir) );
     assure (dir <= dir_end);
 
     while (PATH_MAX <= dir_end - dir)
@@ -168,6 +170,9 @@ chdir_long (char *dir)
            I.e. see if there is a slash that will give us a name of
            length PATH_MAX-1 or less.  */
         char *slash = memrchr (dir, '/', PATH_MAX);
+		if (slash == NULL && '/' != DIR_SEPARATOR)
+			slash = memrchr(dir, DIR_SEPARATOR, PATH_MAX);
+
         if (slash == NULL)
           {
             errno = ENAMETOOLONG;
@@ -177,7 +182,7 @@ chdir_long (char *dir)
         *slash = '\0';
         assure (slash - dir < PATH_MAX);
         err = cdb_advance_fd (&cdb, dir);
-        *slash = '/';
+        *slash = DIR_SEPARATOR;
         if (err != 0)
           goto Fail;
 
diff --git a/lib/chmod.c b/lib/chmod.c
index 40088c8a5b..50d3a9726c 100644
--- a/lib/chmod.c
+++ b/lib/chmod.c
@@ -22,6 +22,7 @@
 
 #include <errno.h>
 #include <string.h>
+#include "filename.h"
 
 int
 rpl_chmod (const char *filename, mode_t mode)
@@ -31,7 +32,7 @@ rpl_chmod (const char *filename, mode_t mode)
 #endif
 {
   size_t len = strlen (filename);
-  if (len > 0 && filename[len - 1] == '/')
+  if (len > 0 && ISSLASH(filename[len - 1]) )
     {
       struct stat st;
       if (lstat (filename, &st) < 0)
diff --git a/lib/chown.c b/lib/chown.c
index d735818afd..31c60e975f 100644
--- a/lib/chown.c
+++ b/lib/chown.c
@@ -27,6 +27,7 @@
 #include <fcntl.h>
 #include <string.h>
 #include <sys/stat.h>
+#include "filename.h"
 
 #if !HAVE_CHOWN
 
@@ -122,7 +123,7 @@ rpl_chown (const char *file, uid_t uid, gid_t gid)
   if (!stat_valid)
     {
       size_t len = strlen (file);
-      if (len && file[len - 1] == '/' && stat (file, &st))
+      if (len && ISSLASH(file[len - 1]) && stat (file, &st))
         return -1;
     }
 # endif
diff --git a/lib/concat-filename.c b/lib/concat-filename.c
index 62842a69cb..22dc871cb7 100644
--- a/lib/concat-filename.c
+++ b/lib/concat-filename.c
@@ -1,73 +1,73 @@
-/* Construct a full filename from a directory and a relative filename.
-   Copyright (C) 2001-2004, 2006-2023 Free Software Foundation, Inc.
-
-   This file is free software: you can redistribute it and/or modify
-   it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
-   License, or (at your option) any later version.
-
-   This file is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public License
-   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
-
-/* Written by Bruno Haible <haible@clisp.cons.org>.  */
-
-#include <config.h>
-
-/* Specification.  */
-#include "concat-filename.h"
-
-#include <errno.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include "filename.h"
-
-/* Concatenate a directory filename, a relative filename and an optional
-   suffix.  The directory may end with the directory separator.  The second
-   argument may not start with the directory separator (it is relative).
-   Return a freshly allocated filename.  Return NULL and set errno
-   upon memory allocation failure.  */
-char *
-concatenated_filename (const char *directory, const char *filename,
-                       const char *suffix)
-{
-  char *result;
-  char *p;
-
-  if (strcmp (directory, ".") == 0)
-    {
-      /* No need to prepend the directory.  */
-      result = (char *) malloc (strlen (filename)
-                                + (suffix != NULL ? strlen (suffix) : 0)
-                                + 1);
-      if (result == NULL)
-        return NULL; /* errno is set here */
-      p = result;
-    }
-  else
-    {
-      size_t directory_len = strlen (directory);
-      int need_slash =
-        (directory_len > FILE_SYSTEM_PREFIX_LEN (directory)
-         && !ISSLASH (directory[directory_len - 1]));
-      result = (char *) malloc (directory_len + need_slash
-                                + strlen (filename)
-                                + (suffix != NULL ? strlen (suffix) : 0)
-                                + 1);
-      if (result == NULL)
-        return NULL; /* errno is set here */
-      memcpy (result, directory, directory_len);
-      p = result + directory_len;
-      if (need_slash)
-        *p++ = '/';
-    }
-  p = stpcpy (p, filename);
-  if (suffix != NULL)
-    stpcpy (p, suffix);
-  return result;
-}
+/* Construct a full filename from a directory and a relative filename.
+   Copyright (C) 2001-2004, 2006-2023 Free Software Foundation, Inc.
+
+   This file is free software: you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   This file is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* Written by Bruno Haible <haible@clisp.cons.org>.  */
+
+#include <config.h>
+
+/* Specification.  */
+#include "concat-filename.h"
+
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "filename.h"
+
+/* Concatenate a directory filename, a relative filename and an optional
+   suffix.  The directory may end with the directory separator.  The second
+   argument may not start with the directory separator (it is relative).
+   Return a freshly allocated filename.  Return NULL and set errno
+   upon memory allocation failure.  */
+char *
+concatenated_filename (const char *directory, const char *filename,
+                       const char *suffix)
+{
+  char *result;
+  char *p;
+
+  if (strcmp (directory, ".") == 0)
+    {
+      /* No need to prepend the directory.  */
+      result = (char *) malloc (strlen (filename)
+                                + (suffix != NULL ? strlen (suffix) : 0)
+                                + 1);
+      if (result == NULL)
+        return NULL; /* errno is set here */
+      p = result;
+    }
+  else
+    {
+      size_t directory_len = strlen (directory);
+      int need_slash =
+        (directory_len > FILE_SYSTEM_PREFIX_LEN (directory)
+         && !ISSLASH (directory[directory_len - 1]));
+      result = (char *) malloc (directory_len + need_slash
+                                + strlen (filename)
+                                + (suffix != NULL ? strlen (suffix) : 0)
+                                + 1);
+      if (result == NULL)
+        return NULL; /* errno is set here */
+      memcpy (result, directory, directory_len);
+      p = result + directory_len;
+      if (need_slash)
+        *p++ = DIR_SEPARATOR;
+    }
+  p = stpcpy (p, filename);
+  if (suffix != NULL)
+    stpcpy (p, suffix);
+  return result;
+}
diff --git a/lib/creat.c b/lib/creat.c
index dad7b2da45..94a8823f96 100644
--- a/lib/creat.c
+++ b/lib/creat.c
@@ -43,6 +43,7 @@ orig_creat (const char *filename, mode_t mode)
 #include <errno.h>
 #include <string.h>
 #include <sys/types.h>
+#include "filename.h"
 
 int
 creat (const char *filename, mode_t mode)
@@ -63,7 +64,7 @@ creat (const char *filename, mode_t mode)
      creat() must fail since creat() cannot create directories.  */
   {
     size_t len = strlen (filename);
-    if (len > 0 && filename[len - 1] == '/')
+    if (len > 0 && ISSLASH(filename[len - 1]))
       {
         errno = EISDIR;
         return -1;
diff --git a/lib/dirname.h b/lib/dirname.h
index 0344f1c44c..65a2675ae9 100644
--- a/lib/dirname.h
+++ b/lib/dirname.h
@@ -30,7 +30,7 @@
 # include "basename-lgpl.h"
 
 # ifndef DIRECTORY_SEPARATOR
-#  define DIRECTORY_SEPARATOR '/'
+#  define DIRECTORY_SEPARATOR DIR_SEPARATOR
 # endif
 
 #ifdef __cplusplus
diff --git a/lib/exclude.c b/lib/exclude.c
index 7bd0ec8c71..9d794ad6a1 100644
--- a/lib/exclude.c
+++ b/lib/exclude.c
@@ -338,7 +338,7 @@ fnmatch_no_wildcards (char const *pattern, char const *f, int options)
       if (! r)
         {
           r = f[patlen];
-          if (r == '/')
+          if (ISSLASH(r))
             r = 0;
         }
       return r;
@@ -355,9 +355,9 @@ fnmatch_no_wildcards (char const *pattern, char const *f, int options)
       char *fcopy = xstrdup (f);
       char *p;
       int r;
-      for (p = fcopy; ; *p++ = '/')
+      for (p = fcopy; ; *p++ = DIR_SEPARATOR)
         {
-          p = strchr (p, '/');
+          p = strpbrk(p, SLASHES);
           if (p)
             *p = '\0';
           r = mbscasecmp (pattern, fcopy);
@@ -381,7 +381,7 @@ exclude_fnmatch (char const *pattern, char const *f, int options)
 
   if (! (options & EXCLUDE_ANCHORED))
     for (p = f; *p && ! matched; p++)
-      if (*p == '/' && p[1] != '/')
+      if ( ISSLASH(*p) && ! ISSLASH(p[1]))
         matched = ((*matcher) (pattern, p + 1, options) == 0);
 
   return matched;
@@ -434,7 +434,7 @@ file_name_matches (struct exclude_segment const *seg, char const *f,
             return true;
           if (options & FNM_LEADING_DIR)
             {
-              char *p = strrchr (buffer, '/');
+              char *p = LAST_SLASH_IN_PATH(buffer);
               if (p)
                 {
                   *p = 0;
@@ -446,7 +446,7 @@ file_name_matches (struct exclude_segment const *seg, char const *f,
 
       if (!(options & EXCLUDE_ANCHORED))
         {
-          f = strchr (f, '/');
+          f = strpbrk (f, SLASHES);
           if (f)
             f++;
         }
diff --git a/lib/faccessat.c b/lib/faccessat.c
index ac8977cfd6..1dbda1b178 100644
--- a/lib/faccessat.c
+++ b/lib/faccessat.c
@@ -30,6 +30,8 @@
 #include <stdlib.h>
 #include <string.h>
 #include <sys/stat.h>
+#include "filename.h"
+
 #undef _GL_INCLUDING_UNISTD_H
 
 #if HAVE_FACCESSAT
@@ -59,7 +61,7 @@ rpl_faccessat (int fd, char const *file, int mode, int flag)
 {
   int result = orig_faccessat (fd, file, mode, flag);
 
-  if (result == 0 && file[strlen (file) - 1] == '/')
+  if (result == 0 && ISSLASH(file[strlen (file) - 1]) )
     {
       struct stat st;
       result = fstatat (fd, file, &st, 0);
diff --git a/lib/fchownat.c b/lib/fchownat.c
index 8d00ae587c..0d4d3ff66d 100644
--- a/lib/fchownat.c
+++ b/lib/fchownat.c
@@ -31,6 +31,7 @@
 #include <string.h>
 
 #include "openat.h"
+#include "filename.h"
 
 #if !HAVE_FCHOWNAT
 
@@ -101,7 +102,7 @@ rpl_fchownat (int fd, char const *file, uid_t owner, gid_t group, int flag)
   {
     size_t len = strlen (file);
     struct stat st;
-    if (len && file[len - 1] == '/')
+    if (len && ISSLASH(file[len - 1]))
       {
         if (fstatat (fd, file, &st, 0))
           return -1;
diff --git a/lib/filename.h b/lib/filename.h
index a2400a9dfe..eecd9a96d7 100644
--- a/lib/filename.h
+++ b/lib/filename.h
@@ -57,8 +57,12 @@ extern "C" {
  */
 #if defined _WIN32 || defined __CYGWIN__ \
     || defined __EMX__ || defined __MSDOS__ || defined __DJGPP__
-  /* Native Windows, Cygwin, OS/2, DOS */
-# define ISSLASH(C) ((C) == '/' || (C) == '\\')
+
+ /* Native Windows, Cygwin, OS/2, DOS */
+const char* strrpbrk(const char* s, const char* accept);
+# define DIR_SEPARATOR		'\\'
+# define ISSLASH(C) ((C) == '/' || (C) == DIR_SEPARATOR)
+# define SLASHES			"\\/"
   /* Internal macro: Tests whether a character is a drive letter.  */
 # define _IS_DRIVE_LETTER(C) \
     (((C) >= 'A' && (C) <= 'Z') || ((C) >= 'a' && (C) <= 'z'))
@@ -88,15 +92,34 @@ extern "C" {
 # define IS_FILE_NAME_WITH_DIR(Filename) \
     (strchr ((Filename), '/') != NULL || strchr ((Filename), '\\') != NULL \
      || HAS_DEVICE (Filename))
+# define LAST_SLASH_IN_PATH(str) strrpbrk(str,SLASHES)
+
+	//could not find a good place to put this otherwise
+	static const char* strrpbrk(const char* s, const char* accept) {
+		const char* p = s + strlen(s);
+		while (--p >= s) {
+			const char* c = accept;
+			while (*c) {
+				if (*c++ == *p)
+					return p;
+			}
+		}
+		return NULL;
+	}
+
+
 #else
   /* Unix */
-# define ISSLASH(C) ((C) == '/')
+# define DIR_SEPARATOR		'/'
+# define ISSLASH(C) ((C) == DIR_SEPARATOR)
+# define SLASHES			"/"
 # define HAS_DEVICE(Filename) ((void) (Filename), 0)
 # define FILE_SYSTEM_PREFIX_LEN(Filename) ((void) (Filename), 0)
 # define FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE 0
 # define IS_ABSOLUTE_FILE_NAME(Filename) ISSLASH ((Filename)[0])
 # define IS_RELATIVE_FILE_NAME(Filename) (! ISSLASH ((Filename)[0]))
 # define IS_FILE_NAME_WITH_DIR(Filename) (strchr ((Filename), '/') != NULL)
+#define LAST_SLASH_IN_PATH(str) strrchr(str,SLASHES)
 #endif
 
 /* Deprecated macros.  For backward compatibility with old users of the
diff --git a/lib/filenamecat-lgpl.c b/lib/filenamecat-lgpl.c
index 6d7ed8481d..3936a7f4ed 100644
--- a/lib/filenamecat-lgpl.c
+++ b/lib/filenamecat-lgpl.c
@@ -56,7 +56,7 @@ mfile_name_concat (char const *dir, char const *base, char **base_in_result)
     {
       /* DIR is not a file system root, so separate with / if needed.  */
       if (! ISSLASH (dir[dirlen - 1]) && ! ISSLASH (*base))
-        sep = '/';
+        sep = DIR_SEPARATOR;
     }
   else if (ISSLASH (*base))
     {
diff --git a/lib/findprog-in.c b/lib/findprog-in.c
index c0768c29e2..69b95dac62 100644
--- a/lib/findprog-in.c
+++ b/lib/findprog-in.c
@@ -30,13 +30,7 @@
 #include "filename.h"
 #include "concat-filename.h"
 
-#if (defined _WIN32 && !defined __CYGWIN__) || defined __EMX__ || defined __DJGPP__
-  /* Native Windows, OS/2, DOS */
-# define NATIVE_SLASH '\\'
-#else
-  /* Unix */
-# define NATIVE_SLASH '/'
-#endif
+# define NATIVE_SLASH DIR_SEPARATOR
 
 /* Separator in PATH like lists of pathnames.  */
 #if (defined _WIN32 && !defined __CYGWIN__) || defined __EMX__ || defined __DJGPP__
diff --git a/lib/fnmatch_loop.c b/lib/fnmatch_loop.c
index 68a3b7a5bc..7184b81c55 100644
--- a/lib/fnmatch_loop.c
+++ b/lib/fnmatch_loop.c
@@ -18,6 +18,7 @@
 #ifdef _LIBC
 # include <stdint.h>
 #endif
+#include "filename.h"
 
 struct STRUCT
 {
@@ -70,7 +71,7 @@ FCT (const CHAR *pattern, const CHAR *string, const CHAR *string_end,
 
           if (n == string_end)
             return FNM_NOMATCH;
-          else if (*n == L_('/') && (flags & FNM_FILE_NAME))
+          else if ( ISSLASH(*n) && (flags & FNM_FILE_NAME))
             return FNM_NOMATCH;
           else if (*n == L_('.') && no_leading_period)
             return FNM_NOMATCH;
@@ -127,7 +128,7 @@ FCT (const CHAR *pattern, const CHAR *string, const CHAR *string_end,
                   if (n == string_end)
                     /* There isn't another character; no match.  */
                     return FNM_NOMATCH;
-                  else if (*n == L_('/')
+                  else if ( ISSLASH(*n)
                            && __glibc_unlikely (flags & FNM_FILE_NAME))
                     /* A slash does not match a wildcard under
                        FNM_FILE_NAME.  */
@@ -154,7 +155,7 @@ FCT (const CHAR *pattern, const CHAR *string, const CHAR *string_end,
                     result = 0;
                   else
                     {
-                      if (MEMCHR (n, L_('/'), string_end - n) == NULL)
+                      if (MEMCHR (n, L_('/'), string_end - n) == NULL && MEMCHR(n, DIR_SEPARATOR, string_end - n) == NULL)
                         result = 0;
                     }
                 }
@@ -167,8 +168,10 @@ FCT (const CHAR *pattern, const CHAR *string, const CHAR *string_end,
               struct STRUCT end;
 
               end.pattern = NULL;
-              endp = MEMCHR (n, (flags & FNM_FILE_NAME) ? L_('/') : L_('\0'),
+              endp = MEMCHR (n, (flags & FNM_FILE_NAME) ? DIR_SEPARATOR : L_('\0'),
                              string_end - n);
+			  if (endp == NULL && (flags & FNM_FILE_NAME) && DIR_SEPARATOR != '/')
+				  endp = MEMCHR(n, L_('/'), string_end - n);
               if (endp == NULL)
                 endp = string_end;
 
@@ -185,11 +188,11 @@ FCT (const CHAR *pattern, const CHAR *string, const CHAR *string_end,
                              &end, alloca_used) == 0)
                       goto found;
                 }
-              else if (c == L_('/') && (flags & FNM_FILE_NAME))
+              else if (ISSLASH(c) && (flags & FNM_FILE_NAME))
                 {
-                  while (n < string_end && *n != L_('/'))
+                  while (n < string_end && ! ISSLASH(*n))
                     ++n;
-                  if (n < string_end && *n == L_('/')
+                  if (n < string_end && ISSLASH (*n)
                       && (FCT (p, n + 1, string_end, flags & FNM_PERIOD, flags,
                                NULL, alloca_used) == 0))
                     return 0;
@@ -243,7 +246,7 @@ FCT (const CHAR *pattern, const CHAR *string, const CHAR *string_end,
             if (*n == L_('.') && no_leading_period)
               return FNM_NOMATCH;
 
-            if (*n == L_('/') && (flags & FNM_FILE_NAME))
+            if (ISSLASH(*n) && (flags & FNM_FILE_NAME))
               /* '/' cannot be matched.  */
               return FNM_NOMATCH;
 
@@ -922,7 +925,7 @@ FCT (const CHAR *pattern, const CHAR *string, const CHAR *string_end,
   if (n == string_end)
     return 0;
 
-  if ((flags & FNM_LEADING_DIR) && n != string_end && *n == L_('/'))
+  if ((flags & FNM_LEADING_DIR) && n != string_end && ISSLASH( *n ))
     /* The FNM_LEADING_DIR flag says that "foo*" matches "foobar/frobozz".  */
     return 0;
 
@@ -1100,7 +1103,7 @@ EXT (INT opt, const CHAR *pattern, const CHAR *string, const CHAR *string_end,
                 && (FCT (p, rs, string_end,
                          rs == string
                          ? no_leading_period
-                         : rs[-1] == '/' && NO_LEADING_PERIOD (flags),
+                         : ISSLASH(rs[-1]) && NO_LEADING_PERIOD (flags),
                          flags & FNM_FILE_NAME
                          ? flags : flags & ~FNM_PERIOD, NULL, alloca_used) == 0
                     /* This didn't work.  Try the whole pattern.  */
@@ -1108,7 +1111,7 @@ EXT (INT opt, const CHAR *pattern, const CHAR *string, const CHAR *string_end,
                         && FCT (pattern - 1, rs, string_end,
                                 rs == string
                                 ? no_leading_period
-                                : rs[-1] == '/' && NO_LEADING_PERIOD (flags),
+                                : ISSLASH(rs[-1]) && NO_LEADING_PERIOD (flags),
                                 flags & FNM_FILE_NAME
                                 ? flags : flags & ~FNM_PERIOD, NULL,
                                 alloca_used) == 0)))
@@ -1160,7 +1163,7 @@ EXT (INT opt, const CHAR *pattern, const CHAR *string, const CHAR *string_end,
               && (FCT (p, rs, string_end,
                        rs == string
                        ? no_leading_period
-                       : rs[-1] == '/' && NO_LEADING_PERIOD (flags),
+                       : ISSLASH(rs[-1]) && NO_LEADING_PERIOD (flags),
                        flags & FNM_FILE_NAME ? flags : flags & ~FNM_PERIOD,
                        NULL, alloca_used) == 0))
             /* This is successful.  */
diff --git a/lib/fopen.c b/lib/fopen.c
index e1e4cdbd23..4f5a7f35f9 100644
--- a/lib/fopen.c
+++ b/lib/fopen.c
@@ -24,6 +24,7 @@
 
 /* Get the original definition of fopen.  It might be defined as a macro.  */
 #include <stdio.h>
+#include "filename.h"
 #undef _GL_ALREADY_INCLUDING_STDIO_H
 
 static FILE *
@@ -163,7 +164,7 @@ rpl_fopen (const char *filename, const char *mode)
      fopen() must fail since the file does not contain a '.' directory.  */
   {
     size_t len = strlen (filename);
-    if (len > 0 && filename[len - 1] == '/')
+    if (len > 0 && ISSLASH(filename[len - 1]))
       {
         int fd;
         struct stat statbuf;
diff --git a/lib/fstatat.c b/lib/fstatat.c
index 372965ef5f..d5d11accac 100644
--- a/lib/fstatat.c
+++ b/lib/fstatat.c
@@ -26,6 +26,7 @@
 /* Get the original definition of fstatat.  It might be defined as a macro.  */
 #include <sys/types.h>
 #include <sys/stat.h>
+#include "filename.h"
 #undef __need_system_sys_stat_h
 
 #if HAVE_FSTATAT && HAVE_WORKING_FSTATAT_ZERO_FLAG
@@ -85,7 +86,7 @@ rpl_fstatat (int fd, char const *file, struct stat *st, int flag)
   if (flag & AT_SYMLINK_NOFOLLOW)
     {
       /* Fix lstat behavior.  */
-      if (file[len - 1] != '/' || S_ISDIR (st->st_mode))
+      if (ISSLASH(file[len - 1]) || S_ISDIR (st->st_mode))
         return 0;
       if (!S_ISLNK (st->st_mode))
         {
@@ -95,7 +96,7 @@ rpl_fstatat (int fd, char const *file, struct stat *st, int flag)
       result = normal_fstatat (fd, file, st, flag & ~AT_SYMLINK_NOFOLLOW);
     }
   /* Fix stat behavior.  */
-  if (result == 0 && !S_ISDIR (st->st_mode) && file[len - 1] == '/')
+  if (result == 0 && !S_ISDIR (st->st_mode) && ISSLASH(file[len - 1]))
     {
       errno = ENOTDIR;
       return -1;
diff --git a/lib/fts.c b/lib/fts.c
index 3fffb45d70..32feac006e 100644
--- a/lib/fts.c
+++ b/lib/fts.c
@@ -67,7 +67,7 @@ static char sccsid[] = "@(#)fts.c       8.6 (Berkeley) 8/14/94";
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
-
+#include "filename.h"
 #if ! _LIBC
 # include "attribute.h"
 # include "fcntl--.h"
@@ -473,8 +473,8 @@ fts_open (char * const *argv,
                     /* If there are two or more trailing slashes, trim all but one,
                        but don't change "//" to "/", and do map "///" to "/".  */
                     char const *v = *argv;
-                    if (2 < len && v[len - 1] == '/')
-                      while (1 < len && v[len - 2] == '/')
+                    if (2 < len && ISSLASH(v[len - 1]))
+                      while (1 < len && ISSLASH(v[len - 2]))
                         --len;
                   }
 
@@ -563,7 +563,7 @@ fts_load (FTS *sp, register FTSENT *p)
          */
         len = p->fts_pathlen = p->fts_namelen;
         memmove(sp->fts_path, p->fts_name, len + 1);
-        if ((cp = strrchr(p->fts_name, '/')) && (cp != p->fts_name || cp[1])) {
+		if ((cp = LAST_SLASH_IN_PATH(p->fts_name)) && (cp != p->fts_name || cp[1])) {
                 len = strlen(++cp);
                 memmove(p->fts_name, cp, len + 1);
                 p->fts_namelen = len;
@@ -832,7 +832,7 @@ leaf_optimization (_GL_UNUSED FTSENT const *p, _GL_UNUSED int dir_fd)
  * appended which would cause file names to be written as "....//foo".
  */
 #define NAPPEND(p)                                                      \
-        (p->fts_path[p->fts_pathlen - 1] == '/'                         \
+        (ISSLASH(p->fts_path[p->fts_pathlen - 1])                      \
             ? p->fts_pathlen - 1 : p->fts_pathlen)
 
 FTSENT *
@@ -1007,7 +1007,7 @@ next:   tmp = p;
                 }
 
 name:           t = sp->fts_path + NAPPEND(p->fts_parent);
-                *t++ = '/';
+                *t++ = DIR_SEPARATOR;
                 memmove(t, p->fts_name, p->fts_namelen + 1);
 check_for_dir:
                 sp->fts_cur = p;
@@ -1163,7 +1163,7 @@ fts_children (register FTS *sp, int instr)
          * directory is, so we can't get back so that the upcoming chdir by
          * fts_read will work.
          */
-        if (p->fts_level != FTS_ROOTLEVEL || p->fts_accpath[0] == '/' ||
+        if (p->fts_level != FTS_ROOTLEVEL || IS_ABSOLUTE_FILE_NAME(p->fts_accpath) ||
             ISSET(FTS_NOCHDIR))
                 return (sp->fts_child = fts_build(sp, instr));
 
@@ -1426,7 +1426,7 @@ fts_build (register FTS *sp, int type)
         len = NAPPEND(cur);
         if (ISSET(FTS_NOCHDIR)) {
                 cp = sp->fts_path + len;
-                *cp++ = '/';
+                *cp++ = DIR_SEPARATOR;
         } else {
                 /* GCC, you're too verbose. */
                 cp = NULL;
diff --git a/lib/getcwd.c b/lib/getcwd.c
index 0530630c43..199229e9cb 100644
--- a/lib/getcwd.c
+++ b/lib/getcwd.c
@@ -30,7 +30,7 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <stddef.h>
-
+#include "filename.h"
 #include <fcntl.h> /* For AT_FDCWD on Solaris 9.  */
 
 /* If this host provides the openat function or if we're using the
@@ -311,7 +311,7 @@ __getcwd_generic (char *buf, size_t size)
       dirstream = __opendir (dotlist);
       if (dirstream == NULL)
         goto lose;
-      dotlist[dotlen++] = '/';
+      dotlist[dotlen++] = DIR_SEPARATOR;
 #endif
       for (;;)
         {
@@ -388,7 +388,7 @@ __getcwd_generic (char *buf, size_t size)
                   {
                     dotlist[i++] = '.';
                     dotlist[i++] = '.';
-                    dotlist[i++] = '/';
+                    dotlist[i++] = DIR_SEPARATOR;
                   }
                 while (i < dotlen);
               }
@@ -437,7 +437,7 @@ __getcwd_generic (char *buf, size_t size)
         }
       dirp -= namlen;
       memcpy (dirp, d->d_name, namlen);
-      *--dirp = '/';
+      *--dirp = DIR_SEPARATOR;
 
       thisdev = dotdev;
       thisino = dotino;
@@ -511,7 +511,7 @@ __getcwd_generic (char *buf, size_t size)
     }
 
   if (dirp == &dir[allocated - 1])
-    *--dirp = '/';
+    *--dirp = DIR_SEPARATOR;
 
 #if ! HAVE_OPENAT_SUPPORT
   if (dotlist != dots)
diff --git a/lib/glob.c b/lib/glob.c
index ddca1e9820..38906eca2c 100644
--- a/lib/glob.c
+++ b/lib/glob.c
@@ -1,1547 +1,1548 @@
-/* Copyright (C) 1991-2023 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#ifndef _LIBC
-
-/* Don't use __attribute__ __nonnull__ in this compilation unit.  Otherwise gcc
-   optimizes away the pattern == NULL test below.  */
-# define _GL_ARG_NONNULL(params)
-
-# include <libc-config.h>
-
-#endif
-
-#include <glob.h>
-
-#include <errno.h>
-#include <fcntl.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <stddef.h>
-#include <stdint.h>
-#include <assert.h>
-#include <unistd.h>
-
-#if defined _WIN32 && ! defined __CYGWIN__
-# define WINDOWS32
-#endif
-
-#ifndef WINDOWS32
-# include <pwd.h>
-#endif
-
-#include <errno.h>
-#include <dirent.h>
-#include <stdlib.h>
-#include <string.h>
-#include <alloca.h>
-
-#ifdef _LIBC
-# undef strdup
-# define strdup(str) __strdup (str)
-# define sysconf(id) __sysconf (id)
-# define closedir(dir) __closedir (dir)
-# define opendir(name) __opendir (name)
-# undef dirfd
-# define dirfd(str) __dirfd (str)
-# define readdir(str) __readdir64 (str)
-# define getpwnam_r(name, bufp, buf, len, res) \
-    __getpwnam_r (name, bufp, buf, len, res)
-# define FLEXIBLE_ARRAY_MEMBER
-# ifndef struct_stat
-#  define struct_stat           struct stat
-# endif
-# ifndef struct_stat64
-#  define struct_stat64         struct stat64
-# endif
-# ifndef GLOB_LSTAT
-#  define GLOB_LSTAT            gl_lstat
-# endif
-# ifndef GLOB_FSTATAT64
-#  define GLOB_FSTATAT64        __fstatat64
-# endif
-# include <shlib-compat.h>
-#else /* !_LIBC */
-# define __glob                 glob
-# define __getlogin_r(buf, len) getlogin_r (buf, len)
-# define __fxstatat64(_, d, f, st, flag) fstatat (d, f, st, flag)
-# ifndef __MVS__
-#  define __alloca              alloca
-# endif
-# define __readdir              readdir
-# define COMPILE_GLOB64
-# define struct_stat            struct stat
-# define struct_stat64          struct stat
-# define GLOB_LSTAT             gl_lstat
-# define GLOB_FSTATAT64         fstatat
-#endif /* _LIBC */
-
-#include <fnmatch.h>
-
-#include <flexmember.h>
-#include <glob_internal.h>
-#include <scratch_buffer.h>
-
-static const char *next_brace_sub (const char *begin, int flags) __THROWNL;
-
-/* The type of ((struct dirent *) 0)->d_type is 'unsigned char' on most
-   platforms, but 'unsigned int' in the mingw from mingw.org.  */
-typedef uint_fast32_t dirent_type;
-
-#if !defined _LIBC && !defined HAVE_STRUCT_DIRENT_D_TYPE
-/* Any distinct values will do here.
-   Undef any existing macros out of the way.  */
-# undef DT_UNKNOWN
-# undef DT_DIR
-# undef DT_LNK
-# define DT_UNKNOWN 0
-# define DT_DIR 1
-# define DT_LNK 2
-#endif
-
-/* A representation of a directory entry which does not depend on the
-   layout of struct dirent, or the size of ino_t.  */
-struct readdir_result
-{
-  const char *name;
-#if defined _DIRENT_HAVE_D_TYPE || defined HAVE_STRUCT_DIRENT_D_TYPE
-  dirent_type type;
-#endif
-};
-
-/* Initialize and return type member of struct readdir_result.  */
-static dirent_type
-readdir_result_type (struct readdir_result d)
-{
-#if defined _DIRENT_HAVE_D_TYPE || defined HAVE_STRUCT_DIRENT_D_TYPE
-# define D_TYPE_TO_RESULT(source) (source)->d_type,
-  return d.type;
-#else
-# define D_TYPE_TO_RESULT(source)
-  return DT_UNKNOWN;
-#endif
-}
-
-/* Construct an initializer for a struct readdir_result object from a
-   struct dirent *.  No copy of the name is made.  */
-#define READDIR_RESULT_INITIALIZER(source) \
-  {                                        \
-    source->d_name,                        \
-    D_TYPE_TO_RESULT (source)              \
-  }
-
-/* Call gl_readdir on STREAM.  This macro can be overridden to reduce
-   type safety if an old interface version needs to be supported.  */
-#ifndef GL_READDIR
-# define GL_READDIR(pglob, stream) ((pglob)->gl_readdir (stream))
-#endif
-
-/* Extract name and type from directory entry.  No copy of the name is
-   made.  If SOURCE is NULL, result name is NULL.  Keep in sync with
-   convert_dirent64 below.  */
-static struct readdir_result
-convert_dirent (const struct dirent *source)
-{
-  if (source == NULL)
-    {
-      struct readdir_result result = { NULL, };
-      return result;
-    }
-  struct readdir_result result = READDIR_RESULT_INITIALIZER (source);
-  return result;
-}
-
-#ifndef COMPILE_GLOB64
-/* Like convert_dirent, but works on struct dirent64 instead.  Keep in
-   sync with convert_dirent above.  */
-static struct readdir_result
-convert_dirent64 (const struct dirent64 *source)
-{
-  if (source == NULL)
-    {
-      struct readdir_result result = { NULL, };
-      return result;
-    }
-  struct readdir_result result = READDIR_RESULT_INITIALIZER (source);
-  return result;
-}
-#endif
-
-#ifndef _LIBC
-/* The results of opendir() in this file are not used with dirfd and fchdir,
-   and we do not leak fds to any single-threaded code that could use stdio,
-   therefore save some unnecessary recursion in fchdir.c and opendir_safer.c.
-   FIXME - if the kernel ever adds support for multi-thread safety for
-   avoiding standard fds, then we should use opendir_safer.  */
-# ifdef GNULIB_defined_opendir
-#  undef opendir
-# endif
-# ifdef GNULIB_defined_closedir
-#  undef closedir
-# endif
-
-/* Just use malloc.  */
-# define __libc_use_alloca(n) false
-# define alloca_account(len, avar) ((void) (len), (void) (avar), (void *) 0)
-# define extend_alloca_account(buf, len, newlen, avar) \
-    ((void) (buf), (void) (len), (void) (newlen), (void) (avar), (void *) 0)
-#endif
-
-static int
-glob_lstat (glob_t *pglob, int flags, const char *fullname)
-{
-/* Use on glob-lstat-compat.c to provide a compat symbol which does not
-   use lstat / gl_lstat.  */
-  union
-  {
-    struct_stat st;
-    struct_stat64 st64;
-  } ust;
-  return (__glibc_unlikely (flags & GLOB_ALTDIRFUNC)
-          ? pglob->GLOB_LSTAT (fullname, &ust.st)
-          : GLOB_FSTATAT64 (AT_FDCWD, fullname, &ust.st64,
-                            AT_SYMLINK_NOFOLLOW));
-}
-
-/* Set *R = A + B.  Return true if the answer is mathematically
-   incorrect due to overflow; in this case, *R is the low order
-   bits of the correct answer.  */
-
-static bool
-size_add_wrapv (size_t a, size_t b, size_t *r)
-{
-#if 7 <= __GNUC__ && !defined __ICC
-  return __builtin_add_overflow (a, b, r);
-#else
-  *r = a + b;
-  return *r < a;
-#endif
-}
-
-static bool
-glob_use_alloca (size_t alloca_used, size_t len)
-{
-  size_t size;
-  return (!size_add_wrapv (alloca_used, len, &size)
-          && __libc_use_alloca (size));
-}
-
-static int glob_in_dir (const char *pattern, const char *directory,
-                        int flags, int (*errfunc) (const char *, int),
-                        glob_t *pglob, size_t alloca_used);
-static int prefix_array (const char *prefix, char **array, size_t n) __THROWNL;
-static int collated_compare (const void *, const void *) __THROWNL;
-
-
-/* Return true if FILENAME is a directory or a symbolic link to a directory.
-   Use FLAGS and PGLOB to resolve the filename.  */
-static bool
-is_dir (char const *filename, int flags, glob_t const *pglob)
-{
-  struct_stat st;
-  struct_stat64 st64;
-  return (__glibc_unlikely (flags & GLOB_ALTDIRFUNC)
-          ? pglob->gl_stat (filename, &st) == 0 && S_ISDIR (st.st_mode)
-          : (GLOB_FSTATAT64 (AT_FDCWD, filename, &st64, 0) == 0
-             && S_ISDIR (st64.st_mode)));
-}
-
-/* Find the end of the sub-pattern in a brace expression.  */
-static const char *
-next_brace_sub (const char *cp, int flags)
-{
-  size_t depth = 0;
-  while (*cp != '\0')
-    if ((flags & GLOB_NOESCAPE) == 0 && *cp == '\\')
-      {
-        if (*++cp == '\0')
-          break;
-        ++cp;
-      }
-    else
-      {
-        if ((*cp == '}' && depth-- == 0) || (*cp == ',' && depth == 0))
-          break;
-
-        if (*cp++ == '{')
-          depth++;
-      }
-
-  return *cp != '\0' ? cp : NULL;
-}
-
-#ifndef GLOB_ATTRIBUTE
-# define GLOB_ATTRIBUTE
-#endif
-
-/* Do glob searching for PATTERN, placing results in PGLOB.
-   The bits defined above may be set in FLAGS.
-   If a directory cannot be opened or read and ERRFUNC is not nil,
-   it is called with the pathname that caused the error, and the
-   'errno' value from the failing call; if it returns non-zero
-   'glob' returns GLOB_ABORTED; if it returns zero, the error is ignored.
-   If memory cannot be allocated for PGLOB, GLOB_NOSPACE is returned.
-   Otherwise, 'glob' returns zero.  */
-int
-GLOB_ATTRIBUTE
-__glob (const char *pattern, int flags, int (*errfunc) (const char *, int),
-        glob_t *pglob)
-{
-  const char *filename;
-  char *dirname = NULL;
-  size_t dirlen;
-  int status;
-  size_t oldcount;
-  int meta;
-  int dirname_modified;
-  int malloc_dirname = 0;
-  glob_t dirs;
-  int retval = 0;
-  size_t alloca_used = 0;
-
-  if (pattern == NULL || pglob == NULL || (flags & ~__GLOB_FLAGS) != 0)
-    {
-      __set_errno (EINVAL);
-      return -1;
-    }
-
-  /* POSIX requires all slashes to be matched.  This means that with
-     a trailing slash we must match only directories.  */
-  if (pattern[0] && pattern[strlen (pattern) - 1] == '/')
-    flags |= GLOB_ONLYDIR;
-
-  if (!(flags & GLOB_DOOFFS))
-    /* Have to do this so 'globfree' knows where to start freeing.  It
-       also makes all the code that uses gl_offs simpler. */
-    pglob->gl_offs = 0;
-
-  if (!(flags & GLOB_APPEND))
-    {
-      pglob->gl_pathc = 0;
-      if (!(flags & GLOB_DOOFFS))
-        pglob->gl_pathv = NULL;
-      else
-        {
-          size_t i;
-
-          if (pglob->gl_offs >= ~((size_t) 0) / sizeof (char *))
-            return GLOB_NOSPACE;
-
-          pglob->gl_pathv = (char **) malloc ((pglob->gl_offs + 1)
-                                              * sizeof (char *));
-          if (pglob->gl_pathv == NULL)
-            return GLOB_NOSPACE;
-
-          for (i = 0; i <= pglob->gl_offs; ++i)
-            pglob->gl_pathv[i] = NULL;
-        }
-    }
-
-  if (flags & GLOB_BRACE)
-    {
-      const char *begin;
-
-      if (flags & GLOB_NOESCAPE)
-        begin = strchr (pattern, '{');
-      else
-        {
-          begin = pattern;
-          while (1)
-            {
-              if (*begin == '\0')
-                {
-                  begin = NULL;
-                  break;
-                }
-
-              if (*begin == '\\' && begin[1] != '\0')
-                ++begin;
-              else if (*begin == '{')
-                break;
-
-              ++begin;
-            }
-        }
-
-      if (begin != NULL)
-        {
-          /* Allocate working buffer large enough for our work.  Note that
-             we have at least an opening and closing brace.  */
-          size_t firstc;
-          char *alt_start;
-          const char *p;
-          const char *next;
-          const char *rest;
-          size_t rest_len;
-          char *onealt;
-          size_t pattern_len = strlen (pattern) - 1;
-          int alloca_onealt = glob_use_alloca (alloca_used, pattern_len);
-          if (alloca_onealt)
-            onealt = alloca_account (pattern_len, alloca_used);
-          else
-            {
-              onealt = malloc (pattern_len);
-              if (onealt == NULL)
-                return GLOB_NOSPACE;
-            }
-
-          /* We know the prefix for all sub-patterns.  */
-          alt_start = mempcpy (onealt, pattern, begin - pattern);
-
-          /* Find the first sub-pattern and at the same time find the
-             rest after the closing brace.  */
-          next = next_brace_sub (begin + 1, flags);
-          if (next == NULL)
-            {
-              /* It is an invalid expression.  */
-            illegal_brace:
-              if (__glibc_unlikely (!alloca_onealt))
-                free (onealt);
-              flags &= ~GLOB_BRACE;
-              goto no_brace;
-            }
-
-          /* Now find the end of the whole brace expression.  */
-          rest = next;
-          while (*rest != '}')
-            {
-              rest = next_brace_sub (rest + 1, flags);
-              if (rest == NULL)
-                /* It is an illegal expression.  */
-                goto illegal_brace;
-            }
-          /* Please note that we now can be sure the brace expression
-             is well-formed.  */
-          rest_len = strlen (++rest) + 1;
-
-          /* We have a brace expression.  BEGIN points to the opening {,
-             NEXT points past the terminator of the first element, and END
-             points past the final }.  We will accumulate result names from
-             recursive runs for each brace alternative in the buffer using
-             GLOB_APPEND.  */
-          firstc = pglob->gl_pathc;
-
-          p = begin + 1;
-          while (1)
-            {
-              int result;
-
-              /* Construct the new glob expression.  */
-              mempcpy (mempcpy (alt_start, p, next - p), rest, rest_len);
-
-              result = __glob (onealt,
-                               ((flags & ~(GLOB_NOCHECK | GLOB_NOMAGIC))
-                                | GLOB_APPEND),
-                               errfunc, pglob);
-
-              /* If we got an error, return it.  */
-              if (result && result != GLOB_NOMATCH)
-                {
-                  if (__glibc_unlikely (!alloca_onealt))
-                    free (onealt);
-                  if (!(flags & GLOB_APPEND))
-                    {
-                      globfree (pglob);
-                      pglob->gl_pathc = 0;
-                    }
-                  return result;
-                }
-
-              if (*next == '}')
-                /* We saw the last entry.  */
-                break;
-
-              p = next + 1;
-              next = next_brace_sub (p, flags);
-              assert (next != NULL);
-            }
-
-          if (__glibc_unlikely (!alloca_onealt))
-            free (onealt);
-
-          if (pglob->gl_pathc != firstc)
-            /* We found some entries.  */
-            return 0;
-          else if (!(flags & (GLOB_NOCHECK|GLOB_NOMAGIC)))
-            return GLOB_NOMATCH;
-        }
-    }
-
- no_brace:
-  oldcount = pglob->gl_pathc + pglob->gl_offs;
-
-  /* Find the filename.  */
-  filename = strrchr (pattern, '/');
-
-#if defined __MSDOS__ || defined WINDOWS32
-  /* The case of "d:pattern".  Since ':' is not allowed in
-     file names, we can safely assume that wherever it
-     happens in pattern, it signals the filename part.  This
-     is so we could some day support patterns like "[a-z]:foo".  */
-  if (filename == NULL)
-    filename = strchr (pattern, ':');
-#endif /* __MSDOS__ || WINDOWS32 */
-
-  dirname_modified = 0;
-  if (filename == NULL)
-    {
-      /* This can mean two things: a simple name or "~name".  The latter
-         case is nothing but a notation for a directory.  */
-      if ((flags & (GLOB_TILDE|GLOB_TILDE_CHECK)) && pattern[0] == '~')
-        {
-          dirname = (char *) pattern;
-          dirlen = strlen (pattern);
-
-          /* Set FILENAME to NULL as a special flag.  This is ugly but
-             other solutions would require much more code.  We test for
-             this special case below.  */
-          filename = NULL;
-        }
-      else
-        {
-          if (__glibc_unlikely (pattern[0] == '\0'))
-            {
-              dirs.gl_pathv = NULL;
-              goto no_matches;
-            }
-
-          filename = pattern;
-          dirname = (char *) ".";
-          dirlen = 0;
-        }
-    }
-  else if (filename == pattern
-           || (filename == pattern + 1 && pattern[0] == '\\'
-               && (flags & GLOB_NOESCAPE) == 0))
-    {
-      /* "/pattern" or "\\/pattern".  */
-      dirname = (char *) "/";
-      dirlen = 1;
-      ++filename;
-    }
-  else
-    {
-      char *newp;
-      dirlen = filename - pattern;
-#if defined __MSDOS__ || defined WINDOWS32
-      if (*filename == ':'
-          || (filename > pattern + 1 && filename[-1] == ':'))
-        {
-          char *drive_spec;
-
-          ++dirlen;
-          drive_spec = __alloca (dirlen + 1);
-          *((char *) mempcpy (drive_spec, pattern, dirlen)) = '\0';
-          /* For now, disallow wildcards in the drive spec, to
-             prevent infinite recursion in glob.  */
-          if (__glob_pattern_p (drive_spec, !(flags & GLOB_NOESCAPE)))
-            return GLOB_NOMATCH;
-          /* If this is "d:pattern", we need to copy ':' to DIRNAME
-             as well.  If it's "d:/pattern", don't remove the slash
-             from "d:/", since "d:" and "d:/" are not the same.*/
-        }
-#endif
-
-      if (glob_use_alloca (alloca_used, dirlen + 1))
-        newp = alloca_account (dirlen + 1, alloca_used);
-      else
-        {
-          newp = malloc (dirlen + 1);
-          if (newp == NULL)
-            return GLOB_NOSPACE;
-          malloc_dirname = 1;
-        }
-      *((char *) mempcpy (newp, pattern, dirlen)) = '\0';
-      dirname = newp;
-      ++filename;
-
-#if defined __MSDOS__ || defined WINDOWS32
-      bool drive_root = (dirlen > 1
-                         && (dirname[dirlen - 1] == ':'
-                             || (dirlen > 2 && dirname[dirlen - 2] == ':'
-                                 && dirname[dirlen - 1] == '/')));
-#else
-      bool drive_root = false;
-#endif
-
-      if (filename[0] == '\0' && dirlen > 1 && !drive_root)
-        /* "pattern/".  Expand "pattern", appending slashes.  */
-        {
-          int orig_flags = flags;
-          if (!(flags & GLOB_NOESCAPE) && dirname[dirlen - 1] == '\\')
-            {
-              /* "pattern\\/".  Remove the final backslash if it hasn't
-                 been quoted.  */
-              char *p = (char *) &dirname[dirlen - 1];
-
-              while (p > dirname && p[-1] == '\\') --p;
-              if ((&dirname[dirlen] - p) & 1)
-                {
-                  *(char *) &dirname[--dirlen] = '\0';
-                  flags &= ~(GLOB_NOCHECK | GLOB_NOMAGIC);
-                }
-            }
-          int val = __glob (dirname, flags | GLOB_MARK, errfunc, pglob);
-          if (val == 0)
-            pglob->gl_flags = ((pglob->gl_flags & ~GLOB_MARK)
-                               | (flags & GLOB_MARK));
-          else if (val == GLOB_NOMATCH && flags != orig_flags)
-            {
-              /* Make sure globfree (&dirs); is a nop.  */
-              dirs.gl_pathv = NULL;
-              flags = orig_flags;
-              oldcount = pglob->gl_pathc + pglob->gl_offs;
-              goto no_matches;
-            }
-          retval = val;
-          goto out;
-        }
-    }
-
-  if ((flags & (GLOB_TILDE|GLOB_TILDE_CHECK)) && dirname[0] == '~')
-    {
-      if (dirname[1] == '\0' || dirname[1] == '/'
-          || (!(flags & GLOB_NOESCAPE) && dirname[1] == '\\'
-              && (dirname[2] == '\0' || dirname[2] == '/')))
-        {
-          /* Look up home directory.  */
-          char *home_dir = getenv ("HOME");
-          int malloc_home_dir = 0;
-          if (home_dir == NULL || home_dir[0] == '\0')
-            {
-#ifdef WINDOWS32
-              /* Windows NT defines HOMEDRIVE and HOMEPATH.  But give
-                 preference to HOME, because the user can change HOME.  */
-              const char *home_drive = getenv ("HOMEDRIVE");
-              const char *home_path = getenv ("HOMEPATH");
-
-              if (home_drive != NULL && home_path != NULL)
-                {
-                  size_t home_drive_len = strlen (home_drive);
-                  size_t home_path_len = strlen (home_path);
-                  char *mem = alloca (home_drive_len + home_path_len + 1);
-
-                  memcpy (mem, home_drive, home_drive_len);
-                  memcpy (mem + home_drive_len, home_path, home_path_len + 1);
-                  home_dir = mem;
-                }
-              else
-                home_dir = "c:/users/default"; /* poor default */
-#else
-              int err;
-              struct passwd *p;
-              struct passwd pwbuf;
-              struct scratch_buffer s;
-              scratch_buffer_init (&s);
-              while (true)
-                {
-                  p = NULL;
-                  err = __getlogin_r (s.data, s.length);
-                  if (err == 0)
-                    {
-# if defined HAVE_GETPWNAM_R || defined _LIBC
-                      size_t ssize = strlen (s.data) + 1;
-                      char *sdata = s.data;
-                      err = getpwnam_r (sdata, &pwbuf, sdata + ssize,
-                                        s.length - ssize, &p);
-# else
-                      p = getpwnam (s.data);
-                      if (p == NULL)
-                        err = errno;
-# endif
-                    }
-                  if (err != ERANGE)
-                    break;
-                  if (!scratch_buffer_grow (&s))
-                    {
-                      retval = GLOB_NOSPACE;
-                      goto out;
-                    }
-                }
-              if (err == 0)
-                {
-                  home_dir = strdup (p->pw_dir);
-                  malloc_home_dir = 1;
-                }
-              scratch_buffer_free (&s);
-              if (err == 0 && home_dir == NULL)
-                {
-                  retval = GLOB_NOSPACE;
-                  goto out;
-                }
-#endif /* WINDOWS32 */
-            }
-          if (home_dir == NULL || home_dir[0] == '\0')
-            {
-              if (__glibc_unlikely (malloc_home_dir))
-                free (home_dir);
-              if (flags & GLOB_TILDE_CHECK)
-                {
-                  retval = GLOB_NOMATCH;
-                  goto out;
-                }
-              else
-                {
-                  home_dir = (char *) "~"; /* No luck.  */
-                  malloc_home_dir = 0;
-                }
-            }
-          /* Now construct the full directory.  */
-          if (dirname[1] == '\0')
-            {
-              if (__glibc_unlikely (malloc_dirname))
-                free (dirname);
-
-              dirname = home_dir;
-              dirlen = strlen (dirname);
-              malloc_dirname = malloc_home_dir;
-            }
-          else
-            {
-              char *newp;
-              size_t home_len = strlen (home_dir);
-              int use_alloca = glob_use_alloca (alloca_used, home_len + dirlen);
-              if (use_alloca)
-                newp = alloca_account (home_len + dirlen, alloca_used);
-              else
-                {
-                  newp = malloc (home_len + dirlen);
-                  if (newp == NULL)
-                    {
-                      if (__glibc_unlikely (malloc_home_dir))
-                        free (home_dir);
-                      retval = GLOB_NOSPACE;
-                      goto out;
-                    }
-                }
-
-              mempcpy (mempcpy (newp, home_dir, home_len),
-                       &dirname[1], dirlen);
-
-              if (__glibc_unlikely (malloc_dirname))
-                free (dirname);
-
-              dirname = newp;
-              dirlen += home_len - 1;
-              malloc_dirname = !use_alloca;
-
-              if (__glibc_unlikely (malloc_home_dir))
-                free (home_dir);
-            }
-          dirname_modified = 1;
-        }
-      else
-        {
-#ifndef WINDOWS32
-          /* Recognize ~user as a shorthand for the specified user's home
-             directory.  */
-          char *end_name = strchr (dirname, '/');
-          char *user_name;
-          int malloc_user_name = 0;
-          char *unescape = NULL;
-
-          if (!(flags & GLOB_NOESCAPE))
-            {
-              if (end_name == NULL)
-                {
-                  unescape = strchr (dirname, '\\');
-                  if (unescape)
-                    end_name = strchr (unescape, '\0');
-                }
-              else
-                unescape = memchr (dirname, '\\', end_name - dirname);
-            }
-          if (end_name == NULL)
-            user_name = dirname + 1;
-          else
-            {
-              char *newp;
-              if (glob_use_alloca (alloca_used, end_name - dirname))
-                newp = alloca_account (end_name - dirname, alloca_used);
-              else
-                {
-                  newp = malloc (end_name - dirname);
-                  if (newp == NULL)
-                    {
-                      retval = GLOB_NOSPACE;
-                      goto out;
-                    }
-                  malloc_user_name = 1;
-                }
-              if (unescape != NULL)
-                {
-                  char *p = mempcpy (newp, dirname + 1,
-                                     unescape - dirname - 1);
-                  char *q = unescape;
-                  while (q != end_name)
-                    {
-                      if (*q == '\\')
-                        {
-                          if (q + 1 == end_name)
-                            {
-                              /* "~fo\\o\\" unescape to user_name "foo\\",
-                                 but "~fo\\o\\/" unescape to user_name
-                                 "foo".  */
-                              if (filename == NULL)
-                                *p++ = '\\';
-                              break;
-                            }
-                          ++q;
-                        }
-                      *p++ = *q++;
-                    }
-                  *p = '\0';
-                }
-              else
-                *((char *) mempcpy (newp, dirname + 1, end_name - dirname - 1))
-                  = '\0';
-              user_name = newp;
-            }
-
-          /* Look up specific user's home directory.  */
-          {
-            struct passwd *p;
-            struct scratch_buffer pwtmpbuf;
-            scratch_buffer_init (&pwtmpbuf);
-
-#  if defined HAVE_GETPWNAM_R || defined _LIBC
-            struct passwd pwbuf;
-
-            while (getpwnam_r (user_name, &pwbuf,
-                               pwtmpbuf.data, pwtmpbuf.length, &p)
-                   == ERANGE)
-              {
-                if (!scratch_buffer_grow (&pwtmpbuf))
-                  {
-                    retval = GLOB_NOSPACE;
-                    goto out;
-                  }
-              }
-#  else
-            p = getpwnam (user_name);
-#  endif
-
-            if (__glibc_unlikely (malloc_user_name))
-              free (user_name);
-
-            /* If we found a home directory use this.  */
-            if (p != NULL)
-              {
-                size_t home_len = strlen (p->pw_dir);
-                size_t rest_len = end_name == NULL ? 0 : strlen (end_name);
-                /* dirname contains end_name; we can't free it now.  */
-                char *prev_dirname =
-                  (__glibc_unlikely (malloc_dirname) ? dirname : NULL);
-                char *d;
-
-                malloc_dirname = 0;
-
-                if (glob_use_alloca (alloca_used, home_len + rest_len + 1))
-                  dirname = alloca_account (home_len + rest_len + 1,
-                                            alloca_used);
-                else
-                  {
-                    dirname = malloc (home_len + rest_len + 1);
-                    if (dirname == NULL)
-                      {
-                        free (prev_dirname);
-                        scratch_buffer_free (&pwtmpbuf);
-                        retval = GLOB_NOSPACE;
-                        goto out;
-                      }
-                    malloc_dirname = 1;
-                  }
-                d = mempcpy (dirname, p->pw_dir, home_len);
-                if (end_name != NULL)
-                  d = mempcpy (d, end_name, rest_len);
-                *d = '\0';
-
-                free (prev_dirname);
-
-                dirlen = home_len + rest_len;
-                dirname_modified = 1;
-              }
-            else
-              {
-                if (flags & GLOB_TILDE_CHECK)
-                  {
-                    /* We have to regard it as an error if we cannot find the
-                       home directory.  */
-                    retval = GLOB_NOMATCH;
-                    goto out;
-                  }
-              }
-            scratch_buffer_free (&pwtmpbuf);
-          }
-#else /* WINDOWS32 */
-          /* On native Windows, access to a user's home directory
-             (via GetUserProfileDirectory) or to a user's environment
-             variables (via ExpandEnvironmentStringsForUser) requires
-             the credentials of the user.  Therefore we cannot support
-             the ~user syntax on this platform.
-             Handling ~user specially (and treat it like plain ~) if
-             user is getenv ("USERNAME") would not be a good idea,
-             since it would make people think that ~user is supported
-             in general.  */
-          if (flags & GLOB_TILDE_CHECK)
-            {
-              retval = GLOB_NOMATCH;
-              goto out;
-            }
-#endif /* WINDOWS32 */
-        }
-    }
-
-  /* Now test whether we looked for "~" or "~NAME".  In this case we
-     can give the answer now.  */
-  if (filename == NULL)
-    {
-      size_t newcount = pglob->gl_pathc + pglob->gl_offs;
-      char **new_gl_pathv;
-
-      if (newcount > SIZE_MAX / sizeof (char *) - 2)
-        {
-        nospace:
-          free (pglob->gl_pathv);
-          pglob->gl_pathv = NULL;
-          pglob->gl_pathc = 0;
-          retval = GLOB_NOSPACE;
-          goto out;
-        }
-
-      new_gl_pathv = realloc (pglob->gl_pathv,
-                              (newcount + 2) * sizeof (char *));
-      if (new_gl_pathv == NULL)
-        goto nospace;
-      pglob->gl_pathv = new_gl_pathv;
-
-      if (flags & GLOB_MARK && is_dir (dirname, flags, pglob))
-        {
-          char *p;
-          pglob->gl_pathv[newcount] = malloc (dirlen + 2);
-          if (pglob->gl_pathv[newcount] == NULL)
-            goto nospace;
-          p = mempcpy (pglob->gl_pathv[newcount], dirname, dirlen);
-          p[0] = '/';
-          p[1] = '\0';
-          if (__glibc_unlikely (malloc_dirname))
-            free (dirname);
-        }
-      else
-        {
-          if (__glibc_unlikely (malloc_dirname))
-            pglob->gl_pathv[newcount] = dirname;
-          else
-            {
-              pglob->gl_pathv[newcount] = strdup (dirname);
-              if (pglob->gl_pathv[newcount] == NULL)
-                goto nospace;
-            }
-        }
-      pglob->gl_pathv[++newcount] = NULL;
-      ++pglob->gl_pathc;
-      pglob->gl_flags = flags;
-
-      return 0;
-    }
-
-  meta = __glob_pattern_type (dirname, !(flags & GLOB_NOESCAPE));
-  /* meta is 1 if correct glob pattern containing metacharacters.
-     If meta has bit (1 << 2) set, it means there was an unterminated
-     [ which we handle the same, using fnmatch.  Broken unterminated
-     pattern bracket expressions ought to be rare enough that it is
-     not worth special casing them, fnmatch will do the right thing.  */
-  if (meta & (GLOBPAT_SPECIAL | GLOBPAT_BRACKET))
-    {
-      /* The directory name contains metacharacters, so we
-         have to glob for the directory, and then glob for
-         the pattern in each directory found.  */
-      size_t i;
-
-      if (!(flags & GLOB_NOESCAPE) && dirlen > 0 && dirname[dirlen - 1] == '\\')
-        {
-          /* "foo\\/bar".  Remove the final backslash from dirname
-             if it has not been quoted.  */
-          char *p = (char *) &dirname[dirlen - 1];
-
-          while (p > dirname && p[-1] == '\\') --p;
-          if ((&dirname[dirlen] - p) & 1)
-            *(char *) &dirname[--dirlen] = '\0';
-        }
-
-      if (__glibc_unlikely ((flags & GLOB_ALTDIRFUNC) != 0))
-        {
-          /* Use the alternative access functions also in the recursive
-             call.  */
-          dirs.gl_opendir = pglob->gl_opendir;
-          dirs.gl_readdir = pglob->gl_readdir;
-          dirs.gl_closedir = pglob->gl_closedir;
-          dirs.gl_stat = pglob->gl_stat;
-          dirs.gl_lstat = pglob->gl_lstat;
-        }
-
-      status = __glob (dirname,
-                       ((flags & (GLOB_ERR | GLOB_NOESCAPE | GLOB_ALTDIRFUNC))
-                        | GLOB_NOSORT | GLOB_ONLYDIR),
-                       errfunc, &dirs);
-      if (status != 0)
-        {
-          if ((flags & GLOB_NOCHECK) == 0 || status != GLOB_NOMATCH)
-            {
-              retval = status;
-              goto out;
-            }
-          goto no_matches;
-        }
-
-      /* We have successfully globbed the preceding directory name.
-         For each name we found, call glob_in_dir on it and FILENAME,
-         appending the results to PGLOB.  */
-      for (i = 0; i < dirs.gl_pathc; ++i)
-        {
-          size_t old_pathc;
-
-          old_pathc = pglob->gl_pathc;
-          status = glob_in_dir (filename, dirs.gl_pathv[i],
-                                ((flags | GLOB_APPEND)
-                                 & ~(GLOB_NOCHECK | GLOB_NOMAGIC)),
-                                errfunc, pglob, alloca_used);
-          if (status == GLOB_NOMATCH)
-            /* No matches in this directory.  Try the next.  */
-            continue;
-
-          if (status != 0)
-            {
-              globfree (&dirs);
-              globfree (pglob);
-              pglob->gl_pathc = 0;
-              retval = status;
-              goto out;
-            }
-
-          /* Stick the directory on the front of each name.  */
-          if (prefix_array (dirs.gl_pathv[i],
-                            &pglob->gl_pathv[old_pathc + pglob->gl_offs],
-                            pglob->gl_pathc - old_pathc))
-            {
-              globfree (&dirs);
-              globfree (pglob);
-              pglob->gl_pathc = 0;
-              retval = GLOB_NOSPACE;
-              goto out;
-            }
-        }
-
-      flags |= GLOB_MAGCHAR;
-
-      /* We have ignored the GLOB_NOCHECK flag in the 'glob_in_dir' calls.
-         But if we have not found any matching entry and the GLOB_NOCHECK
-         flag was set we must return the input pattern itself.  */
-      if (pglob->gl_pathc + pglob->gl_offs == oldcount)
-        {
-        no_matches:
-          /* No matches.  */
-          if (flags & GLOB_NOCHECK)
-            {
-              size_t newcount = pglob->gl_pathc + pglob->gl_offs;
-              char **new_gl_pathv;
-
-              if (newcount > SIZE_MAX / sizeof (char *) - 2)
-                {
-                nospace2:
-                  globfree (&dirs);
-                  retval = GLOB_NOSPACE;
-                  goto out;
-                }
-
-              new_gl_pathv = realloc (pglob->gl_pathv,
-                                      (newcount + 2) * sizeof (char *));
-              if (new_gl_pathv == NULL)
-                goto nospace2;
-              pglob->gl_pathv = new_gl_pathv;
-
-              pglob->gl_pathv[newcount] = strdup (pattern);
-              if (pglob->gl_pathv[newcount] == NULL)
-                {
-                  globfree (&dirs);
-                  globfree (pglob);
-                  pglob->gl_pathc = 0;
-                  retval = GLOB_NOSPACE;
-                  goto out;
-                }
-
-              ++pglob->gl_pathc;
-              ++newcount;
-
-              pglob->gl_pathv[newcount] = NULL;
-              pglob->gl_flags = flags;
-            }
-          else
-            {
-              globfree (&dirs);
-              retval = GLOB_NOMATCH;
-              goto out;
-            }
-        }
-
-      globfree (&dirs);
-    }
-  else
-    {
-      size_t old_pathc = pglob->gl_pathc;
-      int orig_flags = flags;
-
-      if (meta & GLOBPAT_BACKSLASH)
-        {
-          char *p = strchr (dirname, '\\'), *q;
-          /* We need to unescape the dirname string.  It is certainly
-             allocated by alloca, as otherwise filename would be NULL
-             or dirname wouldn't contain backslashes.  */
-          q = p;
-          do
-            {
-              if (*p == '\\')
-                {
-                  *q = *++p;
-                  --dirlen;
-                }
-              else
-                *q = *p;
-              ++q;
-            }
-          while (*p++ != '\0');
-          dirname_modified = 1;
-        }
-      if (dirname_modified)
-        flags &= ~(GLOB_NOCHECK | GLOB_NOMAGIC);
-      status = glob_in_dir (filename, dirname, flags, errfunc, pglob,
-                            alloca_used);
-      if (status != 0)
-        {
-          if (status == GLOB_NOMATCH && flags != orig_flags
-              && pglob->gl_pathc + pglob->gl_offs == oldcount)
-            {
-              /* Make sure globfree (&dirs); is a nop.  */
-              dirs.gl_pathv = NULL;
-              flags = orig_flags;
-              goto no_matches;
-            }
-          retval = status;
-          goto out;
-        }
-
-      if (dirlen > 0)
-        {
-          /* Stick the directory on the front of each name.  */
-          if (prefix_array (dirname,
-                            &pglob->gl_pathv[old_pathc + pglob->gl_offs],
-                            pglob->gl_pathc - old_pathc))
-            {
-              globfree (pglob);
-              pglob->gl_pathc = 0;
-              retval = GLOB_NOSPACE;
-              goto out;
-            }
-        }
-    }
-
-  if (flags & GLOB_MARK)
-    {
-      /* Append slashes to directory names.  */
-      size_t i;
-
-      for (i = oldcount; i < pglob->gl_pathc + pglob->gl_offs; ++i)
-        if (is_dir (pglob->gl_pathv[i], flags, pglob))
-          {
-            size_t len = strlen (pglob->gl_pathv[i]) + 2;
-            char *new = realloc (pglob->gl_pathv[i], len);
-            if (new == NULL)
-              {
-                globfree (pglob);
-                pglob->gl_pathc = 0;
-                retval = GLOB_NOSPACE;
-                goto out;
-              }
-            strcpy (&new[len - 2], "/");
-            pglob->gl_pathv[i] = new;
-          }
-    }
-
-  if (!(flags & GLOB_NOSORT))
-    {
-      /* Sort the vector.  */
-      qsort (&pglob->gl_pathv[oldcount],
-             pglob->gl_pathc + pglob->gl_offs - oldcount,
-             sizeof (char *), collated_compare);
-    }
-
- out:
-  if (__glibc_unlikely (malloc_dirname))
-    free (dirname);
-
-  return retval;
-}
-#if defined _LIBC && !defined __glob
-versioned_symbol (libc, __glob, glob, GLIBC_2_27);
-libc_hidden_ver (__glob, glob)
-#endif
-
-
-/* Do a collated comparison of A and B.  */
-static int
-collated_compare (const void *a, const void *b)
-{
-  char *const *ps1 = a; char *s1 = *ps1;
-  char *const *ps2 = b; char *s2 = *ps2;
-
-  if (s1 == s2)
-    return 0;
-  if (s1 == NULL)
-    return 1;
-  if (s2 == NULL)
-    return -1;
-  return strcoll (s1, s2);
-}
-
-
-/* Prepend DIRNAME to each of N members of ARRAY, replacing ARRAY's
-   elements in place.  Return nonzero if out of memory, zero if successful.
-   A slash is inserted between DIRNAME and each elt of ARRAY,
-   unless DIRNAME is just "/".  Each old element of ARRAY is freed.  */
-static int
-prefix_array (const char *dirname, char **array, size_t n)
-{
-  size_t i;
-  size_t dirlen = strlen (dirname);
-  char dirsep_char = '/';
-
-  if (dirlen == 1 && dirname[0] == '/')
-    /* DIRNAME is just "/", so normal prepending would get us "//foo".
-       We want "/foo" instead, so don't prepend any chars from DIRNAME.  */
-    dirlen = 0;
-
-#if defined __MSDOS__ || defined WINDOWS32
-  if (dirlen > 1)
-    {
-      if (dirname[dirlen - 1] == '/' && dirname[dirlen - 2] == ':')
-        /* DIRNAME is "d:/".  Don't prepend the slash from DIRNAME.  */
-        --dirlen;
-      else if (dirname[dirlen - 1] == ':')
-        {
-          /* DIRNAME is "d:".  Use ':' instead of '/'.  */
-          --dirlen;
-          dirsep_char = ':';
-        }
-    }
-#endif
-
-  for (i = 0; i < n; ++i)
-    {
-      size_t eltlen = strlen (array[i]) + 1;
-      char *new = malloc (dirlen + 1 + eltlen);
-      if (new == NULL)
-        {
-          while (i > 0)
-            free (array[--i]);
-          return 1;
-        }
-
-      {
-        char *endp = mempcpy (new, dirname, dirlen);
-        *endp++ = dirsep_char;
-        mempcpy (endp, array[i], eltlen);
-      }
-      free (array[i]);
-      array[i] = new;
-    }
-
-  return 0;
-}
-
-/* Like 'glob', but PATTERN is a final pathname component,
-   and matches are searched for in DIRECTORY.
-   The GLOB_NOSORT bit in FLAGS is ignored.  No sorting is ever done.
-   The GLOB_APPEND flag is assumed to be set (always appends).  */
-static int
-glob_in_dir (const char *pattern, const char *directory, int flags,
-             int (*errfunc) (const char *, int),
-             glob_t *pglob, size_t alloca_used)
-{
-  size_t dirlen = strlen (directory);
-  void *stream = NULL;
-  struct scratch_buffer s;
-  scratch_buffer_init (&s);
-# define GLOBNAMES_MEMBERS(nnames) \
-    struct globnames *next; size_t count; char *name[nnames];
-  struct globnames { GLOBNAMES_MEMBERS (FLEXIBLE_ARRAY_MEMBER) };
-  struct { GLOBNAMES_MEMBERS (64) } init_names_buf;
-  struct globnames *init_names = (struct globnames *) &init_names_buf;
-  struct globnames *names = init_names;
-  struct globnames *names_alloca = init_names;
-  size_t nfound = 0;
-  size_t cur = 0;
-  int meta;
-  int save;
-  int result;
-
-  alloca_used += sizeof init_names_buf;
-
-  init_names->next = NULL;
-  init_names->count = ((sizeof init_names_buf
-                        - offsetof (struct globnames, name))
-                       / sizeof init_names->name[0]);
-
-  meta = __glob_pattern_type (pattern, !(flags & GLOB_NOESCAPE));
-  if (meta == GLOBPAT_NONE && (flags & (GLOB_NOCHECK|GLOB_NOMAGIC)))
-    {
-      /* We need not do any tests.  The PATTERN contains no meta
-         characters and we must not return an error therefore the
-         result will always contain exactly one name.  */
-      flags |= GLOB_NOCHECK;
-    }
-  else if (meta == GLOBPAT_NONE)
-    {
-      size_t patlen = strlen (pattern);
-      size_t fullsize;
-      bool alloca_fullname
-        = (! size_add_wrapv (dirlen + 1, patlen + 1, &fullsize)
-           && glob_use_alloca (alloca_used, fullsize));
-      char *fullname;
-      if (alloca_fullname)
-        fullname = alloca_account (fullsize, alloca_used);
-      else
-        {
-          fullname = malloc (fullsize);
-          if (fullname == NULL)
-            return GLOB_NOSPACE;
-        }
-
-      mempcpy (mempcpy (mempcpy (fullname, directory, dirlen),
-                        "/", 1),
-               pattern, patlen + 1);
-      if (glob_lstat (pglob, flags, fullname) == 0
-          || errno == EOVERFLOW)
-        /* We found this file to be existing.  Now tell the rest
-           of the function to copy this name into the result.  */
-        flags |= GLOB_NOCHECK;
-
-      if (__glibc_unlikely (!alloca_fullname))
-        free (fullname);
-    }
-  else
-    {
-      stream = (__builtin_expect (flags & GLOB_ALTDIRFUNC, 0)
-                ? (*pglob->gl_opendir) (directory)
-                : opendir (directory));
-      if (stream == NULL)
-        {
-          if (errno != ENOTDIR
-              && ((errfunc != NULL && (*errfunc) (directory, errno))
-                  || (flags & GLOB_ERR)))
-            return GLOB_ABORTED;
-        }
-      else
-        {
-          DIR *dirp = stream;
-          int dfd = dirfd (dirp);
-          int fnm_flags = ((!(flags & GLOB_PERIOD) ? FNM_PERIOD : 0)
-                           | ((flags & GLOB_NOESCAPE) ? FNM_NOESCAPE : 0));
-          flags |= GLOB_MAGCHAR;
-
-          while (1)
-            {
-              struct readdir_result d;
-              {
-                if (__builtin_expect (flags & GLOB_ALTDIRFUNC, 0))
-                  d = convert_dirent (GL_READDIR (pglob, stream));
-                else
-                  {
-#ifdef COMPILE_GLOB64
-                    d = convert_dirent (__readdir (stream));
-#else
-                    d = convert_dirent64 (__readdir64 (stream));
-#endif
-                  }
-              }
-              if (d.name == NULL)
-                break;
-
-              /* If we shall match only directories use the information
-                 provided by the dirent call if possible.  */
-              if (flags & GLOB_ONLYDIR)
-                switch (readdir_result_type (d))
-                  {
-                  default: continue;
-                  case DT_DIR: break;
-                  case DT_LNK: case DT_UNKNOWN:
-                    /* The filesystem was too lazy to give us a hint,
-                       so we have to do it the hard way.  */
-                    if (__glibc_unlikely (dfd < 0 || flags & GLOB_ALTDIRFUNC))
-                      {
-                        size_t namelen = strlen (d.name);
-                        size_t need = dirlen + 1 + namelen + 1;
-                        if (s.length < need
-                            && !scratch_buffer_set_array_size (&s, need, 1))
-                          goto memory_error;
-                        char *p = mempcpy (s.data, directory, dirlen);
-                        *p = '/';
-                        p += p[-1] != '/';
-                        memcpy (p, d.name, namelen + 1);
-                        if (! is_dir (s.data, flags, pglob))
-                          continue;
-                      }
-                    else
-                      {
-                        struct_stat64 st64;
-                        if (! (GLOB_FSTATAT64 (dfd, d.name, &st64, 0) == 0
-                               && S_ISDIR (st64.st_mode)))
-                          continue;
-                      }
-                  }
-
-              if (fnmatch (pattern, d.name, fnm_flags) == 0)
-                {
-                  if (cur == names->count)
-                    {
-                      struct globnames *newnames;
-                      size_t count = names->count * 2;
-                      size_t nameoff = offsetof (struct globnames, name);
-                      size_t size = FLEXSIZEOF (struct globnames, name,
-                                                count * sizeof (char *));
-                      if ((SIZE_MAX - nameoff) / 2 / sizeof (char *)
-                          < names->count)
-                        goto memory_error;
-                      if (glob_use_alloca (alloca_used, size))
-                        newnames = names_alloca
-                          = alloca_account (size, alloca_used);
-                      else if ((newnames = malloc (size))
-                               == NULL)
-                        goto memory_error;
-                      newnames->count = count;
-                      newnames->next = names;
-                      names = newnames;
-                      cur = 0;
-                    }
-                  names->name[cur] = strdup (d.name);
-                  if (names->name[cur] == NULL)
-                    goto memory_error;
-                  ++cur;
-                  ++nfound;
-                  if (SIZE_MAX - pglob->gl_offs <= nfound)
-                    goto memory_error;
-                }
-            }
-        }
-    }
-
-  if (nfound == 0 && (flags & GLOB_NOCHECK))
-    {
-      size_t len = strlen (pattern);
-      nfound = 1;
-      names->name[cur] = malloc (len + 1);
-      if (names->name[cur] == NULL)
-        goto memory_error;
-      *((char *) mempcpy (names->name[cur++], pattern, len)) = '\0';
-    }
-
-  result = GLOB_NOMATCH;
-  if (nfound != 0)
-    {
-      char **new_gl_pathv;
-      result = 0;
-
-      if (SIZE_MAX / sizeof (char *) - pglob->gl_pathc
-          < pglob->gl_offs + nfound + 1)
-        goto memory_error;
-
-      new_gl_pathv
-        = realloc (pglob->gl_pathv,
-                   (pglob->gl_pathc + pglob->gl_offs + nfound + 1)
-                    * sizeof (char *));
-
-      if (new_gl_pathv == NULL)
-        {
-        memory_error:
-          while (1)
-            {
-              struct globnames *old = names;
-              for (size_t i = 0; i < cur; ++i)
-                free (names->name[i]);
-              names = names->next;
-              /* NB: we will not leak memory here if we exit without
-                 freeing the current block assigned to OLD.  At least
-                 the very first block is always allocated on the stack
-                 and this is the block assigned to OLD here.  */
-              if (names == NULL)
-                {
-                  assert (old == init_names);
-                  break;
-                }
-              cur = names->count;
-              if (old == names_alloca)
-                names_alloca = names;
-              else
-                free (old);
-            }
-          result = GLOB_NOSPACE;
-        }
-      else
-        {
-          while (1)
-            {
-              struct globnames *old = names;
-              for (size_t i = 0; i < cur; ++i)
-                new_gl_pathv[pglob->gl_offs + pglob->gl_pathc++]
-                  = names->name[i];
-              names = names->next;
-              /* NB: we will not leak memory here if we exit without
-                 freeing the current block assigned to OLD.  At least
-                 the very first block is always allocated on the stack
-                 and this is the block assigned to OLD here.  */
-              if (names == NULL)
-                {
-                  assert (old == init_names);
-                  break;
-                }
-              cur = names->count;
-              if (old == names_alloca)
-                names_alloca = names;
-              else
-                free (old);
-            }
-
-          pglob->gl_pathv = new_gl_pathv;
-
-          pglob->gl_pathv[pglob->gl_offs + pglob->gl_pathc] = NULL;
-
-          pglob->gl_flags = flags;
-        }
-    }
-
-  if (stream != NULL)
-    {
-      save = errno;
-      if (__glibc_unlikely (flags & GLOB_ALTDIRFUNC))
-        (*pglob->gl_closedir) (stream);
-      else
-        closedir (stream);
-      __set_errno (save);
-    }
-
-  scratch_buffer_free (&s);
-  return result;
-}
+/* Copyright (C) 1991-2023 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _LIBC
+
+/* Don't use __attribute__ __nonnull__ in this compilation unit.  Otherwise gcc
+   optimizes away the pattern == NULL test below.  */
+# define _GL_ARG_NONNULL(params)
+
+# include <libc-config.h>
+
+#endif
+
+#include <glob.h>
+
+#include <errno.h>
+#include <fcntl.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <stddef.h>
+#include <stdint.h>
+#include <assert.h>
+#include <unistd.h>
+
+#if defined _WIN32 && ! defined __CYGWIN__
+# define WINDOWS32
+#endif
+
+#ifndef WINDOWS32
+# include <pwd.h>
+#endif
+
+#include <errno.h>
+#include <dirent.h>
+#include <stdlib.h>
+#include <string.h>
+#include <alloca.h>
+#include "filename.h"
+
+#ifdef _LIBC
+# undef strdup
+# define strdup(str) __strdup (str)
+# define sysconf(id) __sysconf (id)
+# define closedir(dir) __closedir (dir)
+# define opendir(name) __opendir (name)
+# undef dirfd
+# define dirfd(str) __dirfd (str)
+# define readdir(str) __readdir64 (str)
+# define getpwnam_r(name, bufp, buf, len, res) \
+    __getpwnam_r (name, bufp, buf, len, res)
+# define FLEXIBLE_ARRAY_MEMBER
+# ifndef struct_stat
+#  define struct_stat           struct stat
+# endif
+# ifndef struct_stat64
+#  define struct_stat64         struct stat64
+# endif
+# ifndef GLOB_LSTAT
+#  define GLOB_LSTAT            gl_lstat
+# endif
+# ifndef GLOB_FSTATAT64
+#  define GLOB_FSTATAT64        __fstatat64
+# endif
+# include <shlib-compat.h>
+#else /* !_LIBC */
+# define __glob                 glob
+# define __getlogin_r(buf, len) getlogin_r (buf, len)
+# define __fxstatat64(_, d, f, st, flag) fstatat (d, f, st, flag)
+# ifndef __MVS__
+#  define __alloca              alloca
+# endif
+# define __readdir              readdir
+# define COMPILE_GLOB64
+# define struct_stat            struct stat
+# define struct_stat64          struct stat
+# define GLOB_LSTAT             gl_lstat
+# define GLOB_FSTATAT64         fstatat
+#endif /* _LIBC */
+
+#include <fnmatch.h>
+
+#include <flexmember.h>
+#include <glob_internal.h>
+#include <scratch_buffer.h>
+
+static const char *next_brace_sub (const char *begin, int flags) __THROWNL;
+
+/* The type of ((struct dirent *) 0)->d_type is 'unsigned char' on most
+   platforms, but 'unsigned int' in the mingw from mingw.org.  */
+typedef uint_fast32_t dirent_type;
+
+#if !defined _LIBC && !defined HAVE_STRUCT_DIRENT_D_TYPE
+/* Any distinct values will do here.
+   Undef any existing macros out of the way.  */
+# undef DT_UNKNOWN
+# undef DT_DIR
+# undef DT_LNK
+# define DT_UNKNOWN 0
+# define DT_DIR 1
+# define DT_LNK 2
+#endif
+
+/* A representation of a directory entry which does not depend on the
+   layout of struct dirent, or the size of ino_t.  */
+struct readdir_result
+{
+  const char *name;
+#if defined _DIRENT_HAVE_D_TYPE || defined HAVE_STRUCT_DIRENT_D_TYPE
+  dirent_type type;
+#endif
+};
+
+/* Initialize and return type member of struct readdir_result.  */
+static dirent_type
+readdir_result_type (struct readdir_result d)
+{
+#if defined _DIRENT_HAVE_D_TYPE || defined HAVE_STRUCT_DIRENT_D_TYPE
+# define D_TYPE_TO_RESULT(source) (source)->d_type,
+  return d.type;
+#else
+# define D_TYPE_TO_RESULT(source)
+  return DT_UNKNOWN;
+#endif
+}
+
+/* Construct an initializer for a struct readdir_result object from a
+   struct dirent *.  No copy of the name is made.  */
+#define READDIR_RESULT_INITIALIZER(source) \
+  {                                        \
+    source->d_name,                        \
+    D_TYPE_TO_RESULT (source)              \
+  }
+
+/* Call gl_readdir on STREAM.  This macro can be overridden to reduce
+   type safety if an old interface version needs to be supported.  */
+#ifndef GL_READDIR
+# define GL_READDIR(pglob, stream) ((pglob)->gl_readdir (stream))
+#endif
+
+/* Extract name and type from directory entry.  No copy of the name is
+   made.  If SOURCE is NULL, result name is NULL.  Keep in sync with
+   convert_dirent64 below.  */
+static struct readdir_result
+convert_dirent (const struct dirent *source)
+{
+  if (source == NULL)
+    {
+      struct readdir_result result = { NULL, };
+      return result;
+    }
+  struct readdir_result result = READDIR_RESULT_INITIALIZER (source);
+  return result;
+}
+
+#ifndef COMPILE_GLOB64
+/* Like convert_dirent, but works on struct dirent64 instead.  Keep in
+   sync with convert_dirent above.  */
+static struct readdir_result
+convert_dirent64 (const struct dirent64 *source)
+{
+  if (source == NULL)
+    {
+      struct readdir_result result = { NULL, };
+      return result;
+    }
+  struct readdir_result result = READDIR_RESULT_INITIALIZER (source);
+  return result;
+}
+#endif
+
+#ifndef _LIBC
+/* The results of opendir() in this file are not used with dirfd and fchdir,
+   and we do not leak fds to any single-threaded code that could use stdio,
+   therefore save some unnecessary recursion in fchdir.c and opendir_safer.c.
+   FIXME - if the kernel ever adds support for multi-thread safety for
+   avoiding standard fds, then we should use opendir_safer.  */
+# ifdef GNULIB_defined_opendir
+#  undef opendir
+# endif
+# ifdef GNULIB_defined_closedir
+#  undef closedir
+# endif
+
+/* Just use malloc.  */
+# define __libc_use_alloca(n) false
+# define alloca_account(len, avar) ((void) (len), (void) (avar), (void *) 0)
+# define extend_alloca_account(buf, len, newlen, avar) \
+    ((void) (buf), (void) (len), (void) (newlen), (void) (avar), (void *) 0)
+#endif
+
+static int
+glob_lstat (glob_t *pglob, int flags, const char *fullname)
+{
+/* Use on glob-lstat-compat.c to provide a compat symbol which does not
+   use lstat / gl_lstat.  */
+  union
+  {
+    struct_stat st;
+    struct_stat64 st64;
+  } ust;
+  return (__glibc_unlikely (flags & GLOB_ALTDIRFUNC)
+          ? pglob->GLOB_LSTAT (fullname, &ust.st)
+          : GLOB_FSTATAT64 (AT_FDCWD, fullname, &ust.st64,
+                            AT_SYMLINK_NOFOLLOW));
+}
+
+/* Set *R = A + B.  Return true if the answer is mathematically
+   incorrect due to overflow; in this case, *R is the low order
+   bits of the correct answer.  */
+
+static bool
+size_add_wrapv (size_t a, size_t b, size_t *r)
+{
+#if 7 <= __GNUC__ && !defined __ICC
+  return __builtin_add_overflow (a, b, r);
+#else
+  *r = a + b;
+  return *r < a;
+#endif
+}
+
+static bool
+glob_use_alloca (size_t alloca_used, size_t len)
+{
+  size_t size;
+  return (!size_add_wrapv (alloca_used, len, &size)
+          && __libc_use_alloca (size));
+}
+
+static int glob_in_dir (const char *pattern, const char *directory,
+                        int flags, int (*errfunc) (const char *, int),
+                        glob_t *pglob, size_t alloca_used);
+static int prefix_array (const char *prefix, char **array, size_t n) __THROWNL;
+static int collated_compare (const void *, const void *) __THROWNL;
+
+
+/* Return true if FILENAME is a directory or a symbolic link to a directory.
+   Use FLAGS and PGLOB to resolve the filename.  */
+static bool
+is_dir (char const *filename, int flags, glob_t const *pglob)
+{
+  struct_stat st;
+  struct_stat64 st64;
+  return (__glibc_unlikely (flags & GLOB_ALTDIRFUNC)
+          ? pglob->gl_stat (filename, &st) == 0 && S_ISDIR (st.st_mode)
+          : (GLOB_FSTATAT64 (AT_FDCWD, filename, &st64, 0) == 0
+             && S_ISDIR (st64.st_mode)));
+}
+
+/* Find the end of the sub-pattern in a brace expression.  */
+static const char *
+next_brace_sub (const char *cp, int flags)
+{
+  size_t depth = 0;
+  while (*cp != '\0')
+    if ((flags & GLOB_NOESCAPE) == 0 && *cp == '\\')
+      {
+        if (*++cp == '\0')
+          break;
+        ++cp;
+      }
+    else
+      {
+        if ((*cp == '}' && depth-- == 0) || (*cp == ',' && depth == 0))
+          break;
+
+        if (*cp++ == '{')
+          depth++;
+      }
+
+  return *cp != '\0' ? cp : NULL;
+}
+
+#ifndef GLOB_ATTRIBUTE
+# define GLOB_ATTRIBUTE
+#endif
+
+/* Do glob searching for PATTERN, placing results in PGLOB.
+   The bits defined above may be set in FLAGS.
+   If a directory cannot be opened or read and ERRFUNC is not nil,
+   it is called with the pathname that caused the error, and the
+   'errno' value from the failing call; if it returns non-zero
+   'glob' returns GLOB_ABORTED; if it returns zero, the error is ignored.
+   If memory cannot be allocated for PGLOB, GLOB_NOSPACE is returned.
+   Otherwise, 'glob' returns zero.  */
+int
+GLOB_ATTRIBUTE
+__glob (const char *pattern, int flags, int (*errfunc) (const char *, int),
+        glob_t *pglob)
+{
+  const char *filename;
+  char *dirname = NULL;
+  size_t dirlen;
+  int status;
+  size_t oldcount;
+  int meta;
+  int dirname_modified;
+  int malloc_dirname = 0;
+  glob_t dirs;
+  int retval = 0;
+  size_t alloca_used = 0;
+
+  if (pattern == NULL || pglob == NULL || (flags & ~__GLOB_FLAGS) != 0)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  /* POSIX requires all slashes to be matched.  This means that with
+     a trailing slash we must match only directories.  */
+  if (pattern[0] && ISSLASH(pattern[strlen (pattern) - 1]))
+    flags |= GLOB_ONLYDIR;
+
+  if (!(flags & GLOB_DOOFFS))
+    /* Have to do this so 'globfree' knows where to start freeing.  It
+       also makes all the code that uses gl_offs simpler. */
+    pglob->gl_offs = 0;
+
+  if (!(flags & GLOB_APPEND))
+    {
+      pglob->gl_pathc = 0;
+      if (!(flags & GLOB_DOOFFS))
+        pglob->gl_pathv = NULL;
+      else
+        {
+          size_t i;
+
+          if (pglob->gl_offs >= ~((size_t) 0) / sizeof (char *))
+            return GLOB_NOSPACE;
+
+          pglob->gl_pathv = (char **) malloc ((pglob->gl_offs + 1)
+                                              * sizeof (char *));
+          if (pglob->gl_pathv == NULL)
+            return GLOB_NOSPACE;
+
+          for (i = 0; i <= pglob->gl_offs; ++i)
+            pglob->gl_pathv[i] = NULL;
+        }
+    }
+
+  if (flags & GLOB_BRACE)
+    {
+      const char *begin;
+
+      if (flags & GLOB_NOESCAPE)
+        begin = strchr (pattern, '{');
+      else
+        {
+          begin = pattern;
+          while (1)
+            {
+              if (*begin == '\0')
+                {
+                  begin = NULL;
+                  break;
+                }
+
+              if (*begin == '\\' && begin[1] != '\0')
+                ++begin;
+              else if (*begin == '{')
+                break;
+
+              ++begin;
+            }
+        }
+
+      if (begin != NULL)
+        {
+          /* Allocate working buffer large enough for our work.  Note that
+             we have at least an opening and closing brace.  */
+          size_t firstc;
+          char *alt_start;
+          const char *p;
+          const char *next;
+          const char *rest;
+          size_t rest_len;
+          char *onealt;
+          size_t pattern_len = strlen (pattern) - 1;
+          int alloca_onealt = glob_use_alloca (alloca_used, pattern_len);
+          if (alloca_onealt)
+            onealt = alloca_account (pattern_len, alloca_used);
+          else
+            {
+              onealt = malloc (pattern_len);
+              if (onealt == NULL)
+                return GLOB_NOSPACE;
+            }
+
+          /* We know the prefix for all sub-patterns.  */
+          alt_start = mempcpy (onealt, pattern, begin - pattern);
+
+          /* Find the first sub-pattern and at the same time find the
+             rest after the closing brace.  */
+          next = next_brace_sub (begin + 1, flags);
+          if (next == NULL)
+            {
+              /* It is an invalid expression.  */
+            illegal_brace:
+              if (__glibc_unlikely (!alloca_onealt))
+                free (onealt);
+              flags &= ~GLOB_BRACE;
+              goto no_brace;
+            }
+
+          /* Now find the end of the whole brace expression.  */
+          rest = next;
+          while (*rest != '}')
+            {
+              rest = next_brace_sub (rest + 1, flags);
+              if (rest == NULL)
+                /* It is an illegal expression.  */
+                goto illegal_brace;
+            }
+          /* Please note that we now can be sure the brace expression
+             is well-formed.  */
+          rest_len = strlen (++rest) + 1;
+
+          /* We have a brace expression.  BEGIN points to the opening {,
+             NEXT points past the terminator of the first element, and END
+             points past the final }.  We will accumulate result names from
+             recursive runs for each brace alternative in the buffer using
+             GLOB_APPEND.  */
+          firstc = pglob->gl_pathc;
+
+          p = begin + 1;
+          while (1)
+            {
+              int result;
+
+              /* Construct the new glob expression.  */
+              mempcpy (mempcpy (alt_start, p, next - p), rest, rest_len);
+
+              result = __glob (onealt,
+                               ((flags & ~(GLOB_NOCHECK | GLOB_NOMAGIC))
+                                | GLOB_APPEND),
+                               errfunc, pglob);
+
+              /* If we got an error, return it.  */
+              if (result && result != GLOB_NOMATCH)
+                {
+                  if (__glibc_unlikely (!alloca_onealt))
+                    free (onealt);
+                  if (!(flags & GLOB_APPEND))
+                    {
+                      globfree (pglob);
+                      pglob->gl_pathc = 0;
+                    }
+                  return result;
+                }
+
+              if (*next == '}')
+                /* We saw the last entry.  */
+                break;
+
+              p = next + 1;
+              next = next_brace_sub (p, flags);
+              assert (next != NULL);
+            }
+
+          if (__glibc_unlikely (!alloca_onealt))
+            free (onealt);
+
+          if (pglob->gl_pathc != firstc)
+            /* We found some entries.  */
+            return 0;
+          else if (!(flags & (GLOB_NOCHECK|GLOB_NOMAGIC)))
+            return GLOB_NOMATCH;
+        }
+    }
+
+ no_brace:
+  oldcount = pglob->gl_pathc + pglob->gl_offs;
+
+  /* Find the filename.  */
+  filename = LAST_SLASH_IN_PATH(pattern);
+
+#if defined __MSDOS__ || defined WINDOWS32
+  /* The case of "d:pattern".  Since ':' is not allowed in
+     file names, we can safely assume that wherever it
+     happens in pattern, it signals the filename part.  This
+     is so we could some day support patterns like "[a-z]:foo".  */
+  if (filename == NULL)
+    filename = strchr (pattern, ':');
+#endif /* __MSDOS__ || WINDOWS32 */
+
+  dirname_modified = 0;
+  if (filename == NULL)
+    {
+      /* This can mean two things: a simple name or "~name".  The latter
+         case is nothing but a notation for a directory.  */
+      if ((flags & (GLOB_TILDE|GLOB_TILDE_CHECK)) && pattern[0] == '~')
+        {
+          dirname = (char *) pattern;
+          dirlen = strlen (pattern);
+
+          /* Set FILENAME to NULL as a special flag.  This is ugly but
+             other solutions would require much more code.  We test for
+             this special case below.  */
+          filename = NULL;
+        }
+      else
+        {
+          if (__glibc_unlikely (pattern[0] == '\0'))
+            {
+              dirs.gl_pathv = NULL;
+              goto no_matches;
+            }
+
+          filename = pattern;
+          dirname = (char *) ".";
+          dirlen = 0;
+        }
+    }
+  else if (filename == pattern
+           || (filename == pattern + 1 && pattern[0] == '\\'
+               && (flags & GLOB_NOESCAPE) == 0))
+    {
+      /* "/pattern" or "\\/pattern".  */
+      dirname = (char *) "/";
+      dirlen = 1;
+      ++filename;
+    }
+  else
+    {
+      char *newp;
+      dirlen = filename - pattern;
+#if defined __MSDOS__ || defined WINDOWS32
+      if (*filename == ':'
+          || (filename > pattern + 1 && filename[-1] == ':'))
+        {
+          char *drive_spec;
+
+          ++dirlen;
+          drive_spec = __alloca (dirlen + 1);
+          *((char *) mempcpy (drive_spec, pattern, dirlen)) = '\0';
+          /* For now, disallow wildcards in the drive spec, to
+             prevent infinite recursion in glob.  */
+          if (__glob_pattern_p (drive_spec, !(flags & GLOB_NOESCAPE)))
+            return GLOB_NOMATCH;
+          /* If this is "d:pattern", we need to copy ':' to DIRNAME
+             as well.  If it's "d:/pattern", don't remove the slash
+             from "d:/", since "d:" and "d:/" are not the same.*/
+        }
+#endif
+
+      if (glob_use_alloca (alloca_used, dirlen + 1))
+        newp = alloca_account (dirlen + 1, alloca_used);
+      else
+        {
+          newp = malloc (dirlen + 1);
+          if (newp == NULL)
+            return GLOB_NOSPACE;
+          malloc_dirname = 1;
+        }
+      *((char *) mempcpy (newp, pattern, dirlen)) = '\0';
+      dirname = newp;
+      ++filename;
+
+#if defined __MSDOS__ || defined WINDOWS32
+      bool drive_root = (dirlen > 1
+                         && (dirname[dirlen - 1] == ':'
+                             || (dirlen > 2 && dirname[dirlen - 2] == ':'
+                                 && ISSLASH(dirname[dirlen - 1]) )));
+#else
+      bool drive_root = false;
+#endif
+
+      if (filename[0] == '\0' && dirlen > 1 && !drive_root)
+        /* "pattern/".  Expand "pattern", appending slashes.  */
+        {
+          int orig_flags = flags;
+          if (!(flags & GLOB_NOESCAPE) && ISSLASH(dirname[dirlen - 1]))
+            {
+              /* "pattern\\/".  Remove the final backslash if it hasn't
+                 been quoted.  */
+              char *p = (char *) &dirname[dirlen - 1];
+
+              while (p > dirname && p[-1] == '\\') --p;
+              if ((&dirname[dirlen] - p) & 1)
+                {
+                  *(char *) &dirname[--dirlen] = '\0';
+                  flags &= ~(GLOB_NOCHECK | GLOB_NOMAGIC);
+                }
+            }
+          int val = __glob (dirname, flags | GLOB_MARK, errfunc, pglob);
+          if (val == 0)
+            pglob->gl_flags = ((pglob->gl_flags & ~GLOB_MARK)
+                               | (flags & GLOB_MARK));
+          else if (val == GLOB_NOMATCH && flags != orig_flags)
+            {
+              /* Make sure globfree (&dirs); is a nop.  */
+              dirs.gl_pathv = NULL;
+              flags = orig_flags;
+              oldcount = pglob->gl_pathc + pglob->gl_offs;
+              goto no_matches;
+            }
+          retval = val;
+          goto out;
+        }
+    }
+
+  if ((flags & (GLOB_TILDE|GLOB_TILDE_CHECK)) && dirname[0] == '~')
+    {
+      if (dirname[1] == '\0' || ISSLASH(dirname[1])
+          || (!(flags & GLOB_NOESCAPE) && ISSLASH(dirname[1])
+              && (dirname[2] == '\0' || ISSLASH(dirname[2]))))
+        {
+          /* Look up home directory.  */
+          char *home_dir = getenv ("HOME");
+          int malloc_home_dir = 0;
+          if (home_dir == NULL || home_dir[0] == '\0')
+            {
+#ifdef WINDOWS32
+              /* Windows NT defines HOMEDRIVE and HOMEPATH.  But give
+                 preference to HOME, because the user can change HOME.  */
+              const char *home_drive = getenv ("HOMEDRIVE");
+              const char *home_path = getenv ("HOMEPATH");
+
+              if (home_drive != NULL && home_path != NULL)
+                {
+                  size_t home_drive_len = strlen (home_drive);
+                  size_t home_path_len = strlen (home_path);
+                  char *mem = alloca (home_drive_len + home_path_len + 1);
+
+                  memcpy (mem, home_drive, home_drive_len);
+                  memcpy (mem + home_drive_len, home_path, home_path_len + 1);
+                  home_dir = mem;
+                }
+              else
+                home_dir = "c:/users/default"; /* poor default */
+#else
+              int err;
+              struct passwd *p;
+              struct passwd pwbuf;
+              struct scratch_buffer s;
+              scratch_buffer_init (&s);
+              while (true)
+                {
+                  p = NULL;
+                  err = __getlogin_r (s.data, s.length);
+                  if (err == 0)
+                    {
+# if defined HAVE_GETPWNAM_R || defined _LIBC
+                      size_t ssize = strlen (s.data) + 1;
+                      char *sdata = s.data;
+                      err = getpwnam_r (sdata, &pwbuf, sdata + ssize,
+                                        s.length - ssize, &p);
+# else
+                      p = getpwnam (s.data);
+                      if (p == NULL)
+                        err = errno;
+# endif
+                    }
+                  if (err != ERANGE)
+                    break;
+                  if (!scratch_buffer_grow (&s))
+                    {
+                      retval = GLOB_NOSPACE;
+                      goto out;
+                    }
+                }
+              if (err == 0)
+                {
+                  home_dir = strdup (p->pw_dir);
+                  malloc_home_dir = 1;
+                }
+              scratch_buffer_free (&s);
+              if (err == 0 && home_dir == NULL)
+                {
+                  retval = GLOB_NOSPACE;
+                  goto out;
+                }
+#endif /* WINDOWS32 */
+            }
+          if (home_dir == NULL || home_dir[0] == '\0')
+            {
+              if (__glibc_unlikely (malloc_home_dir))
+                free (home_dir);
+              if (flags & GLOB_TILDE_CHECK)
+                {
+                  retval = GLOB_NOMATCH;
+                  goto out;
+                }
+              else
+                {
+                  home_dir = (char *) "~"; /* No luck.  */
+                  malloc_home_dir = 0;
+                }
+            }
+          /* Now construct the full directory.  */
+          if (dirname[1] == '\0')
+            {
+              if (__glibc_unlikely (malloc_dirname))
+                free (dirname);
+
+              dirname = home_dir;
+              dirlen = strlen (dirname);
+              malloc_dirname = malloc_home_dir;
+            }
+          else
+            {
+              char *newp;
+              size_t home_len = strlen (home_dir);
+              int use_alloca = glob_use_alloca (alloca_used, home_len + dirlen);
+              if (use_alloca)
+                newp = alloca_account (home_len + dirlen, alloca_used);
+              else
+                {
+                  newp = malloc (home_len + dirlen);
+                  if (newp == NULL)
+                    {
+                      if (__glibc_unlikely (malloc_home_dir))
+                        free (home_dir);
+                      retval = GLOB_NOSPACE;
+                      goto out;
+                    }
+                }
+
+              mempcpy (mempcpy (newp, home_dir, home_len),
+                       &dirname[1], dirlen);
+
+              if (__glibc_unlikely (malloc_dirname))
+                free (dirname);
+
+              dirname = newp;
+              dirlen += home_len - 1;
+              malloc_dirname = !use_alloca;
+
+              if (__glibc_unlikely (malloc_home_dir))
+                free (home_dir);
+            }
+          dirname_modified = 1;
+        }
+      else
+        {
+#ifndef WINDOWS32
+          /* Recognize ~user as a shorthand for the specified user's home
+             directory.  */
+          char *end_name = strpbrk(dirname, SLASHES);
+          char *user_name;
+          int malloc_user_name = 0;
+          char *unescape = NULL;
+
+          if (!(flags & GLOB_NOESCAPE))
+            {
+              if (end_name == NULL)
+                {
+                  unescape = strchr (dirname, '\\');
+                  if (unescape)
+                    end_name = strchr (unescape, '\0');
+                }
+              else
+                unescape = memchr (dirname, '\\', end_name - dirname);
+            }
+          if (end_name == NULL)
+            user_name = dirname + 1;
+          else
+            {
+              char *newp;
+              if (glob_use_alloca (alloca_used, end_name - dirname))
+                newp = alloca_account (end_name - dirname, alloca_used);
+              else
+                {
+                  newp = malloc (end_name - dirname);
+                  if (newp == NULL)
+                    {
+                      retval = GLOB_NOSPACE;
+                      goto out;
+                    }
+                  malloc_user_name = 1;
+                }
+              if (unescape != NULL)
+                {
+                  char *p = mempcpy (newp, dirname + 1,
+                                     unescape - dirname - 1);
+                  char *q = unescape;
+                  while (q != end_name)
+                    {
+                      if (*q == '\\')
+                        {
+                          if (q + 1 == end_name)
+                            {
+                              /* "~fo\\o\\" unescape to user_name "foo\\",
+                                 but "~fo\\o\\/" unescape to user_name
+                                 "foo".  */
+                              if (filename == NULL)
+                                *p++ = '\\';
+                              break;
+                            }
+                          ++q;
+                        }
+                      *p++ = *q++;
+                    }
+                  *p = '\0';
+                }
+              else
+                *((char *) mempcpy (newp, dirname + 1, end_name - dirname - 1))
+                  = '\0';
+              user_name = newp;
+            }
+
+          /* Look up specific user's home directory.  */
+          {
+            struct passwd *p;
+            struct scratch_buffer pwtmpbuf;
+            scratch_buffer_init (&pwtmpbuf);
+
+#  if defined HAVE_GETPWNAM_R || defined _LIBC
+            struct passwd pwbuf;
+
+            while (getpwnam_r (user_name, &pwbuf,
+                               pwtmpbuf.data, pwtmpbuf.length, &p)
+                   == ERANGE)
+              {
+                if (!scratch_buffer_grow (&pwtmpbuf))
+                  {
+                    retval = GLOB_NOSPACE;
+                    goto out;
+                  }
+              }
+#  else
+            p = getpwnam (user_name);
+#  endif
+
+            if (__glibc_unlikely (malloc_user_name))
+              free (user_name);
+
+            /* If we found a home directory use this.  */
+            if (p != NULL)
+              {
+                size_t home_len = strlen (p->pw_dir);
+                size_t rest_len = end_name == NULL ? 0 : strlen (end_name);
+                /* dirname contains end_name; we can't free it now.  */
+                char *prev_dirname =
+                  (__glibc_unlikely (malloc_dirname) ? dirname : NULL);
+                char *d;
+
+                malloc_dirname = 0;
+
+                if (glob_use_alloca (alloca_used, home_len + rest_len + 1))
+                  dirname = alloca_account (home_len + rest_len + 1,
+                                            alloca_used);
+                else
+                  {
+                    dirname = malloc (home_len + rest_len + 1);
+                    if (dirname == NULL)
+                      {
+                        free (prev_dirname);
+                        scratch_buffer_free (&pwtmpbuf);
+                        retval = GLOB_NOSPACE;
+                        goto out;
+                      }
+                    malloc_dirname = 1;
+                  }
+                d = mempcpy (dirname, p->pw_dir, home_len);
+                if (end_name != NULL)
+                  d = mempcpy (d, end_name, rest_len);
+                *d = '\0';
+
+                free (prev_dirname);
+
+                dirlen = home_len + rest_len;
+                dirname_modified = 1;
+              }
+            else
+              {
+                if (flags & GLOB_TILDE_CHECK)
+                  {
+                    /* We have to regard it as an error if we cannot find the
+                       home directory.  */
+                    retval = GLOB_NOMATCH;
+                    goto out;
+                  }
+              }
+            scratch_buffer_free (&pwtmpbuf);
+          }
+#else /* WINDOWS32 */
+          /* On native Windows, access to a user's home directory
+             (via GetUserProfileDirectory) or to a user's environment
+             variables (via ExpandEnvironmentStringsForUser) requires
+             the credentials of the user.  Therefore we cannot support
+             the ~user syntax on this platform.
+             Handling ~user specially (and treat it like plain ~) if
+             user is getenv ("USERNAME") would not be a good idea,
+             since it would make people think that ~user is supported
+             in general.  */
+          if (flags & GLOB_TILDE_CHECK)
+            {
+              retval = GLOB_NOMATCH;
+              goto out;
+            }
+#endif /* WINDOWS32 */
+        }
+    }
+
+  /* Now test whether we looked for "~" or "~NAME".  In this case we
+     can give the answer now.  */
+  if (filename == NULL)
+    {
+      size_t newcount = pglob->gl_pathc + pglob->gl_offs;
+      char **new_gl_pathv;
+
+      if (newcount > SIZE_MAX / sizeof (char *) - 2)
+        {
+        nospace:
+          free (pglob->gl_pathv);
+          pglob->gl_pathv = NULL;
+          pglob->gl_pathc = 0;
+          retval = GLOB_NOSPACE;
+          goto out;
+        }
+
+      new_gl_pathv = realloc (pglob->gl_pathv,
+                              (newcount + 2) * sizeof (char *));
+      if (new_gl_pathv == NULL)
+        goto nospace;
+      pglob->gl_pathv = new_gl_pathv;
+
+      if (flags & GLOB_MARK && is_dir (dirname, flags, pglob))
+        {
+          char *p;
+          pglob->gl_pathv[newcount] = malloc (dirlen + 2);
+          if (pglob->gl_pathv[newcount] == NULL)
+            goto nospace;
+          p = mempcpy (pglob->gl_pathv[newcount], dirname, dirlen);
+          p[0] = DIR_SEPARATOR;
+          p[1] = '\0';
+          if (__glibc_unlikely (malloc_dirname))
+            free (dirname);
+        }
+      else
+        {
+          if (__glibc_unlikely (malloc_dirname))
+            pglob->gl_pathv[newcount] = dirname;
+          else
+            {
+              pglob->gl_pathv[newcount] = strdup (dirname);
+              if (pglob->gl_pathv[newcount] == NULL)
+                goto nospace;
+            }
+        }
+      pglob->gl_pathv[++newcount] = NULL;
+      ++pglob->gl_pathc;
+      pglob->gl_flags = flags;
+
+      return 0;
+    }
+
+  meta = __glob_pattern_type (dirname, !(flags & GLOB_NOESCAPE));
+  /* meta is 1 if correct glob pattern containing metacharacters.
+     If meta has bit (1 << 2) set, it means there was an unterminated
+     [ which we handle the same, using fnmatch.  Broken unterminated
+     pattern bracket expressions ought to be rare enough that it is
+     not worth special casing them, fnmatch will do the right thing.  */
+  if (meta & (GLOBPAT_SPECIAL | GLOBPAT_BRACKET))
+    {
+      /* The directory name contains metacharacters, so we
+         have to glob for the directory, and then glob for
+         the pattern in each directory found.  */
+      size_t i;
+
+      if (!(flags & GLOB_NOESCAPE) && dirlen > 0 && dirname[dirlen - 1] == '\\')
+        {
+          /* "foo\\/bar".  Remove the final backslash from dirname
+             if it has not been quoted.  */
+          char *p = (char *) &dirname[dirlen - 1];
+
+          while (p > dirname && p[-1] == '\\') --p;
+          if ((&dirname[dirlen] - p) & 1)
+            *(char *) &dirname[--dirlen] = '\0';
+        }
+
+      if (__glibc_unlikely ((flags & GLOB_ALTDIRFUNC) != 0))
+        {
+          /* Use the alternative access functions also in the recursive
+             call.  */
+          dirs.gl_opendir = pglob->gl_opendir;
+          dirs.gl_readdir = pglob->gl_readdir;
+          dirs.gl_closedir = pglob->gl_closedir;
+          dirs.gl_stat = pglob->gl_stat;
+          dirs.gl_lstat = pglob->gl_lstat;
+        }
+
+      status = __glob (dirname,
+                       ((flags & (GLOB_ERR | GLOB_NOESCAPE | GLOB_ALTDIRFUNC))
+                        | GLOB_NOSORT | GLOB_ONLYDIR),
+                       errfunc, &dirs);
+      if (status != 0)
+        {
+          if ((flags & GLOB_NOCHECK) == 0 || status != GLOB_NOMATCH)
+            {
+              retval = status;
+              goto out;
+            }
+          goto no_matches;
+        }
+
+      /* We have successfully globbed the preceding directory name.
+         For each name we found, call glob_in_dir on it and FILENAME,
+         appending the results to PGLOB.  */
+      for (i = 0; i < dirs.gl_pathc; ++i)
+        {
+          size_t old_pathc;
+
+          old_pathc = pglob->gl_pathc;
+          status = glob_in_dir (filename, dirs.gl_pathv[i],
+                                ((flags | GLOB_APPEND)
+                                 & ~(GLOB_NOCHECK | GLOB_NOMAGIC)),
+                                errfunc, pglob, alloca_used);
+          if (status == GLOB_NOMATCH)
+            /* No matches in this directory.  Try the next.  */
+            continue;
+
+          if (status != 0)
+            {
+              globfree (&dirs);
+              globfree (pglob);
+              pglob->gl_pathc = 0;
+              retval = status;
+              goto out;
+            }
+
+          /* Stick the directory on the front of each name.  */
+          if (prefix_array (dirs.gl_pathv[i],
+                            &pglob->gl_pathv[old_pathc + pglob->gl_offs],
+                            pglob->gl_pathc - old_pathc))
+            {
+              globfree (&dirs);
+              globfree (pglob);
+              pglob->gl_pathc = 0;
+              retval = GLOB_NOSPACE;
+              goto out;
+            }
+        }
+
+      flags |= GLOB_MAGCHAR;
+
+      /* We have ignored the GLOB_NOCHECK flag in the 'glob_in_dir' calls.
+         But if we have not found any matching entry and the GLOB_NOCHECK
+         flag was set we must return the input pattern itself.  */
+      if (pglob->gl_pathc + pglob->gl_offs == oldcount)
+        {
+        no_matches:
+          /* No matches.  */
+          if (flags & GLOB_NOCHECK)
+            {
+              size_t newcount = pglob->gl_pathc + pglob->gl_offs;
+              char **new_gl_pathv;
+
+              if (newcount > SIZE_MAX / sizeof (char *) - 2)
+                {
+                nospace2:
+                  globfree (&dirs);
+                  retval = GLOB_NOSPACE;
+                  goto out;
+                }
+
+              new_gl_pathv = realloc (pglob->gl_pathv,
+                                      (newcount + 2) * sizeof (char *));
+              if (new_gl_pathv == NULL)
+                goto nospace2;
+              pglob->gl_pathv = new_gl_pathv;
+
+              pglob->gl_pathv[newcount] = strdup (pattern);
+              if (pglob->gl_pathv[newcount] == NULL)
+                {
+                  globfree (&dirs);
+                  globfree (pglob);
+                  pglob->gl_pathc = 0;
+                  retval = GLOB_NOSPACE;
+                  goto out;
+                }
+
+              ++pglob->gl_pathc;
+              ++newcount;
+
+              pglob->gl_pathv[newcount] = NULL;
+              pglob->gl_flags = flags;
+            }
+          else
+            {
+              globfree (&dirs);
+              retval = GLOB_NOMATCH;
+              goto out;
+            }
+        }
+
+      globfree (&dirs);
+    }
+  else
+    {
+      size_t old_pathc = pglob->gl_pathc;
+      int orig_flags = flags;
+
+      if (meta & GLOBPAT_BACKSLASH)
+        {
+          char *p = strchr (dirname, '\\'), *q;
+          /* We need to unescape the dirname string.  It is certainly
+             allocated by alloca, as otherwise filename would be NULL
+             or dirname wouldn't contain backslashes.  */
+          q = p;
+          do
+            {
+              if (*p == '\\')
+                {
+                  *q = *++p;
+                  --dirlen;
+                }
+              else
+                *q = *p;
+              ++q;
+            }
+          while (*p++ != '\0');
+          dirname_modified = 1;
+        }
+      if (dirname_modified)
+        flags &= ~(GLOB_NOCHECK | GLOB_NOMAGIC);
+      status = glob_in_dir (filename, dirname, flags, errfunc, pglob,
+                            alloca_used);
+      if (status != 0)
+        {
+          if (status == GLOB_NOMATCH && flags != orig_flags
+              && pglob->gl_pathc + pglob->gl_offs == oldcount)
+            {
+              /* Make sure globfree (&dirs); is a nop.  */
+              dirs.gl_pathv = NULL;
+              flags = orig_flags;
+              goto no_matches;
+            }
+          retval = status;
+          goto out;
+        }
+
+      if (dirlen > 0)
+        {
+          /* Stick the directory on the front of each name.  */
+          if (prefix_array (dirname,
+                            &pglob->gl_pathv[old_pathc + pglob->gl_offs],
+                            pglob->gl_pathc - old_pathc))
+            {
+              globfree (pglob);
+              pglob->gl_pathc = 0;
+              retval = GLOB_NOSPACE;
+              goto out;
+            }
+        }
+    }
+
+  if (flags & GLOB_MARK)
+    {
+      /* Append slashes to directory names.  */
+      size_t i;
+
+      for (i = oldcount; i < pglob->gl_pathc + pglob->gl_offs; ++i)
+        if (is_dir (pglob->gl_pathv[i], flags, pglob))
+          {
+            size_t len = strlen (pglob->gl_pathv[i]) + 2;
+            char *new = realloc (pglob->gl_pathv[i], len);
+            if (new == NULL)
+              {
+                globfree (pglob);
+                pglob->gl_pathc = 0;
+                retval = GLOB_NOSPACE;
+                goto out;
+              }
+            strcpy (&new[len - 2], "/");
+            pglob->gl_pathv[i] = new;
+          }
+    }
+
+  if (!(flags & GLOB_NOSORT))
+    {
+      /* Sort the vector.  */
+      qsort (&pglob->gl_pathv[oldcount],
+             pglob->gl_pathc + pglob->gl_offs - oldcount,
+             sizeof (char *), collated_compare);
+    }
+
+ out:
+  if (__glibc_unlikely (malloc_dirname))
+    free (dirname);
+
+  return retval;
+}
+#if defined _LIBC && !defined __glob
+versioned_symbol (libc, __glob, glob, GLIBC_2_27);
+libc_hidden_ver (__glob, glob)
+#endif
+
+
+/* Do a collated comparison of A and B.  */
+static int
+collated_compare (const void *a, const void *b)
+{
+  char *const *ps1 = a; char *s1 = *ps1;
+  char *const *ps2 = b; char *s2 = *ps2;
+
+  if (s1 == s2)
+    return 0;
+  if (s1 == NULL)
+    return 1;
+  if (s2 == NULL)
+    return -1;
+  return strcoll (s1, s2);
+}
+
+
+/* Prepend DIRNAME to each of N members of ARRAY, replacing ARRAY's
+   elements in place.  Return nonzero if out of memory, zero if successful.
+   A slash is inserted between DIRNAME and each elt of ARRAY,
+   unless DIRNAME is just "/".  Each old element of ARRAY is freed.  */
+static int
+prefix_array (const char *dirname, char **array, size_t n)
+{
+  size_t i;
+  size_t dirlen = strlen (dirname);
+  char dirsep_char = DIR_SEPARATOR;
+
+  if (dirlen == 1 && ISSLASH(dirname[0]) )
+    /* DIRNAME is just "/", so normal prepending would get us "//foo".
+       We want "/foo" instead, so don't prepend any chars from DIRNAME.  */
+    dirlen = 0;
+
+#if defined __MSDOS__ || defined WINDOWS32
+  if (dirlen > 1)
+    {
+      if (ISSLASH(dirname[dirlen - 1]) && dirname[dirlen - 2] == ':')
+        /* DIRNAME is "d:/".  Don't prepend the slash from DIRNAME.  */
+        --dirlen;
+      else if (dirname[dirlen - 1] == ':')
+        {
+          /* DIRNAME is "d:".  Use ':' instead of '/'.  */
+          --dirlen;
+          dirsep_char = ':';
+        }
+    }
+#endif
+
+  for (i = 0; i < n; ++i)
+    {
+      size_t eltlen = strlen (array[i]) + 1;
+      char *new = malloc (dirlen + 1 + eltlen);
+      if (new == NULL)
+        {
+          while (i > 0)
+            free (array[--i]);
+          return 1;
+        }
+
+      {
+        char *endp = mempcpy (new, dirname, dirlen);
+        *endp++ = dirsep_char;
+        mempcpy (endp, array[i], eltlen);
+      }
+      free (array[i]);
+      array[i] = new;
+    }
+
+  return 0;
+}
+
+/* Like 'glob', but PATTERN is a final pathname component,
+   and matches are searched for in DIRECTORY.
+   The GLOB_NOSORT bit in FLAGS is ignored.  No sorting is ever done.
+   The GLOB_APPEND flag is assumed to be set (always appends).  */
+static int
+glob_in_dir (const char *pattern, const char *directory, int flags,
+             int (*errfunc) (const char *, int),
+             glob_t *pglob, size_t alloca_used)
+{
+  size_t dirlen = strlen (directory);
+  void *stream = NULL;
+  struct scratch_buffer s;
+  scratch_buffer_init (&s);
+# define GLOBNAMES_MEMBERS(nnames) \
+    struct globnames *next; size_t count; char *name[nnames];
+  struct globnames { GLOBNAMES_MEMBERS (FLEXIBLE_ARRAY_MEMBER) };
+  struct { GLOBNAMES_MEMBERS (64) } init_names_buf;
+  struct globnames *init_names = (struct globnames *) &init_names_buf;
+  struct globnames *names = init_names;
+  struct globnames *names_alloca = init_names;
+  size_t nfound = 0;
+  size_t cur = 0;
+  int meta;
+  int save;
+  int result;
+
+  alloca_used += sizeof init_names_buf;
+
+  init_names->next = NULL;
+  init_names->count = ((sizeof init_names_buf
+                        - offsetof (struct globnames, name))
+                       / sizeof init_names->name[0]);
+
+  meta = __glob_pattern_type (pattern, !(flags & GLOB_NOESCAPE));
+  if (meta == GLOBPAT_NONE && (flags & (GLOB_NOCHECK|GLOB_NOMAGIC)))
+    {
+      /* We need not do any tests.  The PATTERN contains no meta
+         characters and we must not return an error therefore the
+         result will always contain exactly one name.  */
+      flags |= GLOB_NOCHECK;
+    }
+  else if (meta == GLOBPAT_NONE)
+    {
+      size_t patlen = strlen (pattern);
+      size_t fullsize;
+      bool alloca_fullname
+        = (! size_add_wrapv (dirlen + 1, patlen + 1, &fullsize)
+           && glob_use_alloca (alloca_used, fullsize));
+      char *fullname;
+      if (alloca_fullname)
+        fullname = alloca_account (fullsize, alloca_used);
+      else
+        {
+          fullname = malloc (fullsize);
+          if (fullname == NULL)
+            return GLOB_NOSPACE;
+        }
+
+      mempcpy (mempcpy (mempcpy (fullname, directory, dirlen),
+                        "/", 1),
+               pattern, patlen + 1);
+      if (glob_lstat (pglob, flags, fullname) == 0
+          || errno == EOVERFLOW)
+        /* We found this file to be existing.  Now tell the rest
+           of the function to copy this name into the result.  */
+        flags |= GLOB_NOCHECK;
+
+      if (__glibc_unlikely (!alloca_fullname))
+        free (fullname);
+    }
+  else
+    {
+      stream = (__builtin_expect (flags & GLOB_ALTDIRFUNC, 0)
+                ? (*pglob->gl_opendir) (directory)
+                : opendir (directory));
+      if (stream == NULL)
+        {
+          if (errno != ENOTDIR
+              && ((errfunc != NULL && (*errfunc) (directory, errno))
+                  || (flags & GLOB_ERR)))
+            return GLOB_ABORTED;
+        }
+      else
+        {
+          DIR *dirp = stream;
+          int dfd = dirfd (dirp);
+          int fnm_flags = ((!(flags & GLOB_PERIOD) ? FNM_PERIOD : 0)
+                           | ((flags & GLOB_NOESCAPE) ? FNM_NOESCAPE : 0));
+          flags |= GLOB_MAGCHAR;
+
+          while (1)
+            {
+              struct readdir_result d;
+              {
+                if (__builtin_expect (flags & GLOB_ALTDIRFUNC, 0))
+                  d = convert_dirent (GL_READDIR (pglob, stream));
+                else
+                  {
+#ifdef COMPILE_GLOB64
+                    d = convert_dirent (__readdir (stream));
+#else
+                    d = convert_dirent64 (__readdir64 (stream));
+#endif
+                  }
+              }
+              if (d.name == NULL)
+                break;
+
+              /* If we shall match only directories use the information
+                 provided by the dirent call if possible.  */
+              if (flags & GLOB_ONLYDIR)
+                switch (readdir_result_type (d))
+                  {
+                  default: continue;
+                  case DT_DIR: break;
+                  case DT_LNK: case DT_UNKNOWN:
+                    /* The filesystem was too lazy to give us a hint,
+                       so we have to do it the hard way.  */
+                    if (__glibc_unlikely (dfd < 0 || flags & GLOB_ALTDIRFUNC))
+                      {
+                        size_t namelen = strlen (d.name);
+                        size_t need = dirlen + 1 + namelen + 1;
+                        if (s.length < need
+                            && !scratch_buffer_set_array_size (&s, need, 1))
+                          goto memory_error;
+                        char *p = mempcpy (s.data, directory, dirlen);
+                        *p = DIR_SEPARATOR;
+                        p += ISSLASH(p[-1]);
+                        memcpy (p, d.name, namelen + 1);
+                        if (! is_dir (s.data, flags, pglob))
+                          continue;
+                      }
+                    else
+                      {
+                        struct_stat64 st64;
+                        if (! (GLOB_FSTATAT64 (dfd, d.name, &st64, 0) == 0
+                               && S_ISDIR (st64.st_mode)))
+                          continue;
+                      }
+                  }
+
+              if (fnmatch (pattern, d.name, fnm_flags) == 0)
+                {
+                  if (cur == names->count)
+                    {
+                      struct globnames *newnames;
+                      size_t count = names->count * 2;
+                      size_t nameoff = offsetof (struct globnames, name);
+                      size_t size = FLEXSIZEOF (struct globnames, name,
+                                                count * sizeof (char *));
+                      if ((SIZE_MAX - nameoff) / 2 / sizeof (char *)
+                          < names->count)
+                        goto memory_error;
+                      if (glob_use_alloca (alloca_used, size))
+                        newnames = names_alloca
+                          = alloca_account (size, alloca_used);
+                      else if ((newnames = malloc (size))
+                               == NULL)
+                        goto memory_error;
+                      newnames->count = count;
+                      newnames->next = names;
+                      names = newnames;
+                      cur = 0;
+                    }
+                  names->name[cur] = strdup (d.name);
+                  if (names->name[cur] == NULL)
+                    goto memory_error;
+                  ++cur;
+                  ++nfound;
+                  if (SIZE_MAX - pglob->gl_offs <= nfound)
+                    goto memory_error;
+                }
+            }
+        }
+    }
+
+  if (nfound == 0 && (flags & GLOB_NOCHECK))
+    {
+      size_t len = strlen (pattern);
+      nfound = 1;
+      names->name[cur] = malloc (len + 1);
+      if (names->name[cur] == NULL)
+        goto memory_error;
+      *((char *) mempcpy (names->name[cur++], pattern, len)) = '\0';
+    }
+
+  result = GLOB_NOMATCH;
+  if (nfound != 0)
+    {
+      char **new_gl_pathv;
+      result = 0;
+
+      if (SIZE_MAX / sizeof (char *) - pglob->gl_pathc
+          < pglob->gl_offs + nfound + 1)
+        goto memory_error;
+
+      new_gl_pathv
+        = realloc (pglob->gl_pathv,
+                   (pglob->gl_pathc + pglob->gl_offs + nfound + 1)
+                    * sizeof (char *));
+
+      if (new_gl_pathv == NULL)
+        {
+        memory_error:
+          while (1)
+            {
+              struct globnames *old = names;
+              for (size_t i = 0; i < cur; ++i)
+                free (names->name[i]);
+              names = names->next;
+              /* NB: we will not leak memory here if we exit without
+                 freeing the current block assigned to OLD.  At least
+                 the very first block is always allocated on the stack
+                 and this is the block assigned to OLD here.  */
+              if (names == NULL)
+                {
+                  assert (old == init_names);
+                  break;
+                }
+              cur = names->count;
+              if (old == names_alloca)
+                names_alloca = names;
+              else
+                free (old);
+            }
+          result = GLOB_NOSPACE;
+        }
+      else
+        {
+          while (1)
+            {
+              struct globnames *old = names;
+              for (size_t i = 0; i < cur; ++i)
+                new_gl_pathv[pglob->gl_offs + pglob->gl_pathc++]
+                  = names->name[i];
+              names = names->next;
+              /* NB: we will not leak memory here if we exit without
+                 freeing the current block assigned to OLD.  At least
+                 the very first block is always allocated on the stack
+                 and this is the block assigned to OLD here.  */
+              if (names == NULL)
+                {
+                  assert (old == init_names);
+                  break;
+                }
+              cur = names->count;
+              if (old == names_alloca)
+                names_alloca = names;
+              else
+                free (old);
+            }
+
+          pglob->gl_pathv = new_gl_pathv;
+
+          pglob->gl_pathv[pglob->gl_offs + pglob->gl_pathc] = NULL;
+
+          pglob->gl_flags = flags;
+        }
+    }
+
+  if (stream != NULL)
+    {
+      save = errno;
+      if (__glibc_unlikely (flags & GLOB_ALTDIRFUNC))
+        (*pglob->gl_closedir) (stream);
+      else
+        closedir (stream);
+      __set_errno (save);
+    }
+
+  scratch_buffer_free (&s);
+  return result;
+}
diff --git a/lib/lchmod.c b/lib/lchmod.c
index b2d1b8bfde..b2baf00db2 100644
--- a/lib/lchmod.c
+++ b/lib/lchmod.c
@@ -29,6 +29,7 @@
 #include <unistd.h>
 
 #include <intprops.h>
+#include "filename.h"
 
 /* Work like chmod, except when FILE is a symbolic link.
    In that case, on systems where permissions on symbolic links are unsupported
@@ -69,7 +70,7 @@ lchmod (char const *file, mode_t mode)
 #endif
 
   size_t len = strlen (file);
-  if (len && file[len - 1] == '/')
+  if (len && ISSLASH(file[len - 1]) )
     {
       struct stat st;
       if (lstat (file, &st) < 0)
diff --git a/lib/lchown.c b/lib/lchown.c
index 19a68c052b..2d5e3f3f13 100644
--- a/lib/lchown.c
+++ b/lib/lchown.c
@@ -25,6 +25,7 @@
 #include <errno.h>
 #include <string.h>
 #include <sys/stat.h>
+#include "filename.h"
 
 #if !HAVE_LCHOWN
 
@@ -89,7 +90,7 @@ rpl_lchown (const char *file, uid_t uid, gid_t gid)
   if (!stat_valid)
     {
       size_t len = strlen (file);
-      if (len && file[len - 1] == '/')
+      if (len && ISSLASH(file[len - 1]))
         return chown (file, uid, gid);
     }
 # endif
diff --git a/lib/link.c b/lib/link.c
index 2c81e2f2e3..7d32708870 100644
--- a/lib/link.c
+++ b/lib/link.c
@@ -23,6 +23,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <sys/stat.h>
+#include "filename.h"
 
 #if !HAVE_LINK
 # if defined _WIN32 && ! defined __CYGWIN__
@@ -87,8 +88,8 @@ link (const char *file1, const char *file2)
     }
   /* Reject trailing slashes on non-directories; native Windows does not
      support hard-linking directories.  */
-  if ((len1 && (file1[len1 - 1] == '/' || file1[len1 - 1] == '\\'))
-      || (len2 && (file2[len2 - 1] == '/' || file2[len2 - 1] == '\\')))
+  if ((len1 && ISSLASH(file1[len1 - 1]))
+      || (len2 && ISSLASH(file2[len2 - 1])))
     {
       /* If stat() fails, then link() should fail for the same reason.  */
       struct stat st;
@@ -113,7 +114,7 @@ link (const char *file1, const char *file2)
   {
     struct stat st;
     char *p = strchr (dir, '\0');
-    while (dir < p && (*--p != '/' && *p != '\\'));
+    while (dir < p && ISSLASH(*--p));
     *p = '\0';
     if (p != dir && stat (dir, &st) != 0 && errno != EOVERFLOW)
       {
@@ -196,8 +197,8 @@ rpl_link (char const *file1, char const *file2)
   /* Reject trailing slashes on non-directories.  */
   len1 = strlen (file1);
   len2 = strlen (file2);
-  if ((len1 && file1[len1 - 1] == '/')
-      || (len2 && file2[len2 - 1] == '/'))
+  if ((len1 && ISSLASH(file1[len1 - 1]))
+      || (len2 && ISSLASH(file2[len2 - 1])))
     {
       /* Let link() decide whether hard-linking directories is legal.
          If stat() fails, then link() should fail for the same reason
@@ -220,7 +221,7 @@ rpl_link (char const *file1, char const *file2)
         return -1;
       /* We already know file2 does not end in slash.  Strip off the
          basename, then check that the dirname exists.  */
-      p = strrchr (dir, '/');
+      p = LAST_SLASH_IN_PATH(dir);
       if (p)
         {
           *p = '\0';
diff --git a/lib/linkat.c b/lib/linkat.c
index 3d1ee3962f..ec3f3a483c 100644
--- a/lib/linkat.c
+++ b/lib/linkat.c
@@ -32,6 +32,7 @@
 #include "eloop-threshold.h"
 #include "filenamecat.h"
 #include "openat-priv.h"
+#include "filename.h"
 
 #if !HAVE_LINKAT || LINKAT_SYMLINK_NOTSUP
 
@@ -278,8 +279,8 @@ rpl_linkat (int fd1, char const *file1, int fd2, char const *file2, int flag)
   {
     size_t len1 = strlen (file1);
     size_t len2 = strlen (file2);
-    if ((len1 && file1[len1 - 1] == '/')
-        || (len2 && file2[len2 - 1] == '/'))
+    if ((len1 && ISSLASH(file1[len1 - 1]) )
+        || (len2 && ISSLASH(file2[len2 - 1])))
       {
         /* Let linkat() decide whether hard-linking directories is legal.
            If fstatat() fails, then linkat() should fail for the same reason;
diff --git a/lib/lstat.c b/lib/lstat.c
index 00a4ce2ab8..20747ea6f7 100644
--- a/lib/lstat.c
+++ b/lib/lstat.c
@@ -22,7 +22,7 @@
    rpl_lstat.  */
 #define __need_system_sys_stat_h
 #include <config.h>
-
+#include "filename.h"
 #if !HAVE_LSTAT
 /* On systems that lack symlinks, our replacement <sys/stat.h> already
    defined lstat as stat, so there is nothing further to do other than
@@ -81,7 +81,7 @@ rpl_lstat (const char *file, struct stat *sbuf)
      out above, with a failure return of ENOENT.  */
   if (result == 0)
     {
-      if (S_ISDIR (sbuf->st_mode) || file[strlen (file) - 1] != '/')
+      if (S_ISDIR (sbuf->st_mode) || ISSLASH(file[strlen (file) - 1]))
         result = stat_time_normalize (result, sbuf);
       else
         {
diff --git a/lib/mkfifo.c b/lib/mkfifo.c
index 5ad81030e8..18b5eb3e05 100644
--- a/lib/mkfifo.c
+++ b/lib/mkfifo.c
@@ -22,6 +22,7 @@
 
 #include <errno.h>
 #include <string.h>
+#include "filename.h"
 
 #if !HAVE_MKFIFO
 /* Mingw lacks mkfifo; always fail with ENOSYS.  */
@@ -45,7 +46,7 @@ rpl_mkfifo (char const *name, mode_t mode)
 {
 # if MKFIFO_TRAILING_SLASH_BUG
   size_t len = strlen (name);
-  if (len && name[len - 1] == '/')
+  if (len && ISSLASH(name[len - 1]) )
     {
       struct stat st;
       if (stat (name, &st) == 0 || errno == EOVERFLOW)
diff --git a/lib/mkfifoat.c b/lib/mkfifoat.c
index 23243e8cf8..fbd1e78654 100644
--- a/lib/mkfifoat.c
+++ b/lib/mkfifoat.c
@@ -22,6 +22,7 @@
 #include <sys/stat.h>
 
 #include <stdlib.h>
+#include "filename.h"
 
 #if HAVE_MKFIFOAT
 
@@ -35,7 +36,7 @@ rpl_mkfifoat (int fd, char const *file, mode_t mode)
 {
   /* Use the original mkfifoat(), but correct the trailing slash handling.  */
   size_t len = strlen (file);
-  if (len && file[len - 1] == '/')
+  if (len && ISSLASH(file[len - 1]) )
     {
       struct stat st;
 
diff --git a/lib/mknodat.c b/lib/mknodat.c
index 3ed38e159c..1d28dc29a7 100644
--- a/lib/mknodat.c
+++ b/lib/mknodat.c
@@ -22,6 +22,7 @@
 #include <sys/stat.h>
 
 #include <stdlib.h>
+#include "filename.h"
 
 #if HAVE_MKNODAT
 
@@ -35,7 +36,7 @@ rpl_mknodat (int fd, char const *file, mode_t mode, dev_t dev)
 {
   /* Use the original mknodat(), but correct the trailing slash handling.  */
   size_t len = strlen (file);
-  if (len && file[len - 1] == '/')
+  if (len && ISSLASH(file[len - 1]) )
     {
       struct stat st;
 
diff --git a/lib/mountlist.c b/lib/mountlist.c
index 6d38481284..37b330e072 100644
--- a/lib/mountlist.c
+++ b/lib/mountlist.c
@@ -30,7 +30,7 @@
 #include <errno.h>
 
 #include <fcntl.h>
-
+#include "filename.h"
 #include <unistd.h>
 
 #if HAVE_SYS_PARAM_H
@@ -697,7 +697,7 @@ read_file_system_list (bool need_fs_type)
             else
               {
                 name = xmalloc (1 + strlen (d->d_name) + 1);
-                name[0] = '/';
+                name[0] = DIR_SEPARATOR;
                 strcpy (name + 1, d->d_name);
               }
 
diff --git a/lib/open.c b/lib/open.c
index 7ec8fdc35d..092e0cd1a4 100644
--- a/lib/open.c
+++ b/lib/open.c
@@ -21,7 +21,7 @@
    rpl_open.  */
 #define __need_system_fcntl_h
 #include <config.h>
-
+#include "filename.h"
 /* Get the original definition of open.  It might be defined as a macro.  */
 #include <fcntl.h>
 #include <sys/types.h>
@@ -30,11 +30,23 @@
 static int
 orig_open (const char *filename, int flags, mode_t mode)
 {
+	int fd;
 #if defined _WIN32 && !defined __CYGWIN__
-  return _open (filename, flags, mode);
+  fd = _open (filename, flags, mode);
 #else
-  return open (filename, flags, mode);
+  fd = open (filename, flags, mode);
+#endif
+#if defined _WIN32
+  if (fd < 0 && errno == ENOENT && strlen(filename) > 1 && ISSLASH(filename[strlen(filename) - 1]) ) {   ///so windows is odd it doesn't like \ at the end of a path (https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-findfirstfilea see end in a trailing \)  it returns errno=2 ENOENT however while it also doesn't like a path ending in / it returns errno=13 EACCES for this (which the below then fixes)
+	  struct _stat buf;
+	  int result = _stat(filename, &buf);
+	  if (result != 0 || (buf.st_mode & _S_IFDIR) != _S_IFDIR)
+		  _set_errno(ENOENT);
+	  else
+		  _set_errno(EACCES);
+  }
 #endif
+  return fd;
 }
 
 /* Specification.  */
@@ -119,7 +131,7 @@ open (const char *filename, int flags, ...)
       || (flags & O_ACCMODE) == O_WRONLY)
     {
       size_t len = strlen (filename);
-      if (len > 0 && filename[len - 1] == '/')
+      if (len > 0 &&  ISSLASH(filename[len - 1]))
         {
           errno = EISDIR;
           return -1;
@@ -186,7 +198,7 @@ open (const char *filename, int flags, ...)
     {
       /* We know len is positive, since open did not fail with ENOENT.  */
       size_t len = strlen (filename);
-      if (filename[len - 1] == '/')
+      if (ISSLASH( filename[len - 1]) )
         {
           struct stat statbuf;
 
diff --git a/lib/openat-proc.c b/lib/openat-proc.c
index 88f70be4f5..be8376bf53 100644
--- a/lib/openat-proc.c
+++ b/lib/openat-proc.c
@@ -1,154 +1,155 @@
-/* Create /proc/self/fd-related names for subfiles of open directories.
-
-   Copyright (C) 2006, 2009-2023 Free Software Foundation, Inc.
-
-   This program is free software: you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation, either version 3 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
-
-/* Written by Paul Eggert.  */
-
-#include <config.h>
-
-#include "openat-priv.h"
-
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-
-#ifdef __KLIBC__ /* OS/2 */
-# include <InnoTekLIBC/backend.h>
-#endif
-#ifdef __MVS__ /* z/OS */
-# include <termios.h>
-#endif
-
-#include "intprops.h"
-
-/* Set BUF to the name of the subfile of the directory identified by
-   FD, where the subfile is named FILE.  If successful, return BUF if
-   the result fits in BUF, dynamically allocated memory otherwise.
-   Return NULL (setting errno) on error.  */
-char *
-openat_proc_name (char buf[OPENAT_BUFFER_SIZE], int fd, char const *file)
-{
-  char *result = buf;
-  int dirlen;
-
-  /* Make sure the caller gets ENOENT when appropriate.  */
-  if (!*file)
-    {
-      buf[0] = '\0';
-      return buf;
-    }
-
-#if !(defined __KLIBC__ || defined __MVS__)
-  /* Generic code for Linux, Solaris, and similar platforms.  */
-# define PROC_SELF_FD_FORMAT "/proc/self/fd/%d/"
-  {
-    enum {
-      PROC_SELF_FD_DIR_SIZE_BOUND
-        = (sizeof PROC_SELF_FD_FORMAT - (sizeof "%d" - 1)
-           + INT_STRLEN_BOUND (int))
-    };
-
-    static int proc_status = 0;
-    if (! proc_status)
-      {
-        /* Set PROC_STATUS to a positive value if /proc/self/fd is
-           reliable, and a negative value otherwise.  Solaris 10
-           /proc/self/fd mishandles "..", and any file name might expand
-           to ".." after symbolic link expansion, so avoid /proc/self/fd
-           if it mishandles "..".  Solaris 10 has openat, but this
-           problem is exhibited on code that built on Solaris 8 and
-           running on Solaris 10.  */
-
-        int proc_self_fd =
-          open ("/proc/self/fd",
-                O_SEARCH | O_DIRECTORY | O_NOCTTY | O_NONBLOCK | O_CLOEXEC);
-        if (proc_self_fd < 0)
-          proc_status = -1;
-        else
-          {
-            /* Detect whether /proc/self/fd/%i/../fd exists, where %i is the
-               number of a file descriptor open on /proc/self/fd.  On Linux,
-               that name resolves to /proc/self/fd, which was opened above.
-               However, on Solaris, it may resolve to /proc/self/fd/fd, which
-               cannot exist, since all names in /proc/self/fd are numeric.  */
-            char dotdot_buf[PROC_SELF_FD_DIR_SIZE_BOUND + sizeof "../fd" - 1];
-            sprintf (dotdot_buf, PROC_SELF_FD_FORMAT "../fd", proc_self_fd);
-            proc_status = access (dotdot_buf, F_OK) ? -1 : 1;
-            close (proc_self_fd);
-          }
-      }
-
-    if (proc_status < 0)
-      return NULL;
-    else
-      {
-        size_t bufsize = PROC_SELF_FD_DIR_SIZE_BOUND + strlen (file);
-        if (OPENAT_BUFFER_SIZE < bufsize)
-          {
-            result = malloc (bufsize);
-            if (! result)
-              return NULL;
-          }
-
-        dirlen = sprintf (result, PROC_SELF_FD_FORMAT, fd);
-      }
-  }
-#else /* (defined __KLIBC__ || defined __MVS__), i.e. OS/2 or z/OS */
-  /* OS/2 kLIBC provides a function to retrieve a path from a fd.  */
-  {
-    size_t bufsize;
-
-# ifdef __KLIBC__
-    char dir[_MAX_PATH];
-    if (__libc_Back_ioFHToPath (fd, dir, sizeof dir))
-      return NULL;
-# endif
-# ifdef __MVS__
-    char dir[_XOPEN_PATH_MAX];
-    /* Documentation:
-       https://www.ibm.com/docs/en/zos/2.2.0?topic=functions-w-ioctl-w-pioctl-control-devices */
-    if (w_ioctl (fd, _IOCC_GPN, sizeof dir, dir) < 0)
-      return NULL;
-    /* Documentation:
-       https://www.ibm.com/docs/en/zos/2.2.0?topic=functions-e2a-l-convert-characters-from-ebcdic-ascii */
-    dirlen = __e2a_l (dir, strlen (dir));
-    if (dirlen < 0 || dirlen >= sizeof dir)
-      return NULL;
-    dir[dirlen] = '\0';
-# endif
-
-    dirlen = strlen (dir);
-    bufsize = dirlen + 1 + strlen (file) + 1; /* 1 for '/', 1 for null */
-    if (OPENAT_BUFFER_SIZE < bufsize)
-      {
-        result = malloc (bufsize);
-        if (! result)
-          return NULL;
-      }
-
-    strcpy (result, dir);
-    result[dirlen++] = '/';
-  }
-#endif
-
-  strcpy (result + dirlen, file);
-  return result;
-}
+/* Create /proc/self/fd-related names for subfiles of open directories.
+
+   Copyright (C) 2006, 2009-2023 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* Written by Paul Eggert.  */
+
+#include <config.h>
+
+#include "openat-priv.h"
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#ifdef __KLIBC__ /* OS/2 */
+# include <InnoTekLIBC/backend.h>
+#endif
+#ifdef __MVS__ /* z/OS */
+# include <termios.h>
+#endif
+
+#include "intprops.h"
+#include "filename.h"
+
+/* Set BUF to the name of the subfile of the directory identified by
+   FD, where the subfile is named FILE.  If successful, return BUF if
+   the result fits in BUF, dynamically allocated memory otherwise.
+   Return NULL (setting errno) on error.  */
+char *
+openat_proc_name (char buf[OPENAT_BUFFER_SIZE], int fd, char const *file)
+{
+  char *result = buf;
+  int dirlen;
+
+  /* Make sure the caller gets ENOENT when appropriate.  */
+  if (!*file)
+    {
+      buf[0] = '\0';
+      return buf;
+    }
+
+#if !(defined __KLIBC__ || defined __MVS__)
+  /* Generic code for Linux, Solaris, and similar platforms.  */
+# define PROC_SELF_FD_FORMAT "/proc/self/fd/%d/"
+  {
+    enum {
+      PROC_SELF_FD_DIR_SIZE_BOUND
+        = (sizeof PROC_SELF_FD_FORMAT - (sizeof "%d" - 1)
+           + INT_STRLEN_BOUND (int))
+    };
+
+    static int proc_status = 0;
+    if (! proc_status)
+      {
+        /* Set PROC_STATUS to a positive value if /proc/self/fd is
+           reliable, and a negative value otherwise.  Solaris 10
+           /proc/self/fd mishandles "..", and any file name might expand
+           to ".." after symbolic link expansion, so avoid /proc/self/fd
+           if it mishandles "..".  Solaris 10 has openat, but this
+           problem is exhibited on code that built on Solaris 8 and
+           running on Solaris 10.  */
+
+        int proc_self_fd =
+          open ("/proc/self/fd",
+                O_SEARCH | O_DIRECTORY | O_NOCTTY | O_NONBLOCK | O_CLOEXEC);
+        if (proc_self_fd < 0)
+          proc_status = -1;
+        else
+          {
+            /* Detect whether /proc/self/fd/%i/../fd exists, where %i is the
+               number of a file descriptor open on /proc/self/fd.  On Linux,
+               that name resolves to /proc/self/fd, which was opened above.
+               However, on Solaris, it may resolve to /proc/self/fd/fd, which
+               cannot exist, since all names in /proc/self/fd are numeric.  */
+            char dotdot_buf[PROC_SELF_FD_DIR_SIZE_BOUND + sizeof "../fd" - 1];
+            sprintf (dotdot_buf, PROC_SELF_FD_FORMAT "../fd", proc_self_fd);
+            proc_status = access (dotdot_buf, F_OK) ? -1 : 1;
+            close (proc_self_fd);
+          }
+      }
+
+    if (proc_status < 0)
+      return NULL;
+    else
+      {
+        size_t bufsize = PROC_SELF_FD_DIR_SIZE_BOUND + strlen (file);
+        if (OPENAT_BUFFER_SIZE < bufsize)
+          {
+            result = malloc (bufsize);
+            if (! result)
+              return NULL;
+          }
+
+        dirlen = sprintf (result, PROC_SELF_FD_FORMAT, fd);
+      }
+  }
+#else /* (defined __KLIBC__ || defined __MVS__), i.e. OS/2 or z/OS */
+  /* OS/2 kLIBC provides a function to retrieve a path from a fd.  */
+  {
+    size_t bufsize;
+
+# ifdef __KLIBC__
+    char dir[_MAX_PATH];
+    if (__libc_Back_ioFHToPath (fd, dir, sizeof dir))
+      return NULL;
+# endif
+# ifdef __MVS__
+    char dir[_XOPEN_PATH_MAX];
+    /* Documentation:
+       https://www.ibm.com/docs/en/zos/2.2.0?topic=functions-w-ioctl-w-pioctl-control-devices */
+    if (w_ioctl (fd, _IOCC_GPN, sizeof dir, dir) < 0)
+      return NULL;
+    /* Documentation:
+       https://www.ibm.com/docs/en/zos/2.2.0?topic=functions-e2a-l-convert-characters-from-ebcdic-ascii */
+    dirlen = __e2a_l (dir, strlen (dir));
+    if (dirlen < 0 || dirlen >= sizeof dir)
+      return NULL;
+    dir[dirlen] = '\0';
+# endif
+
+    dirlen = strlen (dir);
+    bufsize = dirlen + 1 + strlen (file) + 1; /* 1 for '/', 1 for null */
+    if (OPENAT_BUFFER_SIZE < bufsize)
+      {
+        result = malloc (bufsize);
+        if (! result)
+          return NULL;
+      }
+
+    strcpy (result, dir);
+    result[dirlen++] = DIR_SEPARATOR;
+  }
+#endif
+
+  strcpy (result + dirlen, file);
+  return result;
+}
diff --git a/lib/openat.c b/lib/openat.c
index f28b10e138..b62e1c9c6c 100644
--- a/lib/openat.c
+++ b/lib/openat.c
@@ -104,7 +104,7 @@ rpl_openat (int dfd, char const *filename, int flags, ...)
       || (flags & O_ACCMODE) == O_WRONLY)
     {
       size_t len = strlen (filename);
-      if (len > 0 && filename[len - 1] == '/')
+      if (len > 0 && ISSLASH(filename[len - 1]))
         {
           errno = EISDIR;
           return -1;
@@ -147,7 +147,7 @@ rpl_openat (int dfd, char const *filename, int flags, ...)
     {
       /* We know len is positive, since open did not fail with ENOENT.  */
       size_t len = strlen (filename);
-      if (filename[len - 1] == '/')
+      if ( ISSLASH(filename[len - 1]) )
         {
           struct stat statbuf;
 
diff --git a/lib/progname.c b/lib/progname.c
index ed928e04e9..4ada400f56 100644
--- a/lib/progname.c
+++ b/lib/progname.c
@@ -21,7 +21,7 @@
 /* Specification.  */
 #undef ENABLE_RELOCATABLE /* avoid defining set_program_name as a macro */
 #include "progname.h"
-
+#include "filename.h"
 #include <errno.h> /* get program_invocation_name declaration */
 #include <stdio.h>
 #include <stdlib.h>
@@ -56,7 +56,7 @@ set_program_name (const char *argv0)
       abort ();
     }
 
-  slash = strrchr (argv0, '/');
+  slash = LAST_SLASH_IN_PATH(argv0);
   base = (slash != NULL ? slash + 1 : argv0);
   if (base - argv0 >= 7 && strncmp (base - 7, "/.libs/", 7) == 0)
     {
diff --git a/lib/progreloc.c b/lib/progreloc.c
index 30b1f759b6..b89413c7b1 100644
--- a/lib/progreloc.c
+++ b/lib/progreloc.c
@@ -50,6 +50,7 @@
 #endif
 
 #include "relocatable.h"
+#include "filename.h"
 
 #ifdef NO_XMALLOC
 # include "areadlink.h"
@@ -85,25 +86,6 @@ extern char * canonicalize_file_name (const char *name);
 # define GetModuleFileName GetModuleFileNameA
 #endif
 
-/* Pathname support.
-   ISSLASH(C)                tests whether C is a directory separator character.
-   IS_FILE_NAME_WITH_DIR(P)  tests whether P contains a directory specification.
- */
-#if (defined _WIN32 && !defined __CYGWIN__) || defined __EMX__ || defined __DJGPP__
-  /* Native Windows, OS/2, DOS */
-# define ISSLASH(C) ((C) == '/' || (C) == '\\')
-# define HAS_DEVICE(P) \
-    ((((P)[0] >= 'A' && (P)[0] <= 'Z') || ((P)[0] >= 'a' && (P)[0] <= 'z')) \
-     && (P)[1] == ':')
-# define IS_FILE_NAME_WITH_DIR(P) \
-    (strchr (P, '/') != NULL || strchr (P, '\\') != NULL || HAS_DEVICE (P))
-# define FILE_SYSTEM_PREFIX_LEN(P) (HAS_DEVICE (P) ? 2 : 0)
-#else
-  /* Unix */
-# define ISSLASH(C) ((C) == '/')
-# define IS_FILE_NAME_WITH_DIR(P) (strchr (P, '/') != NULL)
-# define FILE_SYSTEM_PREFIX_LEN(P) 0
-#endif
 
 /* Use the system functions, not the gnulib overrides in this file.  */
 #undef sprintf
@@ -341,7 +323,7 @@ find_executable (const char *argv0)
   char location[4096];
   unsigned int length = sizeof (location);
   if (_NSGetExecutablePath (location, &length) == 0
-      && location[0] == '/')
+      && ISSLASH(location[0]) )
     return canonicalize_file_name (location);
 # endif
   /* Guess the executable's full path.  We assume the executable has been
@@ -352,7 +334,7 @@ find_executable (const char *argv0)
     {
       const char *p;
       for (p = argv0; *p; p++)
-        if (*p == '/')
+        if (ISSLASH(*p) )
           {
             has_slash = true;
             break;
@@ -394,7 +376,7 @@ find_executable (const char *argv0)
                 else
                   {
                     memcpy (concat_name, p, p_len);
-                    concat_name[p_len] = '/';
+                    concat_name[p_len] = DIR_SEPARATOR;
                     strcpy (concat_name + p_len + 1, argv0);
                   }
                 if (maybe_executable (concat_name))
diff --git a/lib/readlinkat.c b/lib/readlinkat.c
index 7738ba8bfd..58bc4ddfcf 100644
--- a/lib/readlinkat.c
+++ b/lib/readlinkat.c
@@ -20,7 +20,7 @@
 
 /* Specification.  */
 #include <unistd.h>
-
+#include "filename.h"
 #include <errno.h>
 #include <stdlib.h>
 #include <string.h>
@@ -36,7 +36,7 @@ rpl_readlinkat (int fd, char const *file, char *buf, size_t bufsize)
 {
 # if READLINK_TRAILING_SLASH_BUG
   size_t file_len = strlen (file);
-  if (file_len && file[file_len - 1] == '/')
+  if (file_len && ISSLASH(file[file_len - 1]) )
     {
       /* Even if FILE without the slash is a symlink to a directory,
          both lstat() and stat() must resolve the trailing slash to
diff --git a/lib/relocatable.c b/lib/relocatable.c
index ac12c6da39..0ab43497be 100644
--- a/lib/relocatable.c
+++ b/lib/relocatable.c
@@ -25,7 +25,7 @@
 
 #define _GL_USE_STDLIB_ALLOC 1
 #include <config.h>
-
+#include "filename.h"
 /* Specification.  */
 #include "relocatable.h"
 
@@ -79,24 +79,6 @@
 #define false 0
 #define true 1
 
-/* Pathname support.
-   ISSLASH(C)                tests whether C is a directory separator character.
-   IS_FILE_NAME_WITH_DIR(P)  tests whether P contains a directory specification.
- */
-#if (defined _WIN32 && !defined __CYGWIN__) || defined __EMX__ || defined __DJGPP__
-  /* Native Windows, OS/2, DOS */
-# define ISSLASH(C) ((C) == '/' || (C) == '\\')
-# define HAS_DEVICE(P) \
-    ((((P)[0] >= 'A' && (P)[0] <= 'Z') || ((P)[0] >= 'a' && (P)[0] <= 'z')) \
-     && (P)[1] == ':')
-# define IS_FILE_NAME_WITH_DIR(P) \
-    (strchr (P, '/') != NULL || strchr (P, '\\') != NULL || HAS_DEVICE (P))
-# define FILE_SYSTEM_PREFIX_LEN(P) (HAS_DEVICE (P) ? 2 : 0)
-#else
-  /* Unix */
-# define ISSLASH(C) ((C) == '/')
-# define IS_FILE_NAME_WITH_DIR(P) (strchr (P, '/') != NULL)
-# define FILE_SYSTEM_PREFIX_LEN(P) 0
 #endif
 
 /* Whether to enable the more costly support for relocatable libraries.
@@ -425,9 +407,9 @@ find_shared_library_fullname ()
           if (address >= start && address <= end - 1)
             {
               /* Found it.  Now see if this line contains a filename.  */
-              while (c = getc (fp), c != EOF && c != '\n' && c != '/')
+              while (c = getc (fp), c != EOF && c != '\n' && ! ISSLASH(c))
                 continue;
-              if (c == '/')
+              if (ISSLASH(c))
                 {
                   size_t size;
                   int len;
diff --git a/lib/rename.c b/lib/rename.c
index 4722f13a12..dcc3e6884c 100644
--- a/lib/rename.c
+++ b/lib/rename.c
@@ -320,8 +320,8 @@ rpl_rename (char const *src, char const *dst)
   }
 # endif /* RENAME_DEST_EXISTS_BUG */
 
-  src_slash = src[src_len - 1] == '/';
-  dst_slash = dst[dst_len - 1] == '/';
+  src_slash = ISSLASH(src[src_len - 1]);
+  dst_slash = ISSLASH(dst[dst_len - 1]);
 
 # if !RENAME_HARD_LINK_BUG && !RENAME_DEST_EXISTS_BUG
   /* If there are no trailing slashes, then trust the native
@@ -448,7 +448,7 @@ rpl_rename (char const *src, char const *dst)
         }
       src_len = strlen (src_temp);
       if (strncmp (src_temp, dst_temp, src_len) == 0
-          && dst_temp[src_len] == '/')
+          && ISSLASH(dst_temp[src_len]) )
         {
           rename_errno = EINVAL;
           goto out;
diff --git a/lib/renameatu.c b/lib/renameatu.c
index 939e58965f..400c673309 100644
--- a/lib/renameatu.c
+++ b/lib/renameatu.c
@@ -155,8 +155,8 @@ renameatu (int fd1, char const *src, int fd2, char const *dst,
   if (!src_len || !dst_len)
     return renameat2ish (fd1, src, fd2, dst, flags);
 
-  src_slash = src[src_len - 1] == '/';
-  dst_slash = dst[dst_len - 1] == '/';
+  src_slash = ISSLASH(src[src_len - 1]);
+  dst_slash = ISSLASH(dst[dst_len - 1]);
   if (!src_slash && !dst_slash)
     return renameat2ish (fd1, src, fd2, dst, flags);
 
diff --git a/lib/spawni.c b/lib/spawni.c
index cc9511fdd8..baea536b98 100644
--- a/lib/spawni.c
+++ b/lib/spawni.c
@@ -1028,7 +1028,7 @@ __spawni (pid_t *pid, const char *file,
         }
     }
 
-  if (! use_path || strchr (file, '/') != NULL)
+  if (! use_path || IS_FILE_NAME_WITH_DIR(file))
     {
       /* The FILE parameter is actually a path.  */
       execve (file, (char * const *) argv, (char * const *) envp);
@@ -1061,7 +1061,7 @@ __spawni (pid_t *pid, const char *file,
   /* Copy the file name at the top.  */
   name = (char *) memcpy (name + pathlen + 1, file, len);
   /* And add the slash.  */
-  *--name = '/';
+  *--name = DIR_SEPARATOR;
 
   p = path;
   do
diff --git a/lib/symlink.c b/lib/symlink.c
index b5009ae835..1d64429d4a 100644
--- a/lib/symlink.c
+++ b/lib/symlink.c
@@ -22,7 +22,7 @@
 #include <errno.h>
 #include <string.h>
 #include <sys/stat.h>
-
+#include "filename.h"
 
 #if HAVE_SYMLINK
 
@@ -33,7 +33,7 @@ int
 rpl_symlink (char const *contents, char const *name)
 {
   size_t len = strlen (name);
-  if (len && name[len - 1] == '/')
+  if (len && ISSLASH(name[len - 1]))
     {
       struct stat st;
       if (lstat (name, &st) == 0 || errno == EOVERFLOW)
diff --git a/lib/symlinkat.c b/lib/symlinkat.c
index 11eda8289a..1aface185f 100644
--- a/lib/symlinkat.c
+++ b/lib/symlinkat.c
@@ -26,7 +26,7 @@
 
 #if HAVE_SYMLINKAT
 # undef symlinkat
-
+#include "filename.h"
 #include <fcntl.h>
 #include <sys/stat.h>
 #include <string.h>
@@ -36,7 +36,7 @@ int
 rpl_symlinkat (char const *contents, int fd, char const *name)
 {
   size_t len = strlen (name);
-  if (len && name[len - 1] == '/')
+  if (len && ISSLASH(name[len - 1]))
     {
       struct stat st;
       if (fstatat (fd, name, &st, AT_SYMLINK_NOFOLLOW) == 0
diff --git a/lib/tmpdir.c b/lib/tmpdir.c
index 9c96a6972c..fe1d5a57b5 100644
--- a/lib/tmpdir.c
+++ b/lib/tmpdir.c
@@ -21,7 +21,7 @@
 
 /* Specification.  */
 #include "tmpdir.h"
-
+#include "filename.h"
 #include <stdlib.h>
 #include <string.h>
 
@@ -62,23 +62,13 @@
 # define __xstat64(version, path, buf) stat (path, buf)
 #endif
 
-/* Pathname support.
-   ISSLASH(C)           tests whether C is a directory separator character.
- */
-#if defined _WIN32 || defined __CYGWIN__ || defined __EMX__ || defined __DJGPP__
-  /* Native Windows, Cygwin, OS/2, DOS */
-# define ISSLASH(C) ((C) == '/' || (C) == '\\')
-#else
-  /* Unix */
-# define ISSLASH(C) ((C) == '/')
-#endif
 
 
 /* Return nonzero if DIR is an existent directory.  */
 static bool
 direxists (const char *dir)
 {
-  struct_stat64 buf;
+  struct_stat64 buf; 
   return __xstat64 (_STAT_VER, dir, &buf) == 0 && S_ISDIR (buf.st_mode);
 }
 
diff --git a/lib/unlink.c b/lib/unlink.c
index d77d26298e..1957ef9a2c 100644
--- a/lib/unlink.c
+++ b/lib/unlink.c
@@ -93,6 +93,13 @@ rpl_unlink (char const *name)
         }
 #endif
       result = unlink (name);
+#ifdef _WIN32 //windows won't let us delete readonly files by default but things like RM have already verified we wanted to delete it
+	  if (result != 0 && errno == EACCES) {
+		  chmod(name, _S_IREAD | _S_IWRITE); 
+		  result = unlink(name);
+	  }
+#endif // _WIN32
+
     }
   return result;
 }
