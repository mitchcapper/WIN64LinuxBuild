diff --git a/Makefile.am b/Makefile.am
index 096ff661..fd5b79fc 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -39,8 +39,8 @@ make_SRCS =	src/ar.c src/arscan.c src/commands.c src/commands.h \
 		src/signame.c src/strcache.c src/variable.c src/variable.h \
 		src/version.c src/vpath.c src/warning.c src/warning.h
 
-w32_SRCS =	src/w32/pathstuff.c src/w32/w32os.c src/w32/compat/dirent.c \
-		src/w32/compat/posixfcn.c src/w32/include/dirent.h \
+w32_SRCS =	src/w32/pathstuff.c src/w32/w32os.c \
+		src/w32/compat/posixfcn.c  \
 		src/w32/include/dlfcn.h src/w32/include/pathstuff.h \
 		src/w32/include/sub_proc.h src/w32/include/w32err.h \
 		src/w32/subproc/misc.c src/w32/subproc/proc.h \
diff --git a/configure.ac b/configure.ac
index d9abc0d2..c183a957 100644
--- a/configure.ac
+++ b/configure.ac
@@ -447,7 +447,7 @@ AM_CONDITIONAL([WINDOWSENV], [false])
 AM_CONDITIONAL([HAVE_WINDRES], [false])
 
 AS_CASE([$host],
-  [*-*-mingw32],
+  [*-*-mingw*],
    [AM_CONDITIONAL([WINDOWSENV], [true])
     w32_target_env=yes
     AC_DEFINE([MK_OS_W32], [1], [Build for the Windows32 API.])
diff --git a/src/ar.c b/src/ar.c
index 289235eb..5d13f734 100644
--- a/src/ar.c
+++ b/src/ar.c
@@ -23,6 +23,7 @@ this program.  If not, see <https://www.gnu.org/licenses/>.  */
 #include "dep.h"
 #include <fnmatch.h>
 #include <intprops.h>
+#include "glob.h"
 
 /* Return nonzero if NAME is an archive-member reference, zero if not.  An
    archive-member reference is a name like 'lib(member)' where member is a
diff --git a/src/arscan.c b/src/arscan.c
index f86e95f7..2fd57780 100644
--- a/src/arscan.c
+++ b/src/arscan.c
@@ -26,7 +26,7 @@ this program.  If not, see <https://www.gnu.org/licenses/>.  */
 #else
 #include <sys/file.h>
 #endif
-
+#include "filename.h"
 #ifndef NO_ARCHIVES
 
 #if MK_OS_VMS
@@ -689,7 +689,7 @@ ar_scan (const char *archive, ar_member_func_t function, const void *arg)
 #endif  /* Not AIAMAG. */
 
           /* On some systems, there is a slash after each member name.  */
-          if (*p == '/')
+          if (ISSLASH(*p))
             *p = '\0';
 
 #ifndef AIAMAG
@@ -699,7 +699,7 @@ ar_scan (const char *archive, ar_member_func_t function, const void *arg)
              real member name appears in the element data (used by
              4.4BSD).  */
           if (! is_namemap
-              && (name[0] == ' ' || name[0] == '/')
+              && (name[0] == ' ' || ISSLASH(name[0]))
               && namemap != 0)
             {
               const char* err;
@@ -717,7 +717,7 @@ ar_scan (const char *archive, ar_member_func_t function, const void *arg)
             }
           else if (name[0] == '#'
                    && name[1] == '1'
-                   && name[2] == '/')
+                   && ISSLASH(name[2]))
             {
               const char* err;
               unsigned int name_len = make_toui (name + 3, &err);
@@ -814,7 +814,7 @@ ar_scan (const char *archive, ar_member_func_t function, const void *arg)
                 if (*clear == '\n')
                   {
                     *clear = '\0';
-                    if (clear[-1] == '/')
+                    if ( ISSLASH(clear[-1]))
                       clear[-1] = '\0';
                   }
               }
@@ -853,7 +853,7 @@ ar_name_equal (const char *name, const char *mem, int truncated)
   if (streq (name, mem))
     return 1;
 
-  p = strrchr (name, '/');
+  p = LAST_SLASH_IN_PATH (name);
   if (p != 0)
     name = p + 1;
 
diff --git a/src/dir.c b/src/dir.c
index a805a377..e53943e9 100644
--- a/src/dir.c
+++ b/src/dir.c
@@ -13,15 +13,22 @@ A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License along with
 this program.  If not, see <https://www.gnu.org/licenses/>.  */
-
+#include "config.h"
 #include "makeint.h"
 #include "hash.h"
 #include "filedef.h"
 #include "dep.h"
 #include "debug.h"
+#include "filename.h"
+#define GetVolumeInformation GetVolumeInformationA
+#if defined HAVE_DIRENT_H || defined _WIN32
+#ifdef _WIN32
+#include <dirent.h>
+#include <sys/types.h>
+#define MAX_PATH 1024
+#define FALSE 0
+#endif
 
-#ifdef HAVE_DIRENT_H
-# include <dirent.h>
 # define NAMLEN(dirent) strlen((dirent)->d_name)
 # if MK_OS_VMS
 /* its prototype is in vmsdir.h, which is not needed for HAVE_DIRENT_H */
@@ -527,7 +534,7 @@ find_directory (const char *name)
     tstart = tem;
     if (tstart[1] == ':')
       tstart += 2;
-    for (tend = tem + (len - 1); tend > tstart && ISDIRSEP (*tend); tend--)
+    for (tend = tem + (len - 1); tend > tstart && ISSLASH (*tend); tend--)
       *tend = '\0';
 
     r = stat (tem, &st);
@@ -819,7 +826,7 @@ file_exists_p (const char *name)
     return ar_member_date (name) != (time_t) -1;
 #endif
 
-  dirend = strrchr (name, '/');
+  dirend = LAST_SLASH_IN_PATH (name);
 #if MK_OS_VMS
   if (dirend == NULL)
     {
@@ -840,9 +847,6 @@ file_exists_p (const char *name)
 #ifdef HAVE_DOS_PATHS
   /* Forward and backslashes might be mixed.  We need the rightmost one.  */
   {
-    const char *bslash = strrchr (name, '\\');
-    if (!dirend || bslash > dirend)
-      dirend = bslash;
     /* The case of "d:file".  */
     if (!dirend && name[0] && name[1] == ':')
       dirend = name + 1;
@@ -869,7 +873,7 @@ file_exists_p (const char *name)
       dirname = p;
     }
 #if MK_OS_VMS
-  if (*slash == '/')
+  if (ISSLASH(*slash))
     slash++;
 #else
   slash++;
@@ -889,7 +893,7 @@ file_impossible (const char *filename)
   struct directory *dir;
   struct dirfile *new;
 
-  dirend = strrchr (p, '/');
+  dirend = LAST_SLASH_IN_PATH (p);
 #if MK_OS_VMS
   if (dirend == NULL)
     {
@@ -942,7 +946,7 @@ file_impossible (const char *filename)
         }
       dir = find_directory (dirname);
 #if MK_OS_VMS
-      if (*slash == '/')
+      if (ISSLASH(*slash))
         filename = p = slash + 1;
       else
         filename = p = slash;
@@ -987,7 +991,7 @@ file_impossible_p (const char *filename)
   int want_vmsify = 0;
 #endif
 
-  dirend = strrchr (filename, '/');
+  dirend = LAST_SLASH_IN_PATH (filename);
 #if MK_OS_VMS
   if (dirend == NULL)
     {
@@ -1034,7 +1038,7 @@ file_impossible_p (const char *filename)
         }
       dir = find_directory (dirname)->contents;
 #if MK_OS_VMS
-      if (*slash == '/')
+      if (ISSLASH(*slash))
         filename = slash + 1;
       else
         filename = slash;
diff --git a/src/function.c b/src/function.c
index b4c38052..acda9a06 100644
--- a/src/function.c
+++ b/src/function.c
@@ -22,7 +22,7 @@ this program.  If not, see <https://www.gnu.org/licenses/>.  */
 #include "os.h"
 #include "commands.h"
 #include "debug.h"
-
+#include "filename.h"
 
 struct function_table_entry
   {
@@ -2036,14 +2036,8 @@ func_not (char *o, char **argv, char *funcname UNUSED)
 
 
 #ifdef HAVE_DOS_PATHS
-# ifdef __CYGWIN__
-#  define IS_ABSOLUTE(n) ((n[0] && n[1] == ':') || ISDIRSEP (n[0]))
-# else
-#  define IS_ABSOLUTE(n) (n[0] && n[1] == ':')
-# endif
 # define ROOT_LEN 3
 #else
-# define IS_ABSOLUTE(n) (n[0] == '/')
 # define ROOT_LEN 1
 #endif
 
@@ -2062,7 +2056,7 @@ abspath (const char *name, char *apath)
 
   apath_limit = apath + GET_PATH_MAX;
 
-  if (!IS_ABSOLUTE(name))
+  if (!IS_ABSOLUTE_FILE_NAME(name))
     {
       /* It is unlikely we would make it until here but just to make sure. */
       if (!starting_directory)
@@ -2193,7 +2187,7 @@ func_realpath (char *o, char **argv, const char *funcname UNUSED)
           if (rp)
             {
               char *ep = rp + strlen (rp) - 1;
-              while (ep > rp && ep[0] == '/')
+              while (ep > rp &&  ISSLASH(ep[0]))
                 *(ep--) = '\0';
             }
 # endif
diff --git a/src/implicit.c b/src/implicit.c
index 134e3fef..24dea816 100644
--- a/src/implicit.c
+++ b/src/implicit.c
@@ -23,6 +23,7 @@ this program.  If not, see <https://www.gnu.org/licenses/>.  */
 #include "job.h"      /* struct child, used inside commands.h */
 #include "commands.h" /* set_file_variables */
 #include "shuffle.h"
+#include "filename.h"
 #include <assert.h>
 
 static int pattern_search (struct file *file, int archive,
@@ -194,6 +195,7 @@ pattern_search (struct file *file, int archive,
 
   /* The last slash in FILENAME (or nil if there is none).  */
   const char *lastslash;
+  const char *lastslash2;
 
   /* This is a file-object used as an argument in
      recursive calls.  It never contains any data
@@ -259,6 +261,11 @@ pattern_search (struct file *file, int archive,
          but not counting any slash at the end.  (foo/bar/ counts as
          bar/ in directory foo/, not empty in directory foo/bar/.)  */
       lastslash = memrchr (filename, '/', namelen - 1);
+#ifdef _WIN32
+      lastslash2 = memrchr (filename, '\\', namelen - 1);
+      if (! lastslash || (lastslash2 && lastslash < lastslash2) )
+        lastslash = lastslash2;
+#endif      
 #if MK_OS_VMS
       if (lastslash == NULL)
         lastslash = strrchr (filename, ']');
@@ -335,7 +342,7 @@ pattern_search (struct file *file, int archive,
 #if MK_OS_VMS
               check_lastslash = strpbrk (target, "/]>:") == NULL;
 #else
-              check_lastslash = strchr (target, '/') == 0;
+              check_lastslash = LAST_SLASH_IN_PATH (target) == 0;
 #endif
 #ifdef HAVE_DOS_PATHS
               /* Didn't find it yet: check for DOS-type directories.  */
diff --git a/src/job.c b/src/job.c
index e54a9340..74e03a92 100644
--- a/src/job.c
+++ b/src/job.c
@@ -1,3 +1,8 @@
+
+
+
+
+
 /* Job execution and handling for GNU Make.
 Copyright (C) 1988-2024 Free Software Foundation, Inc.
 This file is part of GNU Make.
@@ -15,39 +20,65 @@ You should have received a copy of the GNU General Public License along with
 this program.  If not, see <https://www.gnu.org/licenses/>.  */
 
 #include "makeint.h"
-
+#include "debug.h"
 #include <assert.h>
 #include <string.h>
-
+#include "filename.h"
+#include "pathstuff.h"
+#include "variable.h"
 /* Default shell to use.  */
 #if MK_OS_W32
 # include <windows.h>
 
-const char *default_shell = "sh.exe";
-int no_default_sh_exe = 1;
-int batch_mode_shell = 1;
-HANDLE main_thread;
-
-#elif MK_OS_DOS
+int patheq(const char* p1, const char* p2) {
+#if ! defined(HAVE_CASE_INSENSITIVE_FS) && ! defined(_WIN32)
+	return streq(p1, p2);
+#elif _WIN32 //may or may not also have case insensitive comiple flag
+	if (p1 == p2)
+		return 1;
+	if (!p1 || !p2)
+		return 0;
+	while ( *p1 || *p2 ) {
+		if (*p1 == '\0' || *p2 == '\0')
+			return 0;
+		if (ISSLASH(*p1)) {
+			if (! ISSLASH(*p2))
+				return 0;
+		}
+		else {
+#ifdef HAVE_CASE_INSENSITIVE_FS
+			if (tolower(*p1) != tolower(*p2))
+				return 0;
+#else
+			if (*p1 != *p2)
+				return 0;
+#endif // HAVE_CASE_INSENSITIVE_FS
+
+		}
+		p1++;
+		p2++;
+	}
+	return 1;
+
+#else //not windows but case insensitive requested
+	return ((p1) == (p2) \
+		|| (tolower((unsigned char)*(p1)) == tolower((unsigned char)*(p2)) \
+			&& (*(p1) == '\0' || !strcasecmp((p1)+1, (p2)+1))));
+#endif
 
-/* The default shell is a pointer so we can change it if Makefile
-   says so.  It is without an explicit path so we get a chance
-   to search the $PATH for it (since MSDOS doesn't have standard
-   directories we could trust).  */
-const char *default_shell = "command.com";
-int batch_mode_shell = 0;
+}
+static void _shell_set(const char* shell, const char* by_what, int user_set);
+static int expand_executable_in_path(const char* path, char* dst_buffer, size_t dst_buffer_size, int skip_initial_access_check);
+static int shell_fully_qualify_path(const char* path);
+static void shell_init_defaults();
 
-#elif MK_OS_OS2
+HANDLE main_thread;
 
-const char *default_shell = "/bin/sh";
-int batch_mode_shell = 0;
 
 #elif MK_OS_VMS
 
 # include <descrip.h>
 # include <stsdef.h>
-const char *default_shell = "";
-int batch_mode_shell = 0;
 
 #define strsignal vms_strsignal
 char * vms_strsignal (int status);
@@ -61,9 +92,6 @@ char * vms_strsignal (int status);
 
 #else
 
-const char *default_shell = "/bin/sh";
-int batch_mode_shell = 0;
-
 #endif
 
 #if MK_OS_DOS
@@ -83,6 +111,346 @@ int dos_command_running;
 static void vmsWaitForChildren (int *);
 #endif
 
+/// <summary>
+/// Check if a shell may potentially change the current shell can pass NULL for shell if only signalling that directory change has happened
+/// </summary>
+/// <param name="new_shell"></param>
+/// <param name="dir_may_have_changed"></param>
+/// <returns>0 for no change,1 may have changed but equal to old shell (old shell likely relative), 2 for may have changed not equal old shell</returns>
+int shell_check_change(const char * new_shell, int dir_may_have_changed) {
+
+	if (dir_may_have_changed && shell_info.is_relative_path)
+		shell_info._shell_detected = 0;
+
+	if (new_shell && shell_is_banned(new_shell))
+		return 0;
+
+	if (shell_info.full_path != NULL && strcmp(new_shell, shell_info.full_path))
+		return 2;
+
+	if (
+		new_shell == NULL ||
+		(shell_info.initial_value_set_by_user != NULL && strcmp(new_shell, shell_info.initial_value_set_by_user) == 0)
+		) {
+		if (shell_info.have_no_default_sh_exe == 0 && shell_info.is_relative_path && dir_may_have_changed)//while we won't notify the user for the same path being set for the shell we will invalidate its detection if we set it again and its a relative path
+			return 1;
+		else
+			return 0;
+	}
+	
+	return 2;
+}
+
+static void shell_init_defaults() {
+	shell_info._defaults_inited = 1;
+	shell_info.have_no_default_sh_exe = 1;
+#if MK_OS_W32
+	shell_info.default_shell = "gsh.exe";
+#elif MK_OS_DOS
+	shell_info.default_shell = "cmd.exe";
+#else
+	shell_info.default_shell = "/bin/sh";
+#endif
+}
+/// <summary>
+/// Sets the shell and runs a detect
+/// </summary>
+/// <param name="shell"></param>
+/// <param name="by_what"></param>
+/// <returns>shell type detected, 0 is on default due to failure, 1 is set but was set to the default shell, 2 is non-default shell</returns>
+int shell_set_and_detect(const char* shell, const char* by_what) {
+	shell_set(shell, by_what);
+	return shell_detect_features();
+}
+/// <summary>
+/// sets the shell to a new value, will set shell_info.have_no_default_sh_exe to 0
+/// </summary>
+/// <param name="shell"></param>
+/// <param name="by_what"></param>
+void shell_set(const char* shell, const char * by_what) {
+	_shell_set(shell, by_what, 1);
+}
+int shells_equal(const char* s1, const char* s2) {
+	if (s1 == s2)
+		return 1;
+	if (s1 == 0 || s2 == 0)
+		return 0;
+	if (strcmp(s1, s2) == 0)//might as well check the likely of same for both
+		return 1;
+
+	PATH_VAR(expanded);
+	PATH_VAR(s1_full);
+	PATH_VAR(s2_full);
+	expand_executable_in_path(s1, expanded, sizeof(expanded),0);
+	_fullpath(s1_full, expanded, sizeof(s1_full));
+	expand_executable_in_path(s2, expanded, sizeof(expanded), 0);
+	_fullpath(s2_full, expanded, sizeof(s2_full));
+	return patheq(s1_full, s2_full);
+}
+
+int shell_is_banned(const char* shell) {
+	if (!shell || shell[0] == '\0' || shell_info.banned_shells[0] == '\0')
+		return 0;
+	PATH_VAR(lookup);
+	sprintf_s(lookup, sizeof(lookup), ";%s;",shell);
+	int ret;
+#if defined(HAVE_CASE_INSENSITIVE_FS)
+	ret = strcasestr(shell_info.banned_shells, lookup) != NULL;
+#else
+	ret = strstr(shell_info.banned_shells, lookup) != NULL;
+#endif
+	if (ret)
+		DB(DB_VERBOSE, (_("shell_is_banned() shell attempted to be set to banned shell ignoring: %s\n"), shell));
+	return ret;
+}
+void shell_set_user_default_shell(const char* shell) {
+	if (shell_info.user_defined_default_shell)
+		free(shell_info.user_defined_default_shell);
+	shell_info.user_defined_default_shell = strdup(shell);
+	w32ify(shell_info.user_defined_default_shell,0);
+}
+void shell_set_banned_shells(const char* shell) {
+	sprintf_s(shell_info.banned_shells, sizeof(shell_info.banned_shells), ";%s;", shell);
+}
+
+
+void shell_call_flags_set(const char* user_flags) {
+	if (!shell_info._defaults_inited)//not explicitly required but why not
+		shell_init_defaults();
+	if (shell_info.user_call_args != NULL) {
+		free(shell_info.user_call_args);
+		shell_info.user_call_args = NULL;
+	}
+	if (user_flags)
+		shell_info.user_call_args = strdup(user_flags);
+}
+/// <summary>
+/// only has effect if the user call flags are not in use, and the shell is a unixy type shell
+/// </summary>
+/// <param name="val"></param>
+void shell_posix_pedantic_set(int val) {
+	shell_info.posix_pedantic = val;
+}
+const char* shell_get_flags(int no_error_mode) {
+	if (!shell_info._defaults_inited)//not explicitly required but why not
+		shell_init_defaults();
+	shell_get_for_use();
+	if (shell_info.user_call_args)
+		return shell_info.user_call_args;
+	if (shell_info.posix_pedantic && shell_info.unixy && !no_error_mode) {
+		if (shell_info._alt_flags_buffer[0] == 0){ //right now the buffer is only used for pendantic so if its set we can just return it
+			strcpy_s(shell_info._alt_flags_buffer, sizeof(shell_info._alt_flags_buffer), shell_info.call_args);
+			strcat_s(shell_info._alt_flags_buffer, sizeof(shell_info._alt_flags_buffer), 'e');
+		}
+		return shell_info._alt_flags_buffer;
+	}
+	return shell_info.call_args;
+}
+/// <summary>
+/// actual update shell info with internal handler flag, when set by the user we don't update the actual value set by the user just other fields
+/// </summary>
+/// <param name="shell"></param>
+/// <param name="by_what"></param>
+/// <param name="user_set">true if set by the user, false if we are setting internally (forced default or full path qualification)</param>
+static void _shell_set(const char* shell, const char* by_what, int user_set) {
+	if (!shell_info._defaults_inited)
+		shell_init_defaults();
+
+
+
+	int shell_change_detect = shell_check_change(shell, 0);
+	if (!shell_change_detect)
+		return;
+	shell_info._shell_detected = 0;
+	if (shell_change_detect == 1) { //only change would be due to the dir change but the shell itself didnt so no need to udpate anything
+		if (user_set && shell_info.is_relative_path && shell_info.full_path != NULL) {
+			free(shell_info.full_path);
+			shell_info.full_path = NULL;
+		}
+		return;
+	}
+	
+
+	DB(DB_VERBOSE, (_("_shell_set() shell being set to = %s by %s\n"),shell, by_what));
+	shell_info._shell_detected = 0;
+	if (shell_info.full_path) {
+		free(shell_info.full_path);
+		shell_info.full_path = NULL;
+	}
+	if (user_set) {
+		if (shell_info.initial_value_set_by_user != NULL)
+			free(shell_info.initial_value_set_by_user);
+		shell = shell_info.initial_value_set_by_user = strdup(shell);
+		shell_info.is_relative_path = IS_ABSOLUTE_FILE_NAME(shell);
+		shell_info.have_no_default_sh_exe = 0;
+	} else
+		shell = shell_info.full_path = strdup(shell);
+}
+/// <summary>
+/// Called if we are going to use the shell, makes sure 
+/// </summary>
+/// <returns></returns>
+const char* shell_get_for_use() {
+	if (!shell_info._defaults_inited)
+		shell_init_defaults();
+
+	if (shell_info.initial_value_set_by_user != NULL && !shell_info._shell_detected)
+		shell_detect_features();
+
+	if (!shell_info.full_path) {
+		_shell_set(shell_info.default_shell, "shell_get_for_use: Could not find user provided shell and we need one, overriding with default", 0);
+		if (!shell_info._shell_detected)
+			shell_detect_features();
+	}
+	assert(shell_info.full_path);
+	return shell_info.full_path;
+}
+const char* shell_get_default() {
+	if (!shell_info._defaults_inited)
+		shell_init_defaults();
+	return shell_info.user_defined_default_shell ? shell_info.user_defined_default_shell : shell_info.default_shell;
+}
+/// <summary>
+/// Searches path for an executable, if not found buffer is filled with original path
+/// </summary>
+/// <param name="path"></param>
+/// <param name="dst_buffer"></param>
+/// <param name="dst_buffer_size"></param>
+/// <returns>0 for failure or 1 for found</returns>
+static int expand_executable_in_path(const char* path, char* dst_buffer, size_t dst_buffer_size, int skip_initial_access_check) {
+	if (!skip_initial_access_check && _access(path, 0) == 0) {
+		strcpy_s(dst_buffer, dst_buffer_size, path);
+		return 1;
+	}
+	
+	if (IS_ABSOLUTE_FILE_NAME(path)) { //we probably shouldn't actually expand absolute paths using the path, this is likely a breaking change
+		strcpy_s(dst_buffer, dst_buffer_size, path);
+		return 0;
+	}
+	char* p;
+	struct variable* v = lookup_variable(STRING_SIZE_TUPLE("PATH"));
+
+	/* Search Path for shell */
+	if (v && v->value)
+	{
+		char* ep;
+
+		p = v->value;
+		ep = strchr(p, PATH_SEPARATOR_CHAR);
+
+		while (ep && *ep)
+		{
+
+			*ep = '\0';
+
+			snprintf(dst_buffer, dst_buffer_size, "%s/%s", p, path);
+			if (_access(dst_buffer, 0) == 0)
+			{
+				*ep = PATH_SEPARATOR_CHAR;
+				return 1;
+			}
+			else
+			{
+				*ep = PATH_SEPARATOR_CHAR;
+				p = ++ep;
+			}
+			ep = strchr(p, PATH_SEPARATOR_CHAR);
+		}
+
+		/* be sure to check last element of Path */
+		if (p && *p)
+		{
+			snprintf(dst_buffer, dst_buffer_size, "%s/%s", p, path);
+			if (_access(dst_buffer, 0) == 0)
+			{
+				return 1;
+			}
+		}
+
+	}
+	strcpy_s(dst_buffer, dst_buffer_size, path);
+	return 0;
+}
+/// <summary>
+/// search path for the shell, note may result in shell_detected set to 0 if path changed, sets if path is absolute or not
+/// </summary>
+/// <returns>0 for failure or 1 for found</returns>
+static int shell_fully_qualify_path(const char * path) {
+	PATH_VAR(sh_path);
+	if (_access(path, 0) == 0) {
+		if (path != shell_info.full_path)
+			shell_info.full_path = xstrdup(path);
+		return 1;
+	}
+	if (!expand_executable_in_path(path, sh_path, sizeof(sh_path), 1))
+		return 0;
+	_shell_set(sh_path, "shell_fully_qualify_path() found in system PATH", 0);
+}
+/// <summary>
+/// Detects and validates the shell, if the same name as the current shell it is not re-run
+/// </summary>
+/// <returns>shell type detected, 0 not set due to failure will use default if required, 1 is set but was set to the default shell, 2 is non-default shell</returns>
+int shell_detect_features() {
+	if (shell_info._shell_detected)
+		return;
+	shell_info._shell_detected = 1;
+	if (shell_info.full_path == NULL && shell_info.initial_value_set_by_user == NULL)
+		return 0;
+	//const char* name_start = LAST_SLASH_IN_PATH(shell_info.full_path);
+	//if (! name_start)
+	//	name_start = shell_info.full_path;
+
+	//int is_default_shell = stricmp(shell_info.full_path, shell_info.default_shell) == 0;
+	////we are basically only altered by win32 so can just always do case insenstivie
+	//if (stricmp(shell_info.executable_name, name_start) == 0 && (is_default_shell || shell_info.have_no_default_sh_exe != 0)) //if we are the same shell as last time we were detected do no re-run detection, unless a manual shell has yet to be specified.  If we haven't set a manual shell we want to rerun detection as directory may have changed.
+	//	return shell_info.have_no_default_sh_exe ? 0 : (is_default_shell ? 1 : 2);
+	//
+	const char* check_shell = shell_info.full_path ? shell_info.full_path : shell_info.initial_value_set_by_user;
+	int is_default_shell = check_shell && strcmp(check_shell, shell_info.default_shell) == 0;
+	if (!check_shell || ! shell_fully_qualify_path(check_shell)) {
+		if (! is_default_shell)
+			return 0;
+		else
+			assert(0);//full_shell_path == default_shell yet we can't find it, maybe the os knows magically, maybe we should be checking extensions? assert for debug otehrwise we blindly trust
+	}
+	else {
+		w32ify(shell_info.full_path, 0);
+	}
+
+	shell_info.is_cmd_exe = shell_info.unixy = shell_info.use_batchfile = 0;
+	if (shell_info.executable_name)
+		free(shell_info.executable_name);
+	const char* name_start = LAST_SLASH_IN_PATH(shell_info.full_path);
+	if (! name_start)
+		name_start = shell_info.full_path;
+	shell_info.executable_name = xstrdup(name_start);
+
+
+
+#if MK_OS_W32 || MK_OS_DOS
+	if (strcasecmp(shell_info.executable_name, "cmd.exe") == 0 || strcasecmp(shell_info.executable_name, "cmd") == 0 || strcasecmp(shell_info.executable_name, "command.com") == 0) {
+		shell_info.is_cmd_exe = 1;
+		shell_info.use_batchfile = 1;
+		shell_info.call_args = "/c";
+	}
+	else if (strcasecmp(shell_info.executable_name, "pwsh.exe") == 0 || strcasecmp(shell_info.executable_name, "pwsh") == 0 || strcasecmp(shell_info.executable_name, "powershell") == 0 || strcasecmp(shell_info.executable_name, "powershell.exe") == 0) {
+		shell_info.call_args = "-Command";
+	} else {
+#endif // MK_OS_W32 
+		shell_info.unixy = 1;
+		shell_info.call_args = "-c";
+		//shell_info._alt_flags_buffer[0] = 0; //if our flags could ever be anything other than -c we would want to clear this to make sure it is reset on pull with our shell change, but right now that is the only alt we have
+#if MK_OS_W32 || MK_OS_DOS
+	}
+#endif
+	
+#ifdef BATCH_MODE_ONLY_SHELL
+	shell_info.use_batchfile = 1
+#endif
+	w32ify(shell_info.full_path, 0);
+	return is_default_shell ? 1 : 2;
+		
+}
 #if MK_OS_W32
 # include <windows.h>
 # include <io.h>
@@ -236,8 +604,6 @@ static struct child *waiting_jobs = 0;
 
 /* Non-zero if we use a *real* shell (always so on Unix).  */
 
-int unixy_shell = 1;
-
 /* Number of jobs started in the current second.  */
 
 unsigned long job_counter = 0;
@@ -388,15 +754,10 @@ _is_unixy_shell (const char *path)
   };
 
   /* find the rightmost '/' or '\\' */
-  const char *name = strrchr (path, '/');
-  const char *p = strrchr (path, '\\');
+  const char *name = LAST_SLASH_IN_PATH (path);
   unsigned i;
 
-  if (name && p)    /* take the max */
-    name = (name > p) ? name : p;
-  else if (p)       /* name must be 0 */
-    name = p;
-  else if (!name)   /* name and p must be 0 */
+  if (!name)   /* name and p must be 0 */
     name = path;
 
   if (ISDIRSEP (*name))
@@ -428,6 +789,7 @@ is_bourne_compatible_shell (const char *path)
     "rksh",
     "zsh",
     "ash",
+    "gsh",
     NULL
   };
   const char **s;
@@ -1148,8 +1510,7 @@ free_child (struct child *child)
    for calling 'unblock_sigs', once the new child is safely on the chain so
    it can be cleaned up in the event of a fatal signal.  */
 
-static void
-start_job_command (struct child *child)
+static void start_job_command (struct child *child)
 {
   int flags;
   char *p;
@@ -1352,9 +1713,9 @@ start_job_command (struct child *child)
      printed, etc.  */
 
 #if !MK_OS_VMS
-  if (
+  if ( 
 #if MK_OS_DOS || MK_OS_OS2
-      unixy_shell       /* the test is complicated and we already did it */
+	  shell_info.unixy       /* the test is complicated and we already did it */
 #else
       (argv[0] && is_bourne_compatible_shell (argv[0]))
 #endif
@@ -1480,7 +1841,7 @@ start_job_command (struct child *child)
 
         /* If we have a *real* shell, tell 'system' to call
            it to do everything for us.  */
-        if (unixy_shell)
+        if (shell_info.unixy)
           {
             /* A *real* shell on MSDOS may not support long
                command lines the DJGPP way, so we must use 'system'.  */
@@ -2450,7 +2811,7 @@ child_execute_job (struct childbase *child, int good_stdin, char **argv)
         ++l;
 
       nargv = xmalloc (sizeof (char *) * (l + 3));
-      nargv[0] = (char *)default_shell;
+      nargv[0] = (char *) shell_get_for_use();
       nargv[1] = cmd;
       memcpy (&nargv[2], &argv[1], sizeof (char *) * l);
 
@@ -2621,15 +2982,16 @@ exec_command (char **argv, char **envp)
           ++argc;
 
 # if MK_OS_OS2
-        if (!unixy_shell)
+        if (!shell_info.unixy)
           ++argc;
 # endif
-
+		shell_set(shell);
+		shell = shell_get_for_use();
         new_argv = alloca ((1 + argc + 1) * sizeof (char *));
         new_argv[0] = (char *)shell;
 
 # if MK_OS_OS2
-        if (!unixy_shell)
+        if (!shell_info.unixy)
           {
             new_argv[1] = (char *)"/c";
             ++i;
@@ -2698,8 +3060,7 @@ exec_command (char **argv, char **envp)
    the strings, so to free you free the 0'th element then the returned pointer
    (see the FREE_ARGV macro).  */
 
-static char **
-construct_command_argv_internal (char *line, char **restp, const char *shell,
+static char ** construct_command_argv_internal (char *line, char **restp, const char *shell,
                                  const char *shellflags, const char *ifs,
                                  int flags, char **batch_filename UNUSED)
 {
@@ -2833,8 +3194,8 @@ construct_command_argv_internal (char *line, char **restp, const char *shell,
   char *argstr = 0;
 #if MK_OS_W32
   int slow_flag = 0;
-
-  if (!unixy_shell)
+  shell_get_for_use();//ensure it is detected
+  if (!shell_info.unixy)
     {
       sh_cmds = sh_cmds_dos;
       sh_chars = sh_chars_dos;
@@ -2857,14 +3218,14 @@ construct_command_argv_internal (char *line, char **restp, const char *shell,
 
   /* See if it is safe to parse commands internally.  */
   if (shell == 0)
-    shell = default_shell;
+    shell = shell_get_for_use();
 #if MK_OS_W32
-  else if (strcmp (shell, default_shell))
+  else if (strcmp (shell, shell_get_default()))
   {
     char *s1 = _fullpath (NULL, shell, 0);
-    char *s2 = _fullpath (NULL, default_shell, 0);
+    char *s2 = _fullpath (NULL, shell_get_default(), 0);
 
-    slow_flag = strcmp ((s1 ? s1 : ""), (s2 ? s2 : ""));
+    slow_flag = shells_equal((s1 ? s1 : ""), (s2 ? s2 : ""));
 
     free (s1);
     free (s2);
@@ -2873,18 +3234,18 @@ construct_command_argv_internal (char *line, char **restp, const char *shell,
     goto slow;
 #else  /* not MK_OS_W32 */
 #if MK_OS_DOS || MK_OS_OS2
-  else if (strcasecmp (shell, default_shell))
+  else if (strcasecmp (shell, shell_get_default()))
     {
       extern int _is_unixy_shell (const char *_path);
 
       DB (DB_BASIC, (_("$SHELL changed (was '%s', now '%s')\n"),
-                     default_shell, shell));
-      unixy_shell = _is_unixy_shell (shell);
+		  shell_get_default(), shell));
+	  shell_info.unixy = _is_unixy_shell (shell);
       /* we must allocate a copy of shell: construct_command_argv() will free
        * shell after this function returns.  */
-      default_shell = xstrdup (shell);
+      shell_set( shell , "construct_command_argv_internal");
     }
-  if (unixy_shell)
+  if (shell_info.unixy)
     {
       sh_chars = sh_chars_sh;
       sh_cmds  = sh_cmds_sh;
@@ -2902,7 +3263,7 @@ construct_command_argv_internal (char *line, char **restp, const char *shell,
 # endif
     }
 #else  /* !MK_OS_DOS */
-  else if (strcmp (shell, default_shell))
+  else if (strcmp (shell, shell_get_default()))
     goto slow;
 #endif /* !MK_OS_DOS && !MK_OS_OS2 */
 #endif /* not MK_OS_W32 */
@@ -2912,10 +3273,10 @@ construct_command_argv_internal (char *line, char **restp, const char *shell,
       if (*cap != ' ' && *cap != '\t' && *cap != '\n')
         goto slow;
 
-  if (shellflags)
-    if (shellflags[0] != '-'
-        || ((shellflags[1] != 'c' || shellflags[2] != '\0')
-            && (shellflags[1] != 'e' || shellflags[2] != 'c' || shellflags[3] != '\0')))
+  if (shell_info.call_args)
+    if (shell_info.call_args[0] != '-'
+        || ((shell_info.call_args[1] != 'c' || shell_info.call_args[2] != '\0')
+            && (shell_info.call_args[1] != 'e' || shell_info.call_args[2] != 'c' || shell_info.call_args[3] != '\0')))
       goto slow;
 
   i = strlen (line) + 1;
@@ -2955,7 +3316,7 @@ construct_command_argv_internal (char *line, char **restp, const char *shell,
                  pre-POSIX behavior of removing the backslash-newline.  */
               if (instring == '"'
 #if MK_OS_DOS || MK_OS_OS2 || MK_OS_W32
-                  || !unixy_shell
+                  || !shell_info.unixy
 #endif
                   )
                 ++p;
@@ -2975,12 +3336,12 @@ construct_command_argv_internal (char *line, char **restp, const char *shell,
              If we see any of those, punt.
              But on MSDOS, if we use COMMAND.COM, double and single
              quotes have the same effect.  */
-          else if (instring == '"' && strchr ("\\$`", *p) != 0 && unixy_shell)
+          else if (instring == '"' && strchr ("\\$`", *p) != 0 && shell_info.unixy)
             goto slow;
 #if MK_OS_W32
           /* Quoted wildcard characters must be passed quoted to the
              command, so give up the fast route.  */
-          else if (instring == '"' && strchr ("*?", *p) != 0 && !unixy_shell)
+          else if (instring == '"' && strchr ("*?", *p) != 0 && !shell_info.unixy)
             goto slow;
           else if (instring == '"' && strncmp (p, "\\\"", 2) == 0)
             *ap++ = *++p;
@@ -3008,7 +3369,7 @@ construct_command_argv_internal (char *line, char **restp, const char *shell,
                first word with no equals sign in it.  This is not the case
                with sh -k, but we never get here when using nonstandard
                shell flags.  */
-            if (! seen_nonequals && unixy_shell)
+            if (! seen_nonequals && shell_info.unixy)
               goto slow;
             word_has_equals = 1;
             *ap++ = '=';
@@ -3031,7 +3392,7 @@ construct_command_argv_internal (char *line, char **restp, const char *shell,
 #if MK_OS_W32
             /* Backslash before whitespace is not special if our shell
                is not Unixy.  */
-            else if (ISSPACE (p[1]) && !unixy_shell)
+            else if (ISSPACE (p[1]) && !shell_info.unixy)
               {
                 *ap++ = *p;
                 break;
@@ -3114,7 +3475,7 @@ construct_command_argv_internal (char *line, char **restp, const char *shell,
                       goto slow;
 #if MK_OS_OS2 || MK_OS_W32
                     /* Non-Unix shells are case insensitive.  */
-                    if (!unixy_shell
+                    if (!shell_info.unixy
                         && strcasecmp (sh_cmds[j], new_argv[0]) == 0)
                       goto slow;
 #endif
@@ -3208,7 +3569,7 @@ construct_command_argv_internal (char *line, char **restp, const char *shell,
 #endif
 
 # if MK_OS_OS2 /* is this necessary? */
-    if (!unixy_shell && shellflags)
+    if (!shell_info.unixy && shellflags)
       {
         size_t len = strlen (shellflags);
         char *shflags = alloca (len + 1);
@@ -3235,12 +3596,12 @@ construct_command_argv_internal (char *line, char **restp, const char *shell,
         /* Remove and ignore interior prefix chars [@+-] because they're
              meaningless given a single shell. */
 #if MK_OS_DOS || MK_OS_OS2
-        if (unixy_shell)     /* the test is complicated and we already did it */
+        if (shell_info.unixy)     /* the test is complicated and we already did it */
 #else
         if (is_bourne_compatible_shell (shell)
 #if MK_OS_W32
             /* If we didn't find any sh.exe, don't behave is if we did!  */
-            && !no_default_sh_exe
+            && !shell_info.have_no_default_sh_exe
 #endif
             )
 #endif
@@ -3431,7 +3792,7 @@ construct_command_argv_internal (char *line, char **restp, const char *shell,
                POSIX shell on DOS/Windows/OS2, mimic the pre-POSIX behavior
                and remove the backslash/newline.  */
 #if MK_OS_DOS || MK_OS_OS2 || MK_OS_W32
-# define PRESERVE_BSNL  unixy_shell
+# define PRESERVE_BSNL  shell_info.unixy
 #else
 # define PRESERVE_BSNL  1
 #endif
@@ -3441,7 +3802,7 @@ construct_command_argv_internal (char *line, char **restp, const char *shell,
                 /* Only non-batch execution needs another backslash,
                    because it will be passed through a recursive
                    invocation of this function.  */
-                if (!batch_mode_shell)
+                if (!shell_info.use_batchfile)
                   *(ap++) = '\\';
                 *(ap++) = '\n';
               }
@@ -3450,13 +3811,13 @@ construct_command_argv_internal (char *line, char **restp, const char *shell,
           }
 
         /* DOS shells don't know about backslash-escaping.  */
-        if (unixy_shell && !batch_mode_shell &&
+        if (shell_info.unixy && !shell_info.use_batchfile &&
             (*p == '\\' || *p == '\'' || *p == '"'
              || ISSPACE (*p)
              || strchr (sh_chars, *p) != 0))
           *ap++ = '\\';
 #if MK_OS_DOS
-        else if (unixy_shell && strneq (p, "...", 3))
+        else if (shell_info.unixy && strneq (p, "...", 3))
           {
             /* The case of '...' wildcard again.  */
             ap = stpcpy (ap, "\\.\\.\\");
@@ -3485,7 +3846,7 @@ construct_command_argv_internal (char *line, char **restp, const char *shell,
         new_argv[0] = xstrdup ("");
         new_argv[1] = NULL;
       }
-    else if ((no_default_sh_exe || batch_mode_shell) && batch_filename)
+    else if ((shell_info.have_no_default_sh_exe || shell_info.use_batchfile) && batch_filename)
       {
         int temp_fd;
         FILE* batch = NULL;
@@ -3494,7 +3855,7 @@ construct_command_argv_internal (char *line, char **restp, const char *shell,
 
         /* create a file name */
         sprintf (fbuf, "make%d", id);
-        *batch_filename = create_batch_file (fbuf, unixy_shell, &temp_fd);
+        *batch_filename = create_batch_file (fbuf, shell_info.unixy, &temp_fd);
 
         DB (DB_JOBS, (_("Creating temporary batch file %s\n"),
                       *batch_filename));
@@ -3503,17 +3864,17 @@ construct_command_argv_internal (char *line, char **restp, const char *shell,
            commands to be executed.  Put the batch file in TEXT mode.  */
         _setmode (temp_fd, _O_TEXT);
         batch = _fdopen (temp_fd, "wt");
-        if (!unixy_shell)
+        if (shell_info.is_cmd_exe)
           fputs ("@echo off\n", batch);
         fputs (command_ptr, batch);
         fputc ('\n', batch);
         fclose (batch);
         DB (DB_JOBS, (_("Batch file contents:%s\n\t%s\n"),
-                      !unixy_shell ? "\n\t@echo off" : "", command_ptr));
+                      shell_info.is_cmd_exe ? "\n\t@echo off" : "", command_ptr));
 
         /* create argv */
         new_argv = xmalloc (3 * sizeof (char *));
-        if (unixy_shell)
+        if (shell_info.unixy)
           {
             new_argv[0] = xstrdup (shell);
             new_argv[1] = *batch_filename; /* only argv[0] gets freed later */
@@ -3528,12 +3889,12 @@ construct_command_argv_internal (char *line, char **restp, const char *shell,
     else
 #endif /* MK_OS_W32 */
 
-    if (unixy_shell)
+    if (shell_info.unixy)
       new_argv = construct_command_argv_internal (new_line, 0, 0, 0, 0,
                                                   flags, 0);
 
 #if MK_OS_OS2
-    else if (!unixy_shell)
+    else if (!shell_info.unixy)
       {
         /* new_line is local, must not be freed therefore
            We use line here instead of new_line because we run the shell
@@ -3616,7 +3977,7 @@ construct_command_argv_internal (char *line, char **restp, const char *shell,
 #else
     else
       fatal (NILF, CSTRLEN (__FILE__) + INTSTR_LENGTH,
-             _("%s (line %d) Bad shell context (!unixy && !batch_mode_shell)\n"),
+             _("%s (line %d) Bad shell context (!unixy && !use_batchfile)\n"),
             __FILE__, __LINE__);
 #endif
 
@@ -3716,11 +4077,8 @@ construct_command_argv (char *line, char **restp, struct file *file,
       shellflags = "";
     else if (var->origin != o_default)
       shellflags = allocflags = allocated_expand_string_for_file (var->value, file);
-    else if (posix_pedantic && !ignore_errors_flag && NONE_SET (cmd_flags, COMMANDS_NOERROR))
-      /* In POSIX mode we default to -ec, unless we're ignoring errors.  */
-      shellflags = "-ec";
-    else
-      shellflags = "-c";
+    else 
+      shellflags = shell_get_flags( ignore_errors_flag || ALL_SET(cmd_flags, COMMANDS_NOERROR) );
 
     ifs = allocated_expand_variable_for_file (STRING_SIZE_TUPLE ("IFS"), file);
 
diff --git a/src/load.c b/src/load.c
index 8fb5d3ab..a6a698e1 100644
--- a/src/load.c
+++ b/src/load.c
@@ -23,7 +23,7 @@ this program.  If not, see <https://www.gnu.org/licenses/>.  */
 #include <stdlib.h>
 #include <dlfcn.h>
 #include <errno.h>
-
+#include "filename.h"
 #include "debug.h"
 #include "filedef.h"
 #include "variable.h"
@@ -72,17 +72,9 @@ load_object (const floc *flocp, int noerror, const char *ldname,
     }
 
   /* Find the prefix of the ldname.  */
-  fp = strrchr (ldname, '/');
+  fp = LAST_SLASH_IN_PATH (ldname);
 #ifdef HAVE_DOS_PATHS
-  if (fp)
-    {
-      const char *fp2 = strchr (fp, '\\');
 
-      if (fp2 > fp)
-        fp = fp2;
-    }
-  else
-    fp = strrchr (ldname, '\\');
   /* The (improbable) case of d:foo.  */
   if (fp && *fp && fp[1] == ':')
     fp++;
@@ -111,11 +103,7 @@ load_object (const floc *flocp, int noerror, const char *ldname,
 
   /* If the path has no "/", try the current directory first.  */
   dlp = NULL;
-  if (! strchr (ldname, '/')
-#ifdef HAVE_DOS_PATHS
-      && ! strchr (ldname, '\\')
-#endif
-      )
+  if (! LAST_SLASH_IN_PATH (ldname) )
     dlp = dlopen (concat (2, "./", ldname), RTLD_LAZY|RTLD_GLOBAL);
 
   /* If we haven't opened it yet, try the default search path.  */
diff --git a/src/main.c b/src/main.c
index 78084d09..d43da60b 100644
--- a/src/main.c
+++ b/src/main.c
@@ -15,8 +15,9 @@ You should have received a copy of the GNU General Public License along with
 this program.  If not, see <https://www.gnu.org/licenses/>.  */
 
 #include "makeint.h"
-
+
 #include <assert.h>
+#include "filename.h"
 #if MK_OS_W32
 # include <windows.h>
 # include <io.h>
@@ -132,6 +133,7 @@ int verify_flag;
 static int silent_flag;
 static const int default_silent_flag = 0;
 static enum variable_origin silent_origin = o_default;
+extern shell_info_t shell_info = { 0 };
 
 /* Nonzero means either -s was given, or .SILENT-with-no-deps was seen.  */
 
@@ -577,10 +579,7 @@ struct variable * default_goal_var;
 
 struct file *default_file;
 
-/* Nonzero if we have seen the magic '.POSIX' target.
-   This turns on pedantic compliance with POSIX.2.  */
 
-int posix_pedantic;
 
 /* Nonzero if we have seen the '.SECONDEXPANSION' target.
    This turns on secondary expansion of prerequisites.  */
@@ -773,10 +772,10 @@ expand_command_line_file (const char *name)
   /* This is also done in parse_file_seq, so this is redundant
      for names read from makefiles.  It is here for names passed
      on the command line.  */
-  while (name[0] == '.' && name[1] == '/')
+  while (name[0] == '.' && ISSLASH(name[1]))
     {
       name += 2;
-      while (name[0] == '/')
+      while (ISSLASH(name[0]))
         /* Skip following slashes: ".//foo" is "foo", not "/foo".  */
         ++name;
     }
@@ -1009,144 +1008,8 @@ handle_runtime_exceptions (struct _EXCEPTION_POINTERS *exinfo)
   return (255); /* not reached */
 #endif
 }
-
-/*
- * On W32 systems we don't have the luxury of a /bin directory that
- * is mapped globally to every drive mounted to the system. Since make could
- * be invoked from any drive, and we don't want to propagate /bin/sh
- * to every single drive. Allow ourselves a chance to search for
- * a value for default shell here (if the default path does not exist).
- */
-
-int
-find_and_set_default_shell (const char *token)
-{
-  int sh_found = 0;
-  char *atoken = 0;
-  const char *search_token;
-  const char *tokend;
-  extern const char *default_shell;
-
-  if (!token)
-    search_token = default_shell;
-  else
-    search_token = atoken = xstrdup (token);
-
-  /* If the user explicitly requests the DOS cmd shell, obey that request.
-     However, make sure that's what they really want by requiring the value
-     of SHELL either equal, or have a final path element of, "cmd" or
-     "cmd.exe" case-insensitive.  */
-  tokend = search_token + strlen (search_token) - 3;
-  if (((tokend == search_token
-        || (tokend > search_token && ISDIRSEP (tokend[-1])))
-       && !strcasecmp (tokend, "cmd"))
-      || ((tokend - 4 == search_token
-           || (tokend - 4 > search_token && ISDIRSEP (tokend[-5])))
-          && !strcasecmp (tokend - 4, "cmd.exe")))
-    {
-      batch_mode_shell = 1;
-      unixy_shell = 0;
-      default_shell = xstrdup (w32ify (search_token, 0));
-      DB (DB_VERBOSE, (_("find_and_set_shell() setting default_shell = %s\n"),
-                       default_shell));
-      sh_found = 1;
-    }
-  else if (!no_default_sh_exe
-           && (token == NULL || !strcmp (search_token, default_shell)))
-    {
-      /* no new information, path already set or known */
-      sh_found = 1;
-    }
-  else if (_access (search_token, 0) == 0)
-    {
-      /* search token path was found */
-      default_shell = xstrdup (w32ify (search_token, 0));
-      DB (DB_VERBOSE, (_("find_and_set_shell() setting default_shell = %s\n"),
-                       default_shell));
-      sh_found = 1;
-    }
-  else
-    {
-      char *p;
-      struct variable *v = lookup_variable (STRING_SIZE_TUPLE ("PATH"));
-
-      /* Search Path for shell */
-      if (v && v->value)
-        {
-          char *ep;
-
-          p  = v->value;
-          ep = strchr (p, PATH_SEPARATOR_CHAR);
-
-          while (ep && *ep)
-            {
-              int sh_pathlen;
-              PATH_VAR (sh_path);
-
-              *ep = '\0';
-
-              sh_pathlen = snprintf (sh_path, GET_PATH_MAX, "%s/%s",
-                                     p, search_token);
-              if (0 <= sh_pathlen && sh_pathlen < GET_PATH_MAX
-                  && _access (sh_path, 0) == 0)
-                {
-                  default_shell = xstrdup (w32ify (sh_path, 0));
-                  sh_found = 1;
-                  *ep = PATH_SEPARATOR_CHAR;
-
-                  /* terminate loop */
-                  p += strlen (p);
-                }
-              else
-                {
-                  *ep = PATH_SEPARATOR_CHAR;
-                  p = ++ep;
-                }
-
-              ep = strchr (p, PATH_SEPARATOR_CHAR);
-            }
-
-          /* be sure to check last element of Path */
-          if (p && *p)
-            {
-              int sh_pathlen;
-
-              PATH_VAR (sh_path);
-              sh_pathlen = snprintf (sh_path, GET_PATH_MAX, "%s/%s",
-                                     p, search_token);
-              if (0 <= sh_pathlen && sh_pathlen < GET_PATH_MAX
-                  && _access (sh_path, 0) == 0)
-                {
-                  default_shell = xstrdup (w32ify (sh_path, 0));
-                  sh_found = 1;
-                }
-            }
-
-          if (sh_found)
-            DB (DB_VERBOSE,
-                (_("find_and_set_shell() path search set default_shell = %s\n"),
-                 default_shell));
-        }
-    }
-
-  /* naive test */
-  if (!unixy_shell && sh_found
-      && (strstr (default_shell, "sh") || strstr (default_shell, "SH")))
-    {
-      unixy_shell = 1;
-      batch_mode_shell = 0;
-    }
-
-#ifdef BATCH_MODE_ONLY_SHELL
-  batch_mode_shell = 1;
 #endif
 
-  free (atoken);
-
-  return (sh_found);
-}
-#endif  /* MK_OS_W32 */
-
 #if MK_OS_DOS
 static void
 msdos_return_to_initial_directory (void)
@@ -1189,8 +1052,7 @@ extern char **environ;
 int
 main (int argc, char **argv)
 #else
-int
-main (int argc, char **argv, char **envp)
+int main (int argc, char **argv, char **envp)
 #endif
 {
   int makefile_status = MAKE_SUCCESS;
@@ -1206,8 +1068,6 @@ main (int argc, char **argv, char **envp)
   SetUnhandledExceptionFilter (handle_runtime_exceptions);
 
   /* start off assuming we have no shell */
-  unixy_shell = 0;
-  no_default_sh_exe = 1;
 #endif
 
   initialize_variable_output ();
@@ -1380,7 +1240,7 @@ main (int argc, char **argv, char **envp)
         /* Need to know if CRTL set to report UNIX paths.  Use getcwd as
            it works on all versions of VMS. */
         pwd = getcwd(pwdbuf, 256);
-        if (pwd[0] == '/')
+        if ( ISSLASH(pwd[0]) )
           vms_report_unix_paths = 1;
 
         vms_use_mcr_command = get_vms_env_flag ("GNV$MAKE_USE_MCR", 0);
@@ -1413,7 +1273,7 @@ main (int argc, char **argv, char **envp)
       if (need_vms_symbol () && !vms_use_mcr_command)
         create_foreign_command (program_name, argv[0]);
 #else
-      program = strrchr (argv[0], '/');
+      program = LAST_SLASH_IN_PATH (argv[0]);
       if (program == 0)
         program = argv[0];
       else
@@ -1743,19 +1603,19 @@ main (int argc, char **argv, char **envp)
      program that uses a non-absolute name.  */
   if (current_directory[0] != '\0'
       && argv[0] != 0
-      && (argv[0][0] != '/' && (argv[0][0] == '\0' || argv[0][1] != ':'))
+      && (! IS_ABSOLUTE_FILE_NAME(argv[0][0]))
 # if MK_OS_OS2
       /* do not prepend cwd if argv[0] contains no '/', e.g. "make" */
-      && (strchr (argv[0], '/') != 0 || strchr (argv[0], '\\') != 0)
+      && (LAST_SLASH_IN_PATH (argv[0]) != 0)
 # endif
       )
     argv[0] = xstrdup (concat (3, current_directory, "/", argv[0]));
 #else  /* !MK_OS_DOS */
   if (current_directory[0] != '\0'
-      && argv[0] != 0 && argv[0][0] != '/' && strchr (argv[0], '/') != 0
+      && argv[0] != 0 && ! ISSLASH( argv[0][0] ) && LAST_SLASH_IN_PATH (argv[0]) != 0
 #ifdef HAVE_DOS_PATHS
-      && (argv[0][0] != '\\' && (!argv[0][0] || argv[0][1] != ':'))
-      && strchr (argv[0], '\\') != 0
+      && (! IS_ABSOLUTE_FILE_NAME(argv[0]))
+      && LAST_SLASH_IN_PATH (argv[0]) != 0
 #endif
       )
     argv[0] = xstrdup (concat (3, current_directory, "/", argv[0]));
@@ -1797,7 +1657,7 @@ main (int argc, char **argv, char **envp)
    * lookups to fail because the current directory (.) was pointing
    * at the wrong place when it was first evaluated.
    */
-  no_default_sh_exe = !find_and_set_default_shell (NULL);
+  shell_check_change(NULL, 1);
 #endif /* MK_OS_W32 */
 
   /* If we chdir'ed, figure out where we are now.  */
@@ -2124,31 +1984,10 @@ main (int argc, char **argv, char **envp)
 
 #if MK_OS_W32
   /* look one last time after reading all Makefiles */
-  if (no_default_sh_exe)
-    no_default_sh_exe = !find_and_set_default_shell (NULL);
+  if (shell_info.have_no_default_sh_exe)
+	  shell_check_change(NULL, 1);
 #endif /* MK_OS_W32 */
 
-#if MK_OS_DOS || MK_OS_OS2 || MK_OS_VMS
-  /* We need to know what kind of shell we will be using.  */
-  {
-    extern int _is_unixy_shell (const char *_path);
-    struct variable *shv = lookup_variable (STRING_SIZE_TUPLE ("SHELL"));
-    extern int unixy_shell;
-    extern const char *default_shell;
-
-    if (shv && *shv->value)
-      {
-        char *shell_path = recursively_expand (shv);
-
-        if (shell_path && _is_unixy_shell (shell_path))
-          unixy_shell = 1;
-        else
-          unixy_shell = 0;
-        if (shell_path)
-          default_shell = shell_path;
-      }
-  }
-#endif /* MK_OS_DOS || MK_OS_OS2 */
 
   /* Final jobserver configuration.
 
@@ -3682,7 +3521,7 @@ define_makeflags (int makefile)
        $(MAKEOVERRIDES), which contains command-line variable definitions.
        Separate the variables from the switches with a "--" arg.  */
 
-    const char *r = posix_pedantic ? posixref : ref;
+    const char *r = shell_info.posix_pedantic ? posixref : ref;
     size_t l = strlen (r);
     v = lookup_variable (r, l);
     if (v && v->value && v->value[0] != '\0')
@@ -3901,6 +3740,5 @@ die (int status)
           _x = chdir (directory_before_chdir);
         }
     }
-
   exit (status);
 }
diff --git a/src/makeint.h b/src/makeint.h
index 61c78229..d1256c61 100644
--- a/src/makeint.h
+++ b/src/makeint.h
@@ -327,14 +327,8 @@ extern mode_t umask (mode_t);
 /* Test if two strings are equal, but match case-insensitively on systems
    which have case-insensitive filesystems.  Should only be used for
    filenames!  */
-#ifdef HAVE_CASE_INSENSITIVE_FS
-# define patheq(a, b) \
-    ((a) == (b) \
-     || (tolower((unsigned char)*(a)) == tolower((unsigned char)*(b)) \
-         && (*(a) == '\0' || !strcasecmp ((a) + 1, (b) + 1))))
-#else
-# define patheq(a, b) streq(a, b)
-#endif
+
+extern int patheq(const char* p1, const char* p2);
 
 #define strneq(a, b, l) (strncmp ((a), (b), (l)) == 0)
 
@@ -379,13 +373,52 @@ extern mode_t umask (mode_t);
 
 void sync_Path_environment (void);
 int w32_kill (pid_t pid, int sig);
-int find_and_set_default_shell (const char *token);
+typedef struct
+{
+	/* 1 when we have not yet had a valid shell explicitly assigned or found our shell  */
+	int have_no_default_sh_exe;
+	/* is default_shell unixy? , non would be things like cmd.exe or powershell.exe or pwsh.exe */
+	int unixy;
+	int is_cmd_exe;
+	/* can we run commands via 'sh -c xxx' or must we use batch files? */
+	int use_batchfile;
+	int is_relative_path; //tracked as if so we need to re-evaulate any time the directory changes
+	const char* full_path; //same as initial_value_set_by_user unless initial_value_set_by_user can only be found in the path vars
+	const char* executable_name; // ie bash
+	const char* initial_value_set_by_user; // could be ./bash for example
+
+	const char* call_args; //args required to execute a command, ie -c as detected by the system and taking into account posix_pedantic
+	const char* user_call_args; //args specified by the makefile/user directly these are always what is returned if set to non-null
+
+	/* Nonzero if we have seen the magic '.POSIX' target.
+	   This turns on pedantic compliance with POSIX.2.  */
+	int posix_pedantic; //pedantic mode for the flags for the shell
+	const char* default_shell; // default / fallback shell if not overwritten or is invalid
+	int _defaults_inited; //have we inited the shell defaults for the platform
+	int _shell_detected; //after setting the shell have we detected features, if a shell is used and this is not set should throw error
+	char _alt_flags_buffer[128]; //buffer if we need to modify the return flags, for example to take into account pendantic
+
+	char banned_shells[PATH_MAX]; //NOMAKESHELLS shells not to allow Makefiles to set as our shell
+	const char* user_defined_default_shell; //DEFAULTMAKESHELL
+
+} shell_info_t;
+
+extern shell_info_t shell_info;
+
+extern int shell_detect_features();
+extern int shell_set_and_detect(const char* shell, const char* by_what);
+extern const char* shell_get_for_use();
+extern int shells_equal(const char* s1, const char* s2);
+extern const char* shell_get_default();
+extern const char* shell_get_flags(int no_error_mode);
+extern int shell_check_change(const char* new_shell, int dir_may_have_changed);
+extern void shell_set(const char* shell, const char* by_what);
+extern void shell_posix_pedantic_set(int val);
+extern void shell_set_user_default_shell(const char* shell);
+extern void shell_set_banned_shells(const char* shell);
+extern int shell_is_banned(const char* shell);
 
-/* indicates whether or not we have Bourne shell */
-extern int no_default_sh_exe;
 
-/* is default_shell unixy? */
-extern int unixy_shell;
 
 /* We don't have a preferred fixed value for LOCALEDIR.  */
 # ifndef LOCALEDIR
@@ -732,16 +765,13 @@ extern unsigned short stopchar_map[];
 extern int just_print_flag, run_silent, ignore_errors_flag, keep_going_flag;
 extern int print_data_base_flag, question_flag, touch_flag, always_make_flag;
 extern int env_overrides, no_builtin_rules_flag, no_builtin_variables_flag;
-extern int print_version_flag, check_symlink_flag, posix_pedantic;
+extern int print_version_flag, check_symlink_flag;
 extern int not_parallel, second_expansion, clock_skew_detected;
 extern int rebuilding_makefiles, one_shell, output_sync, verify_flag;
 extern int export_all_variables;
 extern unsigned long command_count;
 
-extern const char *default_shell;
 
-/* can we run commands via 'sh -c xxx' or must we use batch files? */
-extern int batch_mode_shell;
 
 #define GNUMAKEFLAGS_NAME       "GNUMAKEFLAGS"
 #define MAKEFLAGS_NAME          "MAKEFLAGS"
diff --git a/src/misc.c b/src/misc.c
index b36248f0..b62a33ab 100644
--- a/src/misc.c
+++ b/src/misc.c
@@ -22,7 +22,9 @@ this program.  If not, see <https://www.gnu.org/licenses/>.  */
 
 #include <assert.h>
 #include <stdarg.h>
-
+#ifdef _WIN32
+#define HAVE_UNISTD_H
+#endif
 #if MK_OS_W32
 # include <windows.h>
 # include <io.h>
@@ -183,7 +185,7 @@ collapse_continuations (char *line)
           if (dollar)
             --out;
 
-          if (!posix_pedantic)
+          if (shell_info.posix_pedantic)
             while (out > line && ISBLANK (out[-1]))
               --out;
 
diff --git a/src/read.c b/src/read.c
index 2e30ce17..c330fc27 100644
--- a/src/read.c
+++ b/src/read.c
@@ -26,7 +26,7 @@ struct passwd *getpwnam (char *name);
 #else
 # include <pwd.h>
 #endif
-
+#include "filename.h"
 #include "filedef.h"
 #include "dep.h"
 #include "job.h"
@@ -1870,9 +1870,9 @@ check_specials (struct nameseq *files, int set_default)
     {
       const char* nm = t->name;
 
-      if (!posix_pedantic && streq (nm, ".POSIX"))
+      if (! shell_info.posix_pedantic && streq (nm, ".POSIX"))
         {
-          posix_pedantic = 1;
+		  shell_posix_pedantic_set(1);
           define_variable_cname (".SHELLFLAGS", "-ec", o_default, 0);
           /* These default values are based on IEEE Std 1003.1-2008.
              It requires '-O 1' for [CF]FLAGS, but GCC doesn't allow
@@ -1913,11 +1913,7 @@ check_specials (struct nameseq *files, int set_default)
 
           /* See if this target's name does not start with a '.',
              unless it contains a slash.  */
-          if (*nm == '.' && strchr (nm, '/') == 0
-#ifdef HAVE_DOS_PATHS
-              && strchr (nm, '\\') == 0
-#endif
-              )
+          if (*nm == '.' && LAST_SLASH_IN_PATH (nm) == 0)
             continue;
 
           /* If this file is a suffix, it can't be the default goal file.  */
@@ -2909,7 +2905,7 @@ construct_include_path (const char **arg_dirs)
           {
             size_t len = strlen (dir);
             /* If dir name is written with trailing slashes, discard them.  */
-            while (len > 1 && dir[len - 1] == '/')
+            while (len > 1 && ISSLASH(dir[len - 1]))
               --len;
             if (len > max_incl_len)
               max_incl_len = len;
@@ -2949,7 +2945,7 @@ construct_include_path (const char **arg_dirs)
             {
               size_t len = strlen (*ccpp);
               /* If dir name is written with trailing slashes, discard them.  */
-              while (len > 1 && (*ccpp)[len - 1] == '/')
+              while (len > 1 && ISSLASH((*ccpp)[len - 1]))
                 --len;
               if (len > max_incl_len)
                 max_incl_len = len;
@@ -2979,7 +2975,7 @@ char *
 tilde_expand (const char *name)
 {
 #if !MK_OS_VMS
-  if (name[1] == '/' || name[1] == '\0')
+  if (ISSLASH(name[1]) || name[1] == '\0')
     {
       char *home_dir;
       int is_variable;
@@ -3025,7 +3021,7 @@ tilde_expand (const char *name)
   else
     {
       struct passwd *pwent;
-      char *userend = strchr (name + 1, '/');
+      char *userend = LAST_SLASH_IN_PATH (name + 1);
       if (userend != 0)
         *userend = '\0';
       pwent = getpwnam (name + 1);
@@ -3189,11 +3185,11 @@ parse_file_seq (char **stringp, size_t size, int stopmap,
             s += 2;
 #endif
           /* Skip leading './'s.  */
-          while (p - s > 2 && s[0] == '.' && s[1] == '/')
+          while (p - s > 2 && s[0] == '.' && ISSLASH( s[1] ))
             {
               /* Skip "./" and all following slashes.  */
               s += 2;
-              while (*s == '/')
+              while (ISSLASH(*s))
                 ++s;
             }
         }
diff --git a/src/remake.c b/src/remake.c
index 9d7ae8fd..36c076f4 100644
--- a/src/remake.c
+++ b/src/remake.c
@@ -24,7 +24,7 @@ this program.  If not, see <https://www.gnu.org/licenses/>.  */
 #include "debug.h"
 
 #include <assert.h>
-
+#include "filename.h"
 #ifdef HAVE_FCNTL_H
 #include <fcntl.h>
 #else
@@ -40,7 +40,8 @@ this program.  If not, see <https://www.gnu.org/licenses/>.  */
 #include <sys/stat.h>
 #if defined(_MSC_VER) && _MSC_VER > 1200
 /* VC7 or later supports _stat64 to access 64-bit file size. */
-#define STAT _stat64
+//#define STAT _stat64
+#define STAT stat
 #else
 #define STAT stat
 #endif
@@ -1499,7 +1500,7 @@ f_mtime (struct file *file, int search)
               name_len = strlen (name) - strlen (file->name) - 1;
 #else
               name_len = strlen (name) - strlen (file->name);
-              if (name[name_len - 1] == '/')
+              if ( ISSLASH(name[name_len - 1]))
                   name_len--;
 #endif
               if (gpath_search (name, name_len))
@@ -1728,7 +1729,7 @@ name_mtime (const char *name)
           /* If the target is fully-qualified or the source is just a
              filename, then the new path is the target.  Otherwise it's the
              source directory plus the target.  */
-          if (lbuf[0] == '/' || (p = strrchr (lpath, '/')) == NULL)
+          if ( IS_ABSOLUTE_FILE_NAME(lbuf[0])  || (p = LAST_SLASH_IN_PATH (lpath)) == NULL)
             strcpy (lpath, lbuf);
           else if ((p - lpath) + llen + 2 > GET_PATH_MAX)
             /* Eh?  Path too long!  Again, just go with what we have.  */
diff --git a/src/rule.c b/src/rule.c
index d6bad472..b370365c 100644
--- a/src/rule.c
+++ b/src/rule.c
@@ -24,6 +24,7 @@ this program.  If not, see <https://www.gnu.org/licenses/>.  */
 #include "commands.h"
 #include "variable.h"
 #include "rule.h"
+#include "filename.h"
 
 static void freerule (struct rule *rule, struct rule *lastrule);
 
@@ -180,7 +181,7 @@ snap_implicit_rules (void)
             p = strrchr (dname, ':');
           p2 = p ? strchr (p, '%') : 0;
 #else
-          const char *p = strrchr (dname, '/');
+          const char *p = LAST_SLASH_IN_PATH (dname);
           const char *p2 = p ? strchr (p, '%') : 0;
 #endif
           ndeps++;
@@ -332,7 +333,7 @@ convert_to_pattern (void)
         {
           if (!f->deps)
             f->suffix = 1;
-          else if (!posix_pedantic)
+          else if (!shell_info.posix_pedantic)
             {
               O (error, &f->cmds->fileinfo,
                  _("warning: ignoring prerequisites on suffix rule definition"));
@@ -366,7 +367,7 @@ convert_to_pattern (void)
              POSIX, but for now preserve the old behavior and warn about it.  */
           if (f->deps != 0)
             {
-              if (posix_pedantic)
+              if (shell_info.posix_pedantic)
                 continue;
               O (error, &f->cmds->fileinfo,
                  _("warning: ignoring prerequisites on suffix rule definition"));
diff --git a/src/variable.c b/src/variable.c
index af3d6a40..3828378a 100644
--- a/src/variable.c
+++ b/src/variable.c
@@ -25,7 +25,9 @@ this program.  If not, see <https://www.gnu.org/licenses/>.  */
 #include "commands.h"
 #include "variable.h"
 #include "os.h"
+#include "filename.h"
 #include "rule.h"
+#define _lookup_variable(str) (lookup_variable (str, strlen(str)))
 #if MK_OS_W32
 #include "pathstuff.h"
 #endif
@@ -932,6 +934,7 @@ define_automatic_variables (void)
 {
   struct variable *v;
   char buf[200];
+  const char* default_shell = shell_get_default();
 
   sprintf (buf, "%u", makelevel);
   define_variable_cname (MAKELEVEL_NAME, buf, o_env, 0);
@@ -945,20 +948,28 @@ define_automatic_variables (void)
   define_variable_cname ("MAKE_VERSION", buf, o_default, 0);
   define_variable_cname ("MAKE_HOST", make_host, o_default, 0);
 
-#if MK_OS_DOS
   /* Allow to specify a special shell just for Make,
      and use $COMSPEC as the default $SHELL when appropriate.  */
-  {
     static char shell_str[] = "SHELL";
     const int shlen = sizeof (shell_str) - 1;
-    struct variable *mshp = lookup_variable ("MAKESHELL", 9);
+  struct variable* mshp = _lookup_variable("MAKESHELL");
+  if (mshp) {
+	  (void)define_variable(shell_str, shlen, mshp->value, o_env_override, 0);
+	  shell_set(mshp->value, "MAKESHELL ENV var");
+  }
+  struct variable* nmshp = _lookup_variable("NOMAKESHELLS");
+  if (nmshp)
+	  shell_set_banned_shells(nmshp->value);
+  struct variable* dmshp = _lookup_variable("DEFAULTMAKESHELL");
+  if (dmshp)
+	  shell_set_user_default_shell(dmshp->value);
+#if MK_OS_DOS || MK_OS_W32
+  {
     struct variable *comp = lookup_variable ("COMSPEC", 7);
 
     /* $(MAKESHELL) overrides $(SHELL) even if -e is in effect.  */
-    if (mshp)
-      (void) define_variable (shell_str, shlen,
-                              mshp->value, o_env_override, 0);
-    else if (comp)
+
+     if (!mshp && comp)
       {
         /* $(COMSPEC) shouldn't override $(SHELL).  */
         struct variable *shp = lookup_variable (shell_str, shlen);
@@ -1019,7 +1030,7 @@ define_automatic_variables (void)
 
   /* This won't override any definition, but it will provide one if there
      isn't one there.  */
-  v = define_variable_cname ("SHELL", default_shell, o_default, 0);
+  v = define_variable_cname ("SHELL", shell_get_default(), o_default, 0);
 #if MK_OS_DOS
   v->export = v_export;  /*  Export always SHELL.  */
 #endif
@@ -1030,7 +1041,7 @@ define_automatic_variables (void)
      that problem above. */
 #if !MK_OS_DOS && !MK_OS_OS2
   /* Don't let SHELL come from the environment.  */
-  if (*v->value == '\0' || v->origin == o_env || v->origin == o_env_override)
+  if (*v->value == '\0' || v->origin == o_env) // if they explicitly use the ENV override var MAKESHELL we should always trust it.
     {
       free (v->value);
       v->origin = o_file;
@@ -1584,10 +1595,7 @@ do_variable_definition (const floc *flocp, const char *varname, const char *valu
           char *fake_env[2];
           size_t pathlen = 0;
 
-          shellbase = strrchr (newval, '/');
-          bslash = strrchr (newval, '\\');
-          if (!shellbase || bslash > shellbase)
-            shellbase = bslash;
+          shellbase = LAST_SLASH_IN_PATH (newval);
           if (!shellbase && newval[1] == ':')
             shellbase = newval + 1;
           if (shellbase)
@@ -1628,20 +1636,21 @@ do_variable_definition (const floc *flocp, const char *varname, const char *valu
   if ((origin == o_file || origin == o_override || origin == o_command)
       && streq (varname, "SHELL"))
     {
-      extern const char *default_shell;
 
       /* Call shell locator function. If it returns TRUE, then
          set no_default_sh_exe to indicate sh was found and
          set new value for SHELL variable.  */
 
-      if (find_and_set_default_shell (newval))
+		  if (shell_is_banned(newval))
+			v = _lookup_variable(varname);
+		  else if ( shell_set_and_detect(newval, "do_variable_definition: SHELL variable read"))
         {
-          v = define_variable_in_set (varname, strlen (varname), default_shell,
+			  v = define_variable_in_set(varname, strlen(varname), shell_get_default(),
                                       origin, flavor == f_recursive,
                                       (scope == s_global ? NULL
                                        : current_variable_set_list->set),
                                       flocp);
-          no_default_sh_exe = 0;
+			  shell_info.have_no_default_sh_exe = 0;
         }
       else
         {
@@ -1649,17 +1658,18 @@ do_variable_definition (const floc *flocp, const char *varname, const char *valu
 
           alloc_value = allocated_expand_string (newval);
 
-          if (find_and_set_default_shell (alloc_value))
+			  if (shell_is_banned(newval))
+				  v = _lookup_variable(varname);
+			  else if ( shell_set_and_detect(alloc_value, "do_variable_definition: SHELL variable read and expanded in makefile"))
             {
               v = define_variable_in_set (varname, strlen (varname), newval,
                                           origin, flavor == f_recursive,
                                           (scope == s_global ? NULL
                                            : current_variable_set_list->set),
                                           flocp);
-              no_default_sh_exe = 0;
+				  shell_info.have_no_default_sh_exe = 0;
             }
-          else
-            v = lookup_variable (varname, strlen (varname));
+
 
           free (tp);
         }
diff --git a/src/variable.h b/src/variable.h
index 9cedebcd..4cb0d606 100644
--- a/src/variable.h
+++ b/src/variable.h
@@ -13,6 +13,7 @@ A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License along with
 this program.  If not, see <https://www.gnu.org/licenses/>.  */
+#pragma once
 
 #include "hash.h"
 
diff --git a/src/vms_export_symbol.c b/src/vms_export_symbol.c
index 51c63b1f..ad9bfcc8 100644
--- a/src/vms_export_symbol.c
+++ b/src/vms_export_symbol.c
@@ -34,6 +34,7 @@ this program.  If not, see <https://www.gnu.org/licenses/>.  */
 #include <ssdef.h>
 #include <unixlib.h>
 #include <libclidef.h>
+#include "filename.h"
 
 #pragma member_alignment save
 #pragma nomember_alignment longword
@@ -373,7 +374,7 @@ create_foreign_command (const char * command, const char * image)
 
   vms_command[0] = '$';
   vms_command[1] = 0;
-  if (image[0] == '/')
+  if (ISSLASH( image[0] ) )
     {
 #if __CRTL_VER >= 70301000
       /* Current decc$to_vms is reentrant */
diff --git a/src/vms_progname.c b/src/vms_progname.c
index cd5f3ff8..ccab44e1 100644
--- a/src/vms_progname.c
+++ b/src/vms_progname.c
@@ -64,7 +64,7 @@ this program.  If not, see <https://www.gnu.org/licenses/>.  */
 #include <string.h>
 #include <ctype.h>
 #include <stdlib.h>
-
+#include "filename.h"
 #include <descrip.h>
 #include <dvidef.h>
 #include <efndef.h>
@@ -155,7 +155,7 @@ set_program_name (const char *argv0)
   /* from the run command and needs to be fixed up.                        */
   /* If the DECC$POSIX_COMPLIANT_PATHNAMES is set to 2, then it is the     */
   /* DISK$VOLUME that will be present, and it will still need to be fixed. */
-  if (argv0[0] == '/')
+  if (IS_ABSOLUTE_FILE_NAME( argv0[0] ))
     {
       char * nextslash;
       int length;
@@ -186,7 +186,7 @@ set_program_name (const char *argv0)
       /* SYS$GETDVI will append the volume name to this */
       strcpy (diskvolnam, "DISK$");
 
-      nextslash = strchr (&argv0[1], '/');
+      nextslash = strpbrk (&argv0[1], SLASHES);
       if (nextslash != NULL)
         {
           length = nextslash - argv0 - 1;
@@ -381,7 +381,7 @@ set_program_name (const char *argv0)
         /* This means it is probably the name from a DCL command */
         /* Find the last slash which separates the file from the */
         /* path. */
-        lastslash = strrchr (argv0, '/');
+        lastslash = LAST_SLASH_IN_PATH (argv0);
 
         if (lastslash != NULL) {
             int i;
diff --git a/src/vmsify.c b/src/vmsify.c
index c3c96105..636cd543 100644
--- a/src/vmsify.c
+++ b/src/vmsify.c
@@ -23,7 +23,7 @@ this program.  If not, see <https://www.gnu.org/licenses/>.  */
 #include <ctype.h>
 
 #include "makeint.h"
-
+#include "filename.h"
 #if MK_OS_VMS
 #include <unixlib.h>
 #include <stdlib.h>
@@ -257,7 +257,7 @@ vmsify (const char *name, int type)
 
       if (*t == '$')
         {
-          if (strchr (name, '/') == 0)
+          if (LAST_SLASH_IN_PATH (name) == 0)
             {
               strcpy (vmsname, name);
               if ((type == 1) && (s1 != 0) && (s2 == 0))
diff --git a/src/vmsjobs.c b/src/vmsjobs.c
index 0950d217..a7b43d23 100644
--- a/src/vmsjobs.c
+++ b/src/vmsjobs.c
@@ -19,7 +19,7 @@ this program.  If not, see <https://www.gnu.org/licenses/>.  */
 #include <string.h>
 #include <descrip.h>
 #include <clidef.h>
-
+#include "filename.h"
 /* TODO - VMS specific header file conditionally included in makeint.h */
 
 #include <stsdef.h>
@@ -1045,6 +1045,9 @@ child_execute_job (struct childbase *child, int good_stdin UNUSED, char *argv)
           UPDATE_TOKEN;
           break;
         case '/':
+#ifdef _WIN32
+        case DIR_SEPARATOR:
+#endif
           /* Unix path or VMS option start, read until non-path symbol */
           if (assignment_hack != 0)
             assignment_hack++;
diff --git a/src/vpath.c b/src/vpath.c
index bd2055ec..a2c77357 100644
--- a/src/vpath.c
+++ b/src/vpath.c
@@ -20,6 +20,7 @@ this program.  If not, see <https://www.gnu.org/licenses/>.  */
 #if MK_OS_W32
 #include "pathstuff.h"
 #endif
+#include "filename.h"
 
 
 /* Structure used to represent a selective VPATH searchpath.  */
@@ -237,7 +238,7 @@ construct_vpath_list (char *pattern, char *dirpath)
       /* We need also to leave alone a trailing slash in "d:/".  */
       if (len > 3 || (len > 1 && v[1] != ':'))
 #endif
-      if (len > 1 && p[-1] == '/')
+      if (len > 1 && ISSLASH( p[-1]))
         --len;
 
       /* Put the directory on the vpath list.  */
@@ -335,15 +336,9 @@ selective_vpath_search (struct vpath *path, const char *file,
      NAME_DPLEN gets the length of the prefix; FILENAME gets the pointer to
      the name-within-directory and FLEN is its length.  */
 
-  n = strrchr (file, '/');
-#ifdef HAVE_DOS_PATHS
+  n = LAST_SLASH_IN_PATH (file);
   /* We need the rightmost slash or backslash.  */
-  {
-    const char *bslash = strrchr (file, '\\');
-    if (!n || bslash > n)
-      n = bslash;
-  }
-#endif
+
   name_dplen = n != 0 ? n - file : 0;
   filename = name_dplen > 0 ? n + 1 : file;
   if (name_dplen > 0)
@@ -384,7 +379,7 @@ selective_vpath_search (struct vpath *path, const char *file,
 #endif
       /* Now add the name-within-directory at the end of NAME.  */
 #if !MK_OS_VMS
-      if (p != name && p[-1] != '/')
+      if (p != name && ! ISSLASH( p[-1] ))
         {
           *p = '/';
           memcpy (p + 1, filename, flen + 1);
@@ -392,7 +387,7 @@ selective_vpath_search (struct vpath *path, const char *file,
       else
 #else
       /* VMS use a slash if no directory terminator present */
-      if (p != name && p[-1] != '/' && p[-1] != ':' &&
+      if (p != name && ! ISSLASH( p[-1] ) && p[-1] != ':' &&
           p[-1] != '>' && p[-1] != ']')
         {
           *p = '/';
@@ -444,7 +439,7 @@ selective_vpath_search (struct vpath *path, const char *file,
 
 #if MK_OS_VMS
           /* For VMS syntax just use the original vpath */
-          if (*p != '/')
+          if (ISSLASH( *p ))
             exists_in_cache = exists = dir_file_exists_p (vpath[i], filename);
           else
 #endif
diff --git a/src/w32/compat/posixfcn.c b/src/w32/compat/posixfcn.c
index 7ffbb535..f4f73591 100644
--- a/src/w32/compat/posixfcn.c
+++ b/src/w32/compat/posixfcn.c
@@ -119,7 +119,7 @@ dlclose (void *handle)
 
 
 #endif  /* MAKE_LOAD */
-
+#undef isatty
 
 /* MS runtime's isatty returns non-zero for any character device,
    including the null device, which is not what we want.  */
diff --git a/src/w32/pathstuff.c b/src/w32/pathstuff.c
index 89c23f37..4060912d 100644
--- a/src/w32/pathstuff.c
+++ b/src/w32/pathstuff.c
@@ -18,7 +18,7 @@ this program.  If not, see <https://www.gnu.org/licenses/>.  */
 #include <string.h>
 #include <stdlib.h>
 #include "pathstuff.h"
-
+#include "filename.h"
 /*
  * Convert delimiter separated vpath to Canonical format.
  */
@@ -110,7 +110,7 @@ w32ify(const char *filename, int resolve)
 
     for (p = w32_path; p && *p; p++)
       if (*p == '\\')
-        *p = '/';
+		  *p = '/';
 
     return w32_path;
 }
diff --git a/src/w32/subproc/sub_proc.c b/src/w32/subproc/sub_proc.c
index ad9e2570..1a5e85fa 100644
--- a/src/w32/subproc/sub_proc.c
+++ b/src/w32/subproc/sub_proc.c
@@ -29,7 +29,7 @@ this program.  If not, see <https://www.gnu.org/licenses/>.  */
 #include <process.h>  /* for msvc _beginthreadex, _endthreadex */
 #include <signal.h>
 #include <windows.h>
-
+#include "filename.h"
 #include "filedef.h"
 #include "variable.h"
 #include "sub_proc.h"
@@ -674,7 +674,7 @@ process_begin(
                         /*
                          *  Find base name of shell
                          */
-                        shell_name = strrchr( buf, '/');
+                        shell_name = LAST_SLASH_IN_PATH( buf );
                         if (shell_name) {
                                 shell_name++;
                         } else {
diff --git a/src/w32/subproc/w32err.c b/src/w32/subproc/w32err.c
index ddcfa5d5..9298a94a 100644
--- a/src/w32/subproc/w32err.c
+++ b/src/w32/subproc/w32err.c
@@ -14,6 +14,7 @@ A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 You should have received a copy of the GNU General Public License along with
 this program.  If not, see <https://www.gnu.org/licenses/>.  */
 
+#include "config.h"
 #include <stdlib.h>
 #include <windows.h>
 #include "makeint.h"
